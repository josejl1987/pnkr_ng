This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
CMakeLists.txt
include/pnkr/core/common.hpp
include/pnkr/core/Handle.h
include/pnkr/core/logger.hpp
include/pnkr/core/profiler.hpp
include/pnkr/core/Timer.h
include/pnkr/engine.hpp
include/pnkr/platform/Input.hpp
include/pnkr/platform/window.hpp
include/pnkr/renderer/debug/DebugLayer.hpp
include/pnkr/renderer/debug/LineCanvas3D.hpp
include/pnkr/renderer/geometry/mesh.h
include/pnkr/renderer/geometry/Vertex.h
include/pnkr/renderer/geometry/VertexInputDescription.h
include/pnkr/renderer/material/Material.hpp
include/pnkr/renderer/pipeline/Pipeline.h
include/pnkr/renderer/renderer_config.hpp
include/pnkr/renderer/renderer.hpp
include/pnkr/renderer/rhi_renderer.hpp
include/pnkr/renderer/scene/Camera.hpp
include/pnkr/renderer/scene/CameraController.hpp
include/pnkr/renderer/scene/Model.hpp
include/pnkr/renderer/scene/Node.hpp
include/pnkr/renderer/scene/RHIScene.hpp
include/pnkr/renderer/scene/Scene.hpp
include/pnkr/renderer/scene/Skybox.hpp
include/pnkr/renderer/scene/transform.hpp
include/pnkr/renderer/vulkan/bindless/bindless_manager.hpp
include/pnkr/renderer/vulkan/image/vulkan_image.hpp
include/pnkr/renderer/vulkan/image/vulkan_sampler.hpp
include/pnkr/renderer/vulkan/pipeline/compute_pipeline.hpp
include/pnkr/renderer/vulkan/pipeline/PipelineBuilder.h
include/pnkr/renderer/vulkan/pipeline/PipelineConfig.h
include/pnkr/renderer/vulkan/PushConstants.h
include/pnkr/renderer/vulkan/vma.cpp
include/pnkr/renderer/vulkan/vulkan_buffer.hpp
include/pnkr/renderer/vulkan/vulkan_command_buffer.hpp
include/pnkr/renderer/vulkan/vulkan_context.hpp
include/pnkr/renderer/vulkan/vulkan_descriptor.hpp
include/pnkr/renderer/vulkan/vulkan_device.hpp
include/pnkr/renderer/vulkan/vulkan_pipeline.hpp
include/pnkr/renderer/vulkan/vulkan_render_target.h
include/pnkr/renderer/vulkan/vulkan_swapchain.hpp
include/pnkr/renderer/vulkan/vulkan_sync_manager.h
include/pnkr/rhi/rhi_buffer.hpp
include/pnkr/rhi/rhi_command_buffer.hpp
include/pnkr/rhi/rhi_descriptor.hpp
include/pnkr/rhi/rhi_device.hpp
include/pnkr/rhi/rhi_factory.hpp
include/pnkr/rhi/rhi_pipeline_builder.hpp
include/pnkr/rhi/rhi_pipeline.hpp
include/pnkr/rhi/rhi_sampler.hpp
include/pnkr/rhi/rhi_shader.hpp
include/pnkr/rhi/rhi_swapchain.hpp
include/pnkr/rhi/rhi_texture.hpp
include/pnkr/rhi/rhi_types.hpp
include/pnkr/rhi/vulkan/vulkan_buffer.hpp
include/pnkr/rhi/vulkan/vulkan_command_buffer.hpp
include/pnkr/rhi/vulkan/vulkan_descriptor.hpp
include/pnkr/rhi/vulkan/vulkan_device.hpp
include/pnkr/rhi/vulkan/vulkan_pipeline.hpp
include/pnkr/rhi/vulkan/vulkan_sampler.hpp
include/pnkr/rhi/vulkan/vulkan_swapchain.hpp
include/pnkr/rhi/vulkan/vulkan_texture.hpp
include/pnkr/rhi/vulkan/vulkan_utils.hpp
include/pnkr/ui/imgui_layer.hpp
src/core/implementations.cpp
src/core/logger.cpp
src/platform/window.cpp
src/renderer/debug/DebugLayer.cpp
src/renderer/debug/LineCanvas3D.cpp
src/renderer/debug/shaders/line_canvas.frag
src/renderer/debug/shaders/line_canvas.vert
src/renderer/geometry/mesh.cpp
src/renderer/renderer.cpp
src/renderer/rhi_renderer.cpp
src/renderer/scene.cpp
src/renderer/scene/Model.cpp
src/renderer/scene/RHIScene.cpp
src/renderer/scene/Skybox.cpp
src/renderer/ui/imgui_layer.cpp
src/renderer/vulkan/bindless/bindless_manager.cpp
src/renderer/vulkan/image/vulkan_image.cpp
src/renderer/vulkan/image/vulkan_sampler.cpp
src/renderer/vulkan/pipeline/compute_pipeline.cpp
src/renderer/vulkan/pipeline/pipeline_builder.cpp
src/renderer/vulkan/vulkan_buffer.cpp
src/renderer/vulkan/vulkan_command_buffer.cpp
src/renderer/vulkan/vulkan_context.cpp
src/renderer/vulkan/vulkan_descriptor.cpp
src/renderer/vulkan/vulkan_device.cpp
src/renderer/vulkan/vulkan_dispatch.cpp
src/renderer/vulkan/vulkan_pipeline.cpp
src/renderer/vulkan/vulkan_render_target.cpp
src/renderer/vulkan/vulkan_swapchain.cpp
src/renderer/vulkan/vulkan_sync_manager.cpp
src/rhi/rhi_pipeline_builder.cpp
src/rhi/rhi_shader.cpp
src/rhi/vulkan/rhi_factory.cpp
src/rhi/vulkan/vulkan_buffer.cpp
src/rhi/vulkan/vulkan_command_buffer.cpp
src/rhi/vulkan/vulkan_descriptor.cpp
src/rhi/vulkan/vulkan_device.cpp
src/rhi/vulkan/vulkan_pipeline.cpp
src/rhi/vulkan/vulkan_sampler.cpp
src/rhi/vulkan/vulkan_swapchain.cpp
src/rhi/vulkan/vulkan_texture.cpp
src/rhi/vulkan/vulkan_utils.cpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CMakeLists.txt">
# ============================================================================
# PNKR Engine Static Library
# ============================================================================
add_library(pnkr_engine STATIC
        src/core/implementations.cpp
        src/renderer/vulkan/vulkan_dispatch.cpp
        src/renderer/vulkan/vulkan_context.cpp
        include/pnkr/renderer/vulkan/vulkan_sync_manager.h
        src/renderer/vulkan/vulkan_sync_manager.cpp
        include/pnkr/renderer/vulkan/vma.cpp
        include/pnkr/renderer/geometry/Vertex.h
        include/pnkr/renderer/geometry/VertexInputDescription.h
        include/pnkr/renderer/vulkan/pipeline/PipelineConfig.h
        include/pnkr/renderer/pipeline/Pipeline.h
        include/pnkr/renderer/geometry/mesh.h
        src/renderer/geometry/mesh.cpp
        include/pnkr/core/Handle.h
        include/pnkr/renderer/vulkan/PushConstants.h
        include/pnkr/renderer/scene/camera.hpp
        src/renderer/scene.cpp
        src/renderer/scene/Model.cpp
        include/pnkr/core/Timer.h
        include/pnkr/renderer/vulkan/image/vulkan_image.hpp
        src/renderer/vulkan/image/vulkan_image.cpp
        include/pnkr/renderer/vulkan/image/vulkan_sampler.hpp
        src/renderer/vulkan/image/vulkan_sampler.cpp
        src/renderer/vulkan/vulkan_descriptor.cpp
        include/pnkr/renderer/scene/Model.hpp
        include/pnkr/renderer/scene/Node.hpp
        include/pnkr/renderer/scene/RHIScene.hpp
        include/pnkr/renderer/scene/Skybox.hpp
        include/pnkr/renderer/material/Material.hpp
        include/pnkr/renderer/vulkan/vulkan_render_target.h
        src/renderer/vulkan/vulkan_render_target.cpp
        include/pnkr/renderer/vulkan/pipeline/PipelineBuilder.h
        src/renderer/vulkan/pipeline/pipeline_builder.cpp
        include/pnkr/ui/imgui_layer.hpp
        src/renderer/ui/imgui_layer.cpp
        include/pnkr/renderer/vulkan/pipeline/compute_pipeline.hpp
        src/renderer/vulkan/pipeline/compute_pipeline.cpp
        include/pnkr/renderer/vulkan/bindless/bindless_manager.hpp
        src/renderer/vulkan/bindless/bindless_manager.cpp
        src/rhi/vulkan/vulkan_buffer.cpp
        src/rhi/vulkan/vulkan_command_buffer.cpp
        src/rhi/vulkan/vulkan_texture.cpp
        src/rhi/vulkan/vulkan_device.cpp
        src/rhi/vulkan/vulkan_descriptor.cpp
        src/rhi/vulkan/vulkan_swapchain.cpp
        src/rhi/vulkan/vulkan_utils.cpp
        src/rhi/vulkan/vulkan_buffer.cpp

        src/rhi/vulkan/vulkan_texture.cpp
        src/rhi/vulkan/vulkan_pipeline.cpp
        src/rhi/vulkan/vulkan_sampler.cpp
        src/rhi/vulkan/rhi_factory.cpp
        include/pnkr/renderer/rhi_renderer.hpp
        src/renderer/rhi_renderer.cpp
        include/pnkr/rhi/rhi_pipeline_builder.hpp
        src/rhi/rhi_pipeline_builder.cpp
        include/pnkr/rhi/rhi_shader.hpp
        src/rhi/rhi_shader.cpp
        include/pnkr/renderer/scene/RHIScene.hpp
        src/renderer/scene/RHIScene.cpp
        include/pnkr/renderer/scene/Skybox.hpp
        src/renderer/scene/Skybox.cpp
        include/pnkr/renderer/debug/LineCanvas3D.hpp
        src/renderer/debug/LineCanvas3D.cpp
        include/pnkr/renderer/debug/DebugLayer.hpp
        src/renderer/debug/DebugLayer.cpp
        src/renderer/debug/shaders/line_canvas.vert
        src/renderer/debug/shaders/line_canvas.frag)

target_sources(pnkr_engine
  PRIVATE
    src/core/logger.cpp
    src/platform/window.cpp
    src/renderer/renderer.cpp
        src/renderer/vulkan/vulkan_buffer.cpp
        src/renderer/vulkan/vulkan_command_buffer.cpp
        src/renderer/vulkan/vulkan_device.cpp
        src/renderer/vulkan/vulkan_pipeline.cpp
        src/renderer/vulkan/vulkan_swapchain.cpp
        src/renderer/vulkan/vulkan_context.cpp

        PUBLIC
    FILE_SET headers
    TYPE HEADERS
    FILES
      include/pnkr/engine.hpp
      include/pnkr/core/logger.hpp
      include/pnkr/core/profiler.hpp
      include/pnkr/core/common.hpp
      include/pnkr/platform/window.hpp
      include/pnkr/renderer/renderer_config.hpp
      include/pnkr/renderer/renderer.hpp
      include/pnkr/rhi/rhi_descriptor.hpp
      include/pnkr/rhi/rhi_swapchain.hpp
      include/pnkr/rhi/vulkan/vulkan_swapchain.hpp
      include/pnkr/rhi/vulkan/vulkan_descriptor.hpp
        include/pnkr/renderer/vulkan/vulkan_buffer.hpp
        include/pnkr/renderer/vulkan/vulkan_command_buffer.hpp
        include/pnkr/renderer/vulkan/vulkan_context.hpp
        include/pnkr/renderer/vulkan/vulkan_device.hpp
        include/pnkr/renderer/vulkan/vulkan_pipeline.hpp
        include/pnkr/renderer/vulkan/vulkan_swapchain.hpp
        include/pnkr/renderer/scene/Model.hpp
        include/pnkr/renderer/scene/Node.hpp
        include/pnkr/renderer/scene/RHIScene.hpp
        include/pnkr/renderer/scene/Skybox.hpp
        include/pnkr/renderer/material/Material.hpp
)

# ============================================================================
# Compilation Settings
# ============================================================================
target_compile_features(pnkr_engine PUBLIC cxx_std_20)

target_include_directories(pnkr_engine
  PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
  PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

target_compile_definitions(pnkr_engine
  PUBLIC
    SPDLOG_USE_STD_FORMAT=1
    GLM_FORCE_RADIANS
    GLM_FORCE_DEPTH_ZERO_TO_ONE
    GLM_ENABLE_EXPERIMENTAL
    TRACY_ENABLE=1
    PRIVATE
    VULKAN_HPP_DISPATCH_LOADER_DYNAMIC=1

)

# Unity build to reduce per-TU header parsing overhead
set_target_properties(pnkr_engine PROPERTIES
  UNITY_BUILD ON
  UNITY_BUILD_BATCH_SIZE 8
)
set_source_files_properties(src/core/implementations.cpp PROPERTIES UNITY_BUILD OFF)

# Precompiled headers to avoid repeatedly parsing heavy includes like vulkan.hpp
target_precompile_headers(pnkr_engine PRIVATE
  <vector>
  <memory>
  <string>
  <stdexcept>
  <vulkan/vulkan.hpp>
  <spdlog/spdlog.h>
  <SDL3/SDL.h>
)

# ============================================================================
# Dependencies
# ============================================================================
# Prefer header-only spdlog to avoid DLL/import-lib mismatches across toolchains
if(TARGET spdlog::spdlog_header_only)
  set(PNKR_SPDLOG_TARGET spdlog::spdlog_header_only)
  target_compile_definitions(pnkr_engine PUBLIC SPDLOG_HEADER_ONLY=1)
else()
  set(PNKR_SPDLOG_TARGET spdlog::spdlog)
endif()

target_link_libraries(pnkr_engine
  PUBLIC
    ${PNKR_SPDLOG_TARGET}
    SDL3::SDL3
    Vulkan::Vulkan

)

# GLM (this one is usually a proper CMake package)
find_package(glm CONFIG REQUIRED)
target_link_libraries(pnkr_engine PUBLIC glm::glm)



# VMA (vcpkg port may not export an imported target; treat as header-only unless a target exists)
find_package(VulkanMemoryAllocator CONFIG REQUIRED)   # provides GPUOpen::VulkanMemoryAllocator

target_link_libraries(pnkr_engine
        PUBLIC
        GPUOpen::VulkanMemoryAllocator
)
find_package(imgui CONFIG REQUIRED)

target_link_libraries(pnkr_engine PRIVATE imgui::imgui)
target_include_directories(pnkr_engine PUBLIC "${VMA_INCLUDE_DIR}")
target_compile_definitions(pnkr_engine PUBLIC VMA_STATIC_VULKAN_FUNCTIONS=0 VMA_DYNAMIC_VULKAN_FUNCTIONS=0)

set(TRACY_ENABLE ON CACHE BOOL "Enable Tracy Profiler")

if(TRACY_ENABLE)
  CPMAddPackage(
          NAME tracy
          GITHUB_REPOSITORY wolfpld/tracy
          GIT_TAG v0.13.1
          OPTIONS
          "TRACY_ENABLE ON"
          "TRACY_ON_DEMAND ON"      # Starts profiling only when server connects
          "TRACY_NO_BROADCAST OFF"
          "TRACY_NO_SYSTEM_VULKAN OFF" # Rely on the Vulkan SDK found by CMake
  )
endif()

find_package(tracy CONFIG REQUIRED)
target_link_libraries(pnkr_engine
  PUBLIC
        Tracy::TracyClient
)

find_package(spirv_cross_core CONFIG REQUIRED)
find_package(spirv_cross_glsl CONFIG REQUIRED)
find_package(spirv_cross_cpp CONFIG REQUIRED)
find_package(spirv_cross_hlsl CONFIG REQUIRED)
find_package(fastgltf CONFIG REQUIRED)

target_link_libraries(pnkr_engine
        PUBLIC
        spirv-cross-core
        spirv-cross-glsl
        spirv-cross-cpp
        spirv-cross-hlsl
        fastgltf::fastgltf
)

# ============================================================================
# Compiler Warnings (Per-target)
# ============================================================================
if(MSVC)
  target_compile_options(pnkr_engine PRIVATE /W4 /WX)
else()
  target_compile_options(pnkr_engine PRIVATE
    -Wall -Wextra -Wpedantic
    -Wno-unused-parameter  # SDL3 headers trigger this
  )
endif()

# ============================================================================
# Optimization
# ============================================================================
if(MSVC)
  target_compile_options(pnkr_engine PRIVATE
    $<$<CONFIG:Release>:/O2>
    $<$<CONFIG:Debug>:/Od>
  )
else()
  target_compile_options(pnkr_engine PRIVATE
    $<$<CONFIG:Release>:-O3>
    $<$<CONFIG:Debug>:-g -O0>
  )
endif()

# ============================================================================
# Install Configuration (for Stage 1+)
# ============================================================================
install(TARGETS pnkr_engine
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  RUNTIME DESTINATION bin
)
install(DIRECTORY include/ DESTINATION include)
</file>

<file path="include/pnkr/core/common.hpp">
#pragma once

/**
 * @file common.hpp
 * @brief Common utilities and macros for PNKR engine
 */

#include <utility>

// ============================================================================
// Assertion Macros (Debug-only)
// ============================================================================

#ifdef DEBUG
#define PNKR_ASSERT(condition, message)                                        \
  do {                                                                         \
    if (!(condition)) {                                                        \
      throw std::runtime_error(                                                \
          "ASSERTION FAILED: " + std::string(message) +                        \
          "\nFile: " __FILE__ "\nLine: " + std::to_string(__LINE__));          \
    }                                                                          \
  } while (0)
#else
#define PNKR_ASSERT(condition, message) (void)(0)
#endif

// ============================================================================
// Utilities
// ============================================================================

namespace pnkr::util {

/**
 * @brief RAII scope guard for cleanup operations
 * @example
 *   auto guard = make_scope_guard([] { std::cout << "cleanup\n"; });
 */
template <typename Func> class ScopeGuard {
public:
  explicit ScopeGuard(Func &&f) : m_func(std::move(f)) {}

  ~ScopeGuard() noexcept(noexcept(m_func())) {
    try {
      m_func();
    } catch (...) {
      // Silently ignore exceptions in destructors
    }
  }

private:
  Func m_func;
};

template <typename Func> [[nodiscard]] auto makeScopeGuard(Func &&func) {
  return ScopeGuard<Func>(std::forward<Func>(func));
}

} // namespace pnkr::util
</file>

<file path="include/pnkr/core/Handle.h">
//
// Created by Jose on 12/13/2025.
//

#pragma once

#include <cstdint>
#include <limits>
#include <compare>

namespace pnkr::core {

template <typename Tag>
struct Handle {
    uint32_t id = std::numeric_limits<uint32_t>::max();

    constexpr bool isValid() const { return id != std::numeric_limits<uint32_t>::max(); }
    constexpr void invalidate() { id = std::numeric_limits<uint32_t>::max(); }

    auto operator<=>(const Handle&) const = default;
    explicit operator bool() const { return isValid(); }
};

struct MeshTag {};
struct PipelineTag {};
struct TextureTag {};

} // namespace pnkr::core

using MeshHandle = pnkr::core::Handle<pnkr::core::MeshTag>;
using PipelineHandle = pnkr::core::Handle<pnkr::core::PipelineTag>;
using TextureHandle = pnkr::core::Handle<pnkr::core::TextureTag>;

constexpr uint32_t INVALID_ID = std::numeric_limits<uint32_t>::max();
inline constexpr MeshHandle INVALID_MESH_HANDLE{};
inline constexpr PipelineHandle INVALID_PIPELINE_HANDLE{};
inline constexpr TextureHandle INVALID_TEXTURE_HANDLE{};
</file>

<file path="include/pnkr/core/logger.hpp">
#pragma once

/**
 * @file logger.hpp
 * @brief Centralized logging facade using spdlog
 */

#include <memory>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/spdlog.h>
#include <string>

namespace pnkr::core {

class Logger {
public:
  // Static-only interface
  Logger() = delete;
  ~Logger() = delete;
  Logger(const Logger &) = delete;
  Logger &operator=(const Logger &) = delete;

  // Initialize logger (call once on startup)
  static void init(const std::string &pattern = "[%H:%M:%S] [%l] %v");

  // Logging interface (C++20 format strings)
  template <typename... Args>
  static void trace(spdlog::format_string_t<Args...> fmt, Args &&...args) {
    if (sLogger)
      sLogger->trace(fmt, std::forward<Args>(args)...);
  }

  template <typename... Args>
  static void debug(spdlog::format_string_t<Args...> fmt, Args &&...args) {
    if (sLogger)
      sLogger->debug(fmt, std::forward<Args>(args)...);
  }

  template <typename... Args>
  static void info(spdlog::format_string_t<Args...> fmt, Args &&...args) {
    if (sLogger)
      sLogger->info(fmt, std::forward<Args>(args)...);
  }

  template <typename... Args>
  static void warn(spdlog::format_string_t<Args...> fmt, Args &&...args) {
    if (sLogger)
      sLogger->warn(fmt, std::forward<Args>(args)...);
  }

  template <typename... Args>
  static void error(spdlog::format_string_t<Args...> fmt, Args &&...args) {
    if (sLogger) {
      sLogger->error(fmt, std::forward<Args>(args)...);
    }
  }

  template <typename... Args>
  static void critical(spdlog::format_string_t<Args...> fmt, Args &&...args) {
    if (sLogger) {
      sLogger->critical(fmt, std::forward<Args>(args)...);
    }
  }

private:
  static std::shared_ptr<spdlog::logger> sLogger;
};

} // namespace pnkr::core
</file>

<file path="include/pnkr/core/profiler.hpp">
#pragma once

#include <cstring>

#if defined(TRACY_ENABLE)
    #include <tracy/Tracy.hpp>
    #include <tracy/TracyVulkan.hpp>

    // CPU Profiling Macros
    #define PNKR_PROFILE_FRAME(name) FrameMarkNamed(name)
    #define PNKR_PROFILE_FUNCTION() ZoneScoped
    #define PNKR_PROFILE_SCOPE(name) ZoneScopedN(name)
    #define PNKR_PROFILE_TAG(str) ZoneText(str, strlen(str))

    // GPU Profiling Types
    using TracyContext = TracyVkCtx;

    // GPU Profiling Macros
    #define PNKR_PROFILE_GPU_CONTEXT(physDev, dev, queue, cmdBuffer) \
            TracyVkContext(physDev, dev, queue, cmdBuffer)

    #define PNKR_PROFILE_GPU_DESTROY(ctx) TracyVkDestroy(ctx)

    #define PNKR_PROFILE_GPU_COLLECT(ctx, cmdBuffer) TracyVkCollect(ctx, cmdBuffer)

    #define PNKR_PROFILE_GPU_ZONE(ctx, cmdBuffer, name) TracyVkZone(ctx, cmdBuffer, name)

#else
    // Empty macros when disabled
    #define PNKR_PROFILE_FRAME(name)
    #define PNKR_PROFILE_FUNCTION()
    #define PNKR_PROFILE_SCOPE(name)
    #define PNKR_PROFILE_TAG(str)

    using TracyContext = void*;

    #define PNKR_PROFILE_GPU_CONTEXT(physDev, dev, queue, cmdBuffer) nullptr
    #define PNKR_PROFILE_GPU_DESTROY(ctx)
    #define PNKR_PROFILE_GPU_COLLECT(ctx, cmdBuffer)
    #define PNKR_PROFILE_GPU_ZONE(ctx, cmdBuffer, name)

#endif
</file>

<file path="include/pnkr/core/Timer.h">
#pragma once

#include <chrono>

namespace pnkr::core {

    class Timer {
    public:
        Timer() { reset(); }

        void reset() {
            m_lastFrame = std::chrono::high_resolution_clock::now();
        }

        [[nodiscard]] float deltaTime() {
            auto now = std::chrono::high_resolution_clock::now();
            std::chrono::duration<float> delta = now - m_lastFrame;
            m_lastFrame = now;
            return delta.count();
        }

        [[nodiscard]] float elapsed() const {
            auto now = std::chrono::high_resolution_clock::now();
            std::chrono::duration<float> delta = now - m_lastFrame;
            return delta.count();
        }

    private:
        std::chrono::high_resolution_clock::time_point m_lastFrame;
    };

} // namespace pnkr::core
</file>

<file path="include/pnkr/engine.hpp">
#pragma once

/**
 * @file engine.hpp
 * @brief Main PNKR engine header - include this for all engine functionality
 */

#define PNKR_VERSION_MAJOR 0
#define PNKR_VERSION_MINOR 1
#define PNKR_VERSION_PATCH 0

#include "core/Timer.h"
#include "pnkr/core/logger.hpp"
#include "pnkr/platform/window.hpp"
#include "pnkr/renderer/renderer.hpp"
#include "pnkr/renderer/renderer_config.hpp"

namespace pnkr
{
    using Log = core::Logger;
    using Window = platform::Window;
    using Renderer = renderer::Renderer;
    using RendererConfig = renderer::RendererConfig;
    using Timer = core::Timer;
    using Input = platform::Input;
}
</file>

<file path="include/pnkr/platform/Input.hpp">
#pragma once

#include <SDL3/SDL.h>
#include <glm/vec2.hpp>
#include <array>

namespace pnkr::platform {

class Input {
public:
  Input() = default;

  void beginFrame() {
    m_mouseDelta = {0.0f, 0.0f};
    m_mouseWheel = 0.0f;
  }

  void processEvent(const SDL_Event& event) {
    switch (event.type) {
      case SDL_EVENT_KEY_DOWN:
        if (event.key.scancode < m_keys.size()) {
          m_keys[event.key.scancode] = true;
        }
        break;

      case SDL_EVENT_KEY_UP:
        if (event.key.scancode < m_keys.size()) {
          m_keys[event.key.scancode] = false;
        }
        break;

      case SDL_EVENT_MOUSE_MOTION:
        m_mousePos = {event.motion.x, event.motion.y};
        m_mouseDelta = {event.motion.xrel, event.motion.yrel};
        break;

      case SDL_EVENT_MOUSE_BUTTON_DOWN:
        if (event.button.button < m_mouseButtons.size()) {
          m_mouseButtons[event.button.button] = true;
        }
        break;

      case SDL_EVENT_MOUSE_BUTTON_UP:
        if (event.button.button < m_mouseButtons.size()) {
          m_mouseButtons[event.button.button] = false;
        }
        break;

      case SDL_EVENT_MOUSE_WHEEL:
        m_mouseWheel = event.wheel.y;
        break;

      default:
        break;
    }
  }

  [[nodiscard]] bool isKeyDown(SDL_Scancode key) const {
    return key < m_keys.size() && m_keys[key];
  }

  [[nodiscard]] bool isKeyUp(SDL_Scancode key) const {
    return !isKeyDown(key);
  }

  [[nodiscard]] bool isMouseButtonDown(uint8_t button) const {
    return button < m_mouseButtons.size() && m_mouseButtons[button];
  }

  [[nodiscard]] glm::vec2 mousePosition() const { return m_mousePos; }
  [[nodiscard]] glm::vec2 mouseDelta() const { return m_mouseDelta; }
  [[nodiscard]] float mouseWheel() const { return m_mouseWheel; }

private:
  std::array<bool, SDL_SCANCODE_COUNT> m_keys{};
  std::array<bool, 8> m_mouseButtons{}; // SDL supports up to 8 mouse buttons
  glm::vec2 m_mousePos{0.0f, 0.0f};
  glm::vec2 m_mouseDelta{0.0f, 0.0f};
  float m_mouseWheel{0.0f};
};

}
</file>

<file path="include/pnkr/platform/window.hpp">
#pragma once

#include <SDL3/SDL.h>
#include <functional>
#include <memory>
#include <string>

#include "Input.hpp"

namespace pnkr::platform {

class Window {
public:

  explicit Window(const std::string &title = "PNKR", int width = 800,
                  int height = 600, SDL_WindowFlags flags = 0);

  ~Window();

  Window(const Window &) = delete;
  Window &operator=(const Window &) = delete;

  Window(Window &&) = default;
  Window &operator=(Window &&) = default;

  [[nodiscard]] SDL_Window *get() const noexcept { return m_window.get(); }
  [[nodiscard]] SDL_Window *operator->() const noexcept {
    return m_window.get();
  }
  [[nodiscard]] operator SDL_Window *() const noexcept {
    return m_window.get();
  }

  using EventCallback = std::function<void(const SDL_Event&)>;

  void processEvents(Input* input = nullptr, const EventCallback& callback = nullptr) noexcept;

  [[nodiscard]] bool isRunning() const noexcept { return m_running; }

  void setTitle(const std::string &title) const;
  [[nodiscard]] int width() const noexcept;
  [[nodiscard]] int height() const noexcept;

  void setRelativeMouseMode(bool enabled) const {
    SDL_SetWindowRelativeMouseMode(m_window.get(), enabled);
  }

  [[nodiscard]] bool getRelativeMouseMode() const {
    return SDL_GetWindowRelativeMouseMode(m_window.get());
  }
private:

  struct SDLWindowDeleter {
    void operator()(SDL_Window *window) const noexcept {
      if (window) {
        SDL_DestroyWindow(window);
      }
    }
  };

  std::unique_ptr<SDL_Window, SDLWindowDeleter> m_window;
  bool m_running = true;
};

}
</file>

<file path="include/pnkr/renderer/debug/DebugLayer.hpp">
#pragma once

#include "pnkr/renderer/rhi_renderer.hpp"
#include "pnkr/rhi/rhi_types.hpp"
#include "pnkr/core/Handle.h"
#include "pnkr/renderer/scene/RHIScene.hpp"
#include <glm/glm.hpp>
#include <vector>
#include <memory>

namespace pnkr::renderer::debug
{
    class DebugLayer
    {
    public:
        DebugLayer();
        ~DebugLayer();

        // Disable copy/move
        DebugLayer(const DebugLayer&) = delete;
        DebugLayer& operator=(const DebugLayer&) = delete;
        DebugLayer(DebugLayer&&) = delete;
        DebugLayer& operator=(DebugLayer&&) = delete;

        // Lifecycle
        void initialize(RHIRenderer* renderer);

        // Scene integration (optional)
        void setScene(scene::RHIScene* scene) { m_scene = scene; }
        void clear(); // Clear debug objects for next frame

        // Drawing primitives (these create debug objects that are rendered with the scene)
        void line(const glm::vec3& start, const glm::vec3& end, const glm::vec3& color);
        void box(const glm::vec3& min, const glm::vec3& max, const glm::vec3& color);
        void box(const glm::mat4& transform, const glm::vec3& size, const glm::vec3& color);
        void plane(const glm::vec3& origin, const glm::vec3& v1, const glm::vec3& v2,
                   int segments1, int segments2, const glm::vec3& color);
        void frustum(const glm::mat4& viewProj, const glm::vec3& color);
        void circle(const glm::vec3& center, float radius, const glm::vec3& color, int segments = 32);
        void sphere(const glm::vec3& center, float radius, const glm::vec3& color, int segments = 16);

        // Direct rendering for immediate mode (when not using scene integration)
        void render(const RHIFrameContext& ctx, const glm::mat4& viewProj);

    private:
        struct LineVertex
        {
            glm::vec3 position;
            glm::vec3 color;
        };

        struct PushConstants
        {
            glm::mat4 mvp;
        };

        void createPipeline();
        void createVertexBuffer();
        void uploadVertexData();

        std::vector<LineVertex> m_vertices;
        std::unique_ptr<rhi::RHIBuffer> m_vertexBuffer;
        PipelineHandle m_pipeline;
        RHIRenderer* m_renderer = nullptr;
        scene::RHIScene* m_scene = nullptr;

        // Ring buffer management
        static constexpr uint32_t kMaxFrames = 3;
        uint32_t m_maxVertices = 100000;
        uint32_t m_currentFrameIndex = 0;
        bool m_initialized = false;
    };
} // namespace pnkr::renderer::debug
</file>

<file path="include/pnkr/renderer/debug/LineCanvas3D.hpp">
#pragma once

#include "pnkr/renderer/rhi_renderer.hpp"
#include "pnkr/rhi/rhi_types.hpp"
#include "pnkr/core/Handle.h"
#include <glm/glm.hpp>
#include <vector>
#include <memory>

namespace pnkr::renderer::debug
{
    class LineCanvas3D
    {
    public:
        LineCanvas3D();
        ~LineCanvas3D();

        // Disable copy/move
        LineCanvas3D(const LineCanvas3D&) = delete;
        LineCanvas3D& operator=(const LineCanvas3D&) = delete;
        LineCanvas3D(LineCanvas3D&&) = delete;
        LineCanvas3D& operator=(LineCanvas3D&&) = delete;

        // Lifecycle
        void initialize(RHIRenderer* renderer);
        void beginFrame();
        void endFrame();

        // Drawing primitives
        void line(const glm::vec3& start, const glm::vec3& end, const glm::vec3& color);
        void box(const glm::vec3& min, const glm::vec3& max, const glm::vec3& color);
        void box(const glm::mat4& transform, const glm::vec3& size, const glm::vec3& color);
        void plane(const glm::vec3& origin, const glm::vec3& v1, const glm::vec3& v2,
                   int segments1, int segments2, const glm::vec3& color);
        void frustum(const glm::mat4& viewProj, const glm::vec3& color);
        void circle(const glm::vec3& center, float radius, const glm::vec3& color, int segments = 32);
        void sphere(const glm::vec3& center, float radius, const glm::vec3& color, int segments = 16);

        // Rendering
        void render(const RHIFrameContext& ctx, const glm::mat4& viewProj);

    private:
        struct LineVertex
        {
            glm::vec3 position;
            glm::vec3 color;
        };

        struct PushConstants
        {
            glm::mat4 mvp;
        };

        void createPipeline();
        void createVertexBuffer();
        void uploadVertexData();

        std::vector<LineVertex> m_vertices;
        std::unique_ptr<rhi::RHIBuffer> m_vertexBuffer;
        PipelineHandle m_pipeline;
        RHIRenderer* m_renderer = nullptr;

        // Ring buffer management
        static constexpr uint32_t kMaxFrames = 3;
        uint32_t m_maxVertices = 100000;
        uint32_t m_currentFrameIndex = 0;
        bool m_frameActive = false;
        bool m_initialized = false;
    };
} // namespace pnkr::renderer::debug
</file>

<file path="include/pnkr/renderer/geometry/mesh.h">
//
// Created by Jose on 12/13/2025.
//

#ifndef PNKR_MESH_H
#define PNKR_MESH_H
#include "Vertex.h"
#include "pnkr/renderer/vulkan/vulkan_buffer.hpp"
#include "pnkr/renderer/vulkan/vulkan_device.hpp"
namespace pnkr::renderer {
class Mesh {
public:
  Mesh(VulkanDevice &device, const std::vector<Vertex> &vertices,
       const std::vector<std::uint32_t> &indices);
  void bind(vk::CommandBuffer cmd) const;
  void draw(vk::CommandBuffer cmd) const;

private:
  VulkanBuffer m_vertexBuffer;
  VulkanBuffer m_indexBuffer;
  std::uint32_t m_indexCount = 0;
};
} // namespace pnkr::renderer
#endif // PNKR_MESH_H
</file>

<file path="include/pnkr/renderer/geometry/Vertex.h">
#pragma once
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>
#include <glm/vec4.hpp>
#include "pnkr/rhi/rhi_types.hpp"

namespace pnkr::renderer
{
    struct Vertex
    {
        glm::vec3 m_position;
        glm::vec3 m_color;
        glm::vec3 m_normal;
        glm::vec2 m_texCoord;
        glm::vec4 m_tangent;

        struct SemanticMap
        {
            rhi::VertexSemantic m_semantic;
            uint32_t m_offset;
            rhi::Format m_format;
        };

        static std::vector<SemanticMap> getLayout()
        {
            return {
                {rhi::VertexSemantic::Position, offsetof(Vertex, m_position), rhi::Format::R32G32B32_SFLOAT},
                {rhi::VertexSemantic::Color, offsetof(Vertex, m_color), rhi::Format::R32G32B32_SFLOAT},
                {rhi::VertexSemantic::Normal, offsetof(Vertex, m_normal), rhi::Format::R32G32B32_SFLOAT},
                {rhi::VertexSemantic::TexCoord, offsetof(Vertex, m_texCoord), rhi::Format::R32G32_SFLOAT},
                {rhi::VertexSemantic::Tangent, offsetof(Vertex, m_tangent), rhi::Format::R32G32B32A32_SFLOAT}
            };
        }
    };
} // namespace pnkr::renderer
</file>

<file path="include/pnkr/renderer/geometry/VertexInputDescription.h">
#pragma once
#include <vector>
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer
{
    struct VertexInputDescription {
        std::vector<vk::VertexInputBindingDescription> m_bindings;
        std::vector<vk::VertexInputAttributeDescription> m_attributes;
    };


    class VertexInputBuilder {
    public:
        VertexInputBuilder& addBinding(uint32_t binding, uint32_t stride, vk::VertexInputRate rate = vk::VertexInputRate::eVertex) {
            vk::VertexInputBindingDescription desc;
            desc.binding = binding;
            desc.stride = stride;
            desc.inputRate = rate;
            m_description.m_bindings.push_back(desc);
            return *this;
        }

        VertexInputBuilder& addAttribute(uint32_t location, uint32_t binding, vk::Format format, uint32_t offset) {
            vk::VertexInputAttributeDescription desc;
            desc.location = location;
            desc.binding = binding;
            desc.format = format;
            desc.offset = offset;
            m_description.m_attributes.push_back(desc);
            return *this;
        }

        [[nodiscard]] VertexInputDescription build() const {
            return m_description;
        }

    private:
        VertexInputDescription m_description;
    };
}
</file>

<file path="include/pnkr/renderer/material/Material.hpp">
#pragma once
#include "pnkr/core/Handle.h"
#include <glm/vec4.hpp>

namespace pnkr::renderer {

struct MaterialData {
    glm::vec4 baseColorFactor{1.0f};
    TextureHandle baseColorTexture{INVALID_TEXTURE_HANDLE};
    PipelineHandle pipeline{INVALID_PIPELINE_HANDLE};
};

}
</file>

<file path="include/pnkr/renderer/pipeline/Pipeline.h">
//
// Created by Jose on 12/13/2025.
//
#pragma once
#include <cstdint>
#include <functional>
#include <vulkan/vulkan.hpp>
#include "pnkr/core/Handle.h"
namespace pnkr::renderer {

// Frame context passed to record callback
struct RenderFrameContext {
  vk::CommandBuffer m_cmd{};
  uint32_t m_frameIndex{};
  uint32_t m_imageIndex{};
  vk::Extent2D m_extent{};
  float m_deltaTime{};         // seconds

  void bindPipeline(vk::Pipeline pipeline) const {
    m_cmd.bindPipeline(vk::PipelineBindPoint::eGraphics, pipeline);
  }
};

// Signature for per-frame render callback
using RenderCallback = std::function<void(RenderFrameContext &)>;

} // namespace pnkr::renderer
</file>

<file path="include/pnkr/renderer/renderer_config.hpp">
#pragma once
#include "pnkr/rhi/rhi_device.hpp"

namespace pnkr::renderer {

struct RendererConfig
{
    bool m_enableValidation = false;
    bool m_useBindless = false;
    uint32_t m_maxFramesInFlight = 2;
    bool m_enableBindless = true;
};

}
</file>

<file path="include/pnkr/renderer/renderer.hpp">
#pragma once

#include <filesystem>
#include <functional>
#include <memory>
#include <vector>

#include "pipeline/Pipeline.h"
#include "pnkr/core/Handle.h"
#include "pnkr/core/profiler.hpp"
#include "pnkr/renderer/renderer_config.hpp"
#include "pnkr/renderer/vulkan/vulkan_command_buffer.hpp"
#include "pnkr/renderer/vulkan/vulkan_context.hpp"
#include "pnkr/renderer/vulkan/vulkan_device.hpp"
#include "pnkr/renderer/vulkan/vulkan_pipeline.hpp"
#include "pnkr/renderer/vulkan/vulkan_render_target.h"
#include "pnkr/renderer/vulkan/vulkan_swapchain.hpp"
#include "pnkr/renderer/vulkan/vulkan_sync_manager.h"

#include "geometry/mesh.h"
#include "pnkr/renderer/vulkan/pipeline/compute_pipeline.hpp"
#include "geometry/Vertex.h"
#include "vulkan/bindless/bindless_manager.hpp"
#include "vulkan/image/vulkan_image.hpp"
#include "vulkan/image/vulkan_sampler.hpp"

namespace pnkr::renderer
{
    class VulkanCommandBuffer;
    class VulkanContext;
    class VulkanDevice;
    class VulkanPipeline;
    class VulkanSwapchain;
    class VulkanSyncManager;
    class VulkanRenderTarget;
    class VulkanDescriptorAllocator;
    class VulkanDescriptorLayoutCache;
    class VulkanImage;
    class VulkanSampler;
}

namespace pnkr::renderer
{
    using RecordFunc = std::function<void(const RenderFrameContext&)>;

    class Renderer
    {
    public:
        explicit Renderer(platform::Window& window,
                          [[maybe_unused]] const RendererConfig& config);
        void createTextureDescriptorSetLayout();
        TextureHandle createTextureFromPixels(const unsigned char* data,
                                              int width,
                                              int height,
                                              int channels,
                                              bool srgb = true);
        uint32_t getTextureBindlessIndex(TextureHandle handle) const;

        explicit Renderer(platform::Window& window)
            : Renderer(window, RendererConfig{})
        {
        }

        ~Renderer();

        Renderer(const Renderer&) = delete;
        Renderer& operator=(const Renderer&) = delete;
        Renderer(Renderer&&) = delete;
        Renderer& operator=(Renderer&&) = delete;

        void bindMesh(vk::CommandBuffer cmd, MeshHandle handle) const;
        void drawMesh(vk::CommandBuffer cmd, MeshHandle handle) const;

        void beginFrame(float deltaTime);
        void drawFrame();
        void endFrame();
        void resize(int width, int height);

        MeshHandle createMesh(const std::vector<Vertex>& vertices,
                              const std::vector<uint32_t>& indices);
        PipelineHandle createPipeline(const VulkanPipeline::Config& cfg);
        void setRecordFunc(const RecordFunc& callback);
        void bindPipeline(vk::CommandBuffer cmd, PipelineHandle handle) const;
        vk::PipelineLayout pipelineLayout(PipelineHandle handle) const;
        TextureHandle loadTexture(const std::filesystem::path& filepath,
                                  bool srgb = true);
        vk::DescriptorSet getTextureDescriptor(TextureHandle handle) const;
        vk::DescriptorSetLayout getTextureDescriptorLayout() const;

        template <typename T>
        void pushConstants(vk::CommandBuffer cmd,
                           PipelineHandle pipe,
                           vk::ShaderStageFlags stages,
                           const T& data,
                           uint32_t offset = 0) const
        {
            static_assert(std::is_trivially_copyable_v<T>,
                          "pushConstants<T>: T must be trivially copyable");
            cmd.pushConstants(pipelineLayout(pipe),
                              stages,
                              offset,
                              static_cast<uint32_t>(sizeof(T)),
                              &data);
        }

        void pushConstantsRaw(vk::CommandBuffer cmd,
                              PipelineHandle pipe,
                              vk::ShaderStageFlags stages,
                              uint32_t offset,
                              uint32_t size,
                              const void* data) const
        {
            cmd.pushConstants(pipelineLayout(pipe), stages, offset, size, data);
        }

        [[nodiscard]] vk::Format getDrawColorFormat() const { return m_mainTarget->colorImage().format(); }
        [[nodiscard]] vk::Format getDrawDepthFormat() const { return m_mainTarget->depthImage().format(); }
        [[nodiscard]] vk::Device device() const { return m_device->device(); }
        [[nodiscard]] vk::PhysicalDevice physicalDevice() const { return m_device->physicalDevice(); }
        [[nodiscard]] vk::Instance instance() const { return m_context->instance(); }

        [[nodiscard]] vk::Queue graphicsQueue() const { return m_device->graphicsQueue(); }
        [[nodiscard]] uint32_t graphicsQueueFamilyIndex() const { return m_device->graphicsQueueFamily(); }

        [[nodiscard]] vk::CommandPool commandPool() const
        {
            return m_commandBuffer->commandPool();
        }

        [[nodiscard]] vk::Format getSwapchainColorFormat() const { return m_swapchain->imageFormat(); }

        void bindPipeline(vk::CommandBuffer cmd, const ComputePipeline& pipeline);
        void dispatch(vk::CommandBuffer cmd, uint32_t groupX, uint32_t groupY, uint32_t groupZ);

        using PostProcessCallback = std::function<void(vk::CommandBuffer cmd, uint32_t swapchainImageIndex,
                                                       const vk::Extent2D& extent)>;
        void setPostProcessCallback(PostProcessCallback callback) { m_postProcessCallback = callback; }

        [[nodiscard]] vk::ImageView getSwapchainImageView(uint32_t index) const
        {
            return m_swapchain->imageViews()[index];
        }

        [[nodiscard]] uint32_t getSwapchainImageCount() const
        {
            return static_cast<uint32_t>(m_swapchain->images().size());
        }

        [[nodiscard]] const VulkanImage& getOffscreenTexture() const { return m_mainTarget->colorImage(); }

        [[nodiscard]] BindlessIndex registerBindlessStorageBuffer(vk::Buffer buffer,
                                                                  vk::DeviceSize offset,
                                                                  vk::DeviceSize range) const
        {
            if (!m_bindless) {
                core::Logger::error("Bindless not initialized");
                return INVALID_BINDLESS_INDEX;
            }
            return m_bindless->registerStorageBuffer(buffer, offset, range);
        }

        // Overload for common case where offset = 0
        [[nodiscard]] BindlessIndex registerBindlessStorageBuffer(vk::Buffer buffer,
                                                                  vk::DeviceSize range) const
        {
            return registerBindlessStorageBuffer(buffer, 0, range);
        }

        [[nodiscard]] BindlessIndex registerBindlessSampledImage(vk::ImageView view, vk::Sampler sampler) const
        {
            return m_bindless->registerSampledImage(view, sampler);
        }

        [[nodiscard]] BindlessIndex registerBindlessStorageImage(vk::ImageView view) const
        {
            return m_bindless->registerStorageImage(view);
        }

        [[nodiscard]] vk::DescriptorSetLayout getBindlessLayout() const
        {
            return m_bindless->getLayout();
        }

        [[nodiscard]] vk::DescriptorSet getBindlessDescriptorSet() const
        {
            return m_bindless->getDescriptorSet();
        }

        void setBindlessEnabled(bool enabled) {
            if (enabled && !m_bindless) {
                core::Logger::warn("Cannot enable bindless: not initialized at startup");
                return;
            }
            m_useBindlessForCurrentFrame = enabled;
            core::Logger::info("Bindless rendering: {}", enabled ? "ENABLED" : "DISABLED");
        }

        [[nodiscard]] bool isBindlessEnabled() const noexcept {
            return m_useBindlessForCurrentFrame;
        }

        [[nodiscard]] bool hasBindlessSupport() const noexcept {
            return m_bindless != nullptr;
        }


    private:
        platform::Window& m_window;
        std::unique_ptr<VulkanContext> m_context;
        std::unique_ptr<VulkanDevice> m_device;
        std::unique_ptr<VulkanSwapchain> m_swapchain;
        std::unique_ptr<VulkanCommandBuffer> m_commandBuffer;
        std::unique_ptr<VulkanSyncManager> m_sync;
        TracyContext m_tracyCtx{nullptr};
        std::vector<std::unique_ptr<Mesh>> m_meshes;
        std::unique_ptr<VulkanRenderTarget> m_mainTarget;
        std::unique_ptr<VulkanDescriptorAllocator> m_descriptorAllocator;
        std::unique_ptr<VulkanDescriptorLayoutCache> m_descriptorLayoutCache;
        std::unique_ptr<VulkanSampler> m_defaultSampler;
        std::vector<std::unique_ptr<VulkanImage>> m_textures;
        std::vector<vk::DescriptorSet> m_textureDescriptors;
        vk::DescriptorSetLayout m_textureSetLayout{};
        PostProcessCallback m_postProcessCallback = nullptr;
        std::unique_ptr<BindlessManager> m_bindless;
        bool m_useBindlessForCurrentFrame = false;
        std::vector<std::unique_ptr<VulkanPipeline>> m_pipelines;
        std::vector<BindlessIndex> m_textureBindlessIndices;
        const VulkanPipeline& pipeline(PipelineHandle handle) const;
        RecordFunc m_recordCallback;

        uint32_t m_imageIndex = 0;
        bool m_frameInProgress = false;
        float m_deltaTime = 0.0f;
        TextureHandle m_whiteTexture{INVALID_TEXTURE_HANDLE};
    };
}
</file>

<file path="include/pnkr/renderer/rhi_renderer.hpp">
#pragma once

#include "pnkr/rhi/rhi_types.hpp"
#include "pnkr/rhi/rhi_device.hpp"
#include "pnkr/rhi/rhi_buffer.hpp"
#include "pnkr/rhi/rhi_texture.hpp"
#include "pnkr/rhi/rhi_pipeline.hpp"
#include "pnkr/rhi/rhi_command_buffer.hpp"
#include "pnkr/rhi/rhi_swapchain.hpp"
#include "pnkr/rhi/rhi_sampler.hpp"
#include "pnkr/rhi/rhi_descriptor.hpp"
#include "pnkr/renderer/renderer_config.hpp"
#include "pnkr/core/Handle.h"
#include "pnkr/platform/window.hpp"

#include <functional>
#include <memory>
#include <vector>
#include <filesystem>

namespace pnkr::renderer
{
    // Frame context for recording commands
    struct RHIFrameContext
    {
        rhi::RHICommandBuffer* commandBuffer;
        uint32_t frameIndex;
        float deltaTime;
    };

    using RHIRecordFunc = std::function<void(const RHIFrameContext&)>;

    class RHIRenderer
    {
    public:
        explicit RHIRenderer(platform::Window& window,
                            const RendererConfig& config = RendererConfig{});
        ~RHIRenderer();

        // Disable copy/move
        RHIRenderer(const RHIRenderer&) = delete;
        RHIRenderer& operator=(const RHIRenderer&) = delete;
        RHIRenderer(RHIRenderer&&) = delete;
        RHIRenderer& operator=(RHIRenderer&&) = delete;

        // Frame management
        void beginFrame(float deltaTime);
        void drawFrame();
        void endFrame();
        void resize(int width, int height);

        // Resource creation
        MeshHandle createMesh(const std::vector<struct Vertex>& vertices,
                             const std::vector<uint32_t>& indices);
        
        TextureHandle createTexture(const unsigned char* data,
                                   int width, int height, int channels,
                                   bool srgb = true);
        
        TextureHandle loadTexture(const std::filesystem::path& filepath,
                                 bool srgb = true);

        TextureHandle createCubemap(const std::vector<std::filesystem::path>& faces,
                                   bool srgb = true);
        
        PipelineHandle createGraphicsPipeline(const rhi::GraphicsPipelineDescriptor& desc);
        PipelineHandle createComputePipeline(const rhi::ComputePipelineDescriptor& desc);

        // Command recording
        void setRecordFunc(const RHIRecordFunc& callback);

        // Drawing commands (to be used within record callback)
        void bindPipeline(rhi::RHICommandBuffer* cmd, PipelineHandle handle);
        void bindMesh(rhi::RHICommandBuffer* cmd, MeshHandle handle);
        void drawMesh(rhi::RHICommandBuffer* cmd, MeshHandle handle);
        void bindDescriptorSet(rhi::RHICommandBuffer* cmd,
                               PipelineHandle handle,
                               uint32_t setIndex,
                               rhi::RHIDescriptorSet* descriptorSet);

        // Push constants
        template <typename T>
        void pushConstants(rhi::RHICommandBuffer* cmd,
                          PipelineHandle pipe,
                          rhi::ShaderStage stages,
                          const T& data,
                          uint32_t offset = 0)
        {
            static_assert(std::is_trivially_copyable_v<T>,
                         "pushConstants<T>: T must be trivially copyable");
            
            auto* pipeline = getPipeline(pipe);
            cmd->pushConstants(pipeline, stages, offset, sizeof(T), &data);
        }

        // Texture/descriptor access
        [[nodiscard]] rhi::RHITexture* getTexture(TextureHandle handle) const;
        [[nodiscard]] uint32_t getTextureBindlessIndex(TextureHandle handle) const;

        // Format queries
        rhi::Format getDrawColorFormat() const;
        rhi::Format getDrawDepthFormat() const;
        rhi::Format getSwapchainColorFormat() const;

        // Device access
        rhi::RHIDevice* device() const { return m_device.get(); }

        // Bindless support
        void setBindlessEnabled(bool enabled);
        rhi::RHIPipeline* pipeline(PipelineHandle handle);
        bool isBindlessEnabled() const noexcept { return m_useBindless; }
        bool hasBindlessSupport() const noexcept { return m_bindlessSupported; }

        // Pipeline access
        [[nodiscard]] rhi::RHIPipeline* getPipeline(PipelineHandle handle);

    private:
        // Window reference
        platform::Window& m_window;

        // RHI objects
        std::unique_ptr<rhi::RHIDevice> m_device;
        std::unique_ptr<rhi::RHISwapchain> m_swapchain;
        std::vector<std::unique_ptr<rhi::RHICommandBuffer>> m_commandBuffers;
        rhi::RHICommandBuffer* m_activeCommandBuffer = nullptr;
        rhi::SwapchainFrame m_currentFrame{};
        std::unique_ptr<rhi::RHISampler> m_defaultSampler;

        // Resources
        struct MeshData {
            std::unique_ptr<rhi::RHIBuffer> vertexBuffer;
            std::unique_ptr<rhi::RHIBuffer> indexBuffer;
            uint32_t vertexCount;
            uint32_t indexCount;
        };
        std::vector<MeshData> m_meshes;

        struct TextureData {
            std::unique_ptr<rhi::RHITexture> texture;
            uint32_t bindlessIndex;
        };
        std::vector<TextureData> m_textures;

        std::vector<std::unique_ptr<rhi::RHIPipeline>> m_pipelines;

        // Render targets
        // Backbuffer is owned by the swapchain; depth is device-owned.
        rhi::RHITexture* m_backbuffer = nullptr;
        std::unique_ptr<rhi::RHITexture> m_depthTarget;
        rhi::ResourceLayout m_depthLayout = rhi::ResourceLayout::Undefined;

        // Frame state
        RHIRecordFunc m_recordCallback;
        bool m_frameInProgress = false;
        float m_deltaTime = 0.0f;
        uint32_t m_frameIndex = 0;

        // Config
        bool m_bindlessSupported = false;
        bool m_useBindless = false;
        TextureHandle m_whiteTexture{INVALID_TEXTURE_HANDLE};

        // Helper methods
        void createRenderTargets();
        void createDefaultResources();
        TextureHandle createWhiteTexture();
        void uploadToBuffer(rhi::RHIBuffer* target, const void* data, uint64_t size);
    };

} // namespace pnkr::renderer
</file>

<file path="include/pnkr/renderer/scene/Camera.hpp">
//
// Created by Jose on 12/14/2025.
//

#ifndef PNKR_CAMERA_H
#define PNKR_CAMERA_H

#pragma once

#include <glm/mat4x4.hpp>
#include <glm/gtc/matrix_transform.hpp>

namespace pnkr::renderer::scene {

    class Camera {
    public:
        void lookAt(const glm::vec3& eye,
                    const glm::vec3& center,
                    const glm::vec3& up = glm::vec3(0.f, 1.f, 0.f))
        {
            m_view = glm::lookAt(eye, center, up);
        }

        // fovyRad in radians
        void setPerspective(float fovyRad, float aspect, float zNear, float zFar)
        {
            m_proj = glm::perspective(fovyRad, aspect, zNear, zFar);
            // Vulkan NDC has inverted Y when using GLM's default conventions
            m_proj[1][1] *= -1.0f;
        }

        const glm::mat4& view() const noexcept { return m_view; }
        const glm::mat4& proj() const noexcept { return m_proj; }

        glm::mat4 viewProj() const noexcept { return m_proj * m_view; }

    private:
        glm::mat4 m_view{1.0f};
        glm::mat4 m_proj{1.0f};
    };

} // namespace pnkr::renderer


#endif //PNKR_CAMERA_H
</file>

<file path="include/pnkr/renderer/scene/CameraController.hpp">
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/constants.hpp>
#include "Camera.hpp"
#include "pnkr/platform/Input.hpp"

namespace pnkr::renderer::scene {

class CameraController {
public:
  CameraController(const glm::vec3& position = {0.0f, 0.0f, 5.0f},
                   float yaw = -90.0f,
                   float pitch = 0.0f)
    : m_position(position)
    , m_yaw(yaw)
    , m_pitch(pitch)
  {
    updateVectors();
  }

  void update(const platform::Input& input, float deltaTime) {

    const float moveSpeed = m_moveSpeed * deltaTime;
    const float sensitivity = m_mouseSensitivity;

    if (input.isKeyDown(SDL_SCANCODE_W)) {
      m_position += m_front * moveSpeed;
    }
    if (input.isKeyDown(SDL_SCANCODE_S)) {
      m_position -= m_front * moveSpeed;
    }
    if (input.isKeyDown(SDL_SCANCODE_A)) {
      m_position -= m_right * moveSpeed;
    }
    if (input.isKeyDown(SDL_SCANCODE_D)) {
      m_position += m_right * moveSpeed;
    }

    if (input.isKeyDown(SDL_SCANCODE_E)) {
      m_position += m_up * moveSpeed;
    }
    if (input.isKeyDown(SDL_SCANCODE_Q)) {
      m_position -= m_up * moveSpeed;
    }

    if (input.isKeyDown(SDL_SCANCODE_LSHIFT)) {
      m_moveSpeed = 5.0f;
    } else {
      m_moveSpeed = 2.5f;
    }

    // Mouse look (only if right mouse button is held)
    if (input.isMouseButtonDown(SDL_BUTTON_RIGHT)) {
      glm::vec2 delta = input.mouseDelta();

      m_yaw += delta.x * sensitivity;
      m_pitch -= delta.y * sensitivity;

      if (m_pitch > 89.0f) m_pitch = 89.0f;
      if (m_pitch < -89.0f) m_pitch = -89.0f;

      updateVectors();
    }
  }

  void applyToCamera(Camera& camera) const {
    camera.lookAt(m_position, m_position + m_front, m_worldUp);
  }

  // Setters
  void setPosition(const glm::vec3& pos) { m_position = pos; }
  void setMoveSpeed(float speed) { m_moveSpeed = speed; }
  void setMouseSensitivity(float sensitivity) { m_mouseSensitivity = sensitivity; }

  // Getters
  [[nodiscard]] const glm::vec3& position() const { return m_position; }
  [[nodiscard]] const glm::vec3& front() const { return m_front; }
  [[nodiscard]] float yaw() const { return m_yaw; }
  [[nodiscard]] float pitch() const { return m_pitch; }

private:
  void updateVectors() {
    // Calculate new front vector
    glm::vec3 front;
    front.x = glm::cos(glm::radians(m_yaw)) * glm::cos(glm::radians(m_pitch));
    front.y = glm::sin(glm::radians(m_pitch));
    front.z = glm::sin(glm::radians(m_yaw)) * glm::cos(glm::radians(m_pitch));
    m_front = glm::normalize(front);

    // Recalculate right and up vectors
    m_right = glm::normalize(glm::cross(m_front, m_worldUp));
    m_up = glm::normalize(glm::cross(m_right, m_front));
  }

  // Camera position and orientation
  glm::vec3 m_position{0.0f, 0.0f, 5.0f};
  glm::vec3 m_front{0.0f, 0.0f, -1.0f};
  glm::vec3 m_up{0.0f, 1.0f, 0.0f};
  glm::vec3 m_right{1.0f, 0.0f, 0.0f};
  glm::vec3 m_worldUp{0.0f, 1.0f, 0.0f};

  // Euler angles
  float m_yaw{-90.0f};
  float m_pitch{0.0f};

  // Camera options
  float m_moveSpeed{2.5f};
  float m_mouseSensitivity{0.1f};
};

} // namespace pnkr::renderer::scene
</file>

<file path="include/pnkr/renderer/scene/Model.hpp">
#pragma once

#include "pnkr/renderer/rhi_renderer.hpp"
#include "pnkr/renderer/scene/transform.hpp"

#include <vector>
#include <string>
#include <memory>
#include <filesystem>

namespace pnkr::renderer::scene
{
    struct MaterialData
    {
        glm::vec4 baseColorFactor{1.0f};
        TextureHandle baseColorTexture = INVALID_TEXTURE_HANDLE;
    };

    struct MeshPrimitive
    {
        MeshHandle mesh;
        uint32_t materialIndex;
    };

    struct Node
    {
        std::string name;
        Transform localTransform;
        Transform worldTransform;
        int parentIndex = -1;
        std::vector<int> children;
        std::vector<MeshPrimitive> meshPrimitives;
    };

    class Model
    {
    public:
        static std::unique_ptr<Model> load(RHIRenderer& renderer, const std::filesystem::path& path);

        void updateTransforms();

        const std::vector<MaterialData>& materials() const { return m_materials; }
        const std::vector<Node>& nodes() const { return m_nodes; }
        const std::vector<int>& rootNodes() const { return m_rootNodes; }

    private:
        std::vector<TextureHandle> m_textures;
        std::vector<MaterialData> m_materials;
        std::vector<Node> m_nodes;
        std::vector<int> m_rootNodes;
    };
}
</file>

<file path="include/pnkr/renderer/scene/Node.hpp">
#pragma once
#include "pnkr/renderer/scene/transform.hpp"
#include "pnkr/core/Handle.h"
#include <vector>
#include <memory>
#include <optional>
#include <string>

namespace pnkr::renderer::scene {

struct MeshPrimitive {
    MeshHandle mesh;
    uint32_t materialIndex;
};

struct Node {
    Transform localTransform;
    Transform worldTransform;
    int parentIndex = -1;
    std::vector<int> children;
    
    // A node can hold a mesh (which may have multiple primitives)
    std::optional<std::vector<MeshPrimitive>> meshPrimitives;

    std::string name;
};

}
</file>

<file path="include/pnkr/renderer/scene/RHIScene.hpp">
#pragma once

#include "pnkr/renderer/rhi_renderer.hpp"
#include "pnkr/renderer/scene/Skybox.hpp"
#include "pnkr/renderer/scene/Camera.hpp"
#include "pnkr/renderer/scene/CameraController.hpp"
#include "pnkr/renderer/scene/transform.hpp"
#include "pnkr/core/Handle.h"
#include <vector>

namespace pnkr::renderer::scene {

    struct RHIRenderable {
        Transform xform;
        MeshHandle mesh{};
        PipelineHandle pipe{};
    };

    class RHIScene {
    public:
        RHIScene(RHIRenderer& renderer) : m_renderer(renderer) {}

        void update(float dt, int width, int height);
        void render(rhi::RHICommandBuffer* cmd) const;

        // Skybox functionality
        void loadSkybox(const std::vector<std::filesystem::path>& faces);
        void renderSkybox(rhi::RHICommandBuffer* cmd) const;

        Camera& camera() { return m_camera; }
        const Camera& camera() const { return m_camera; }

        CameraController& cameraController() { return m_cameraController; }
        const CameraController& cameraController() const { return m_cameraController; }

        std::vector<RHIRenderable>& objects() { return m_objects; }
        const std::vector<RHIRenderable>& objects() const { return m_objects; }

    private:
        RHIRenderer& m_renderer;
        Camera m_camera;
        CameraController m_cameraController;
        std::vector<RHIRenderable> m_objects;
        std::unique_ptr<Skybox> m_skybox;
        int m_lastWidth = 0;
        int m_lastHeight = 0;
    };

} // namespace pnkr::renderer::scene
</file>

<file path="include/pnkr/renderer/scene/Scene.hpp">
#pragma once
#include <vector>
#include <vulkan/vulkan.hpp>

#include "pnkr/core/Handle.h"
#include "pnkr/renderer/pipeline/Pipeline.h"
#include "pnkr/renderer/scene/Camera.hpp"
#include "pnkr/renderer/scene/CameraController.hpp"
#include "pnkr/renderer/scene/transform.hpp"
#include "pnkr/platform/Input.hpp"

namespace pnkr::renderer {
    class Renderer;
}

namespace pnkr::renderer::scene {

    struct Renderable {
        Transform xform;
        MeshHandle mesh{};
        PipelineHandle pipe{};
    };

    class Scene {
    public:
        void onResize(vk::Extent2D ext);
        void update(float dt, vk::Extent2D ext, const platform::Input& input);
        void record(const RenderFrameContext& ctx, const Renderer& r) const;

        Camera& camera() { return m_camera; }
        const Camera& camera() const { return m_camera; }

        CameraController& cameraController() { return m_cameraController; }
        const CameraController& cameraController() const { return m_cameraController; }

        std::vector<Renderable>& objects() { return m_objects; }
        const std::vector<Renderable>& objects() const { return m_objects; }

    private:
        Camera m_camera;
        CameraController m_cameraController;
        std::vector<Renderable> m_objects;
        vk::Extent2D m_lastExtent{0, 0};
    };

}
</file>

<file path="include/pnkr/renderer/scene/Skybox.hpp">
#pragma once

#include "pnkr/renderer/rhi_renderer.hpp"
#include "pnkr/renderer/scene/Camera.hpp"
#include <vector>
#include <filesystem>
#include <glm/mat4x4.hpp>

namespace pnkr::renderer::scene {

    struct SkyboxPushConstants {
        glm::mat4 view;
        glm::mat4 proj;
        uint32_t textureIndex;
        uint32_t _pad[3];
    };

    class Skybox {
    public:
        // Changed: Removed the manual loadSpirv helper (we use RHI Factory)
        // We store the renderer pointer in init.
        void init(RHIRenderer& renderer, const std::vector<std::filesystem::path>& faces);

        // Changed: Renderer is no longer a parameter
        void draw(rhi::RHICommandBuffer* cmd, const Camera& camera);

        // Cleanup resources
        void destroy();

    private:
        void createSkyboxPipeline();

        RHIRenderer* m_renderer = nullptr; // Stored reference
        TextureHandle m_cubemapHandle{INVALID_TEXTURE_HANDLE};
        PipelineHandle m_pipeline{INVALID_PIPELINE_HANDLE};
    };
}
</file>

<file path="include/pnkr/renderer/scene/transform.hpp">
#pragma once

#include <glm/gtc/matrix_transform.hpp>
#include <glm/mat4x4.hpp>
#include <glm/vec3.hpp>
#include <glm/gtx/quaternion.hpp>

namespace pnkr::renderer::scene {

struct Transform {
  glm::vec3 m_translation{0.0f};
  glm::quat m_rotation{1.0f, 0.0f, 0.0f, 0.0f};
  glm::vec3 m_scale{1.0f};

  [[nodiscard]] glm::mat4 mat4() const {

    glm::mat4 mat = glm::translate(glm::mat4(1.0f), m_translation);
    mat = mat * glm::toMat4(m_rotation);
    mat = glm::scale(mat, m_scale);
    return mat;
  }
};

}
</file>

<file path="include/pnkr/renderer/vulkan/bindless/bindless_manager.hpp">
#pragma once

#include <vulkan/vulkan.hpp>

namespace pnkr::renderer {

class VulkanBuffer;
class VulkanImage;

struct BindlessIndex {
    uint32_t index = UINT32_MAX;

    [[nodiscard]] bool isValid() const { return index != UINT32_MAX; }

    [[nodiscard]] uint32_t raw() const { return index; }
};

constexpr BindlessIndex INVALID_BINDLESS_INDEX{UINT32_MAX};

class BindlessManager {
public:
    explicit BindlessManager(vk::Device device, vk::PhysicalDevice physicalDevice);
    ~BindlessManager();
    void createDescriptorPool();

    BindlessManager(const BindlessManager&) = delete;
    BindlessManager& operator=(const BindlessManager&) = delete;

    [[nodiscard]] BindlessIndex registerStorageBuffer(vk::Buffer buffer, vk::DeviceSize offset, vk::DeviceSize range);
    [[nodiscard]] BindlessIndex registerSampledImage(vk::ImageView view, vk::Sampler sampler);
    [[nodiscard]] BindlessIndex registerStorageImage(vk::ImageView view);
    [[nodiscard]] BindlessIndex registerCubemap(vk::ImageView view, vk::Sampler sampler);
    void logStats() const;

    [[nodiscard]] vk::DescriptorSet getDescriptorSet() const { return m_descriptorSet; }
    [[nodiscard]] vk::DescriptorSetLayout getLayout() const { return m_layout; }

    [[nodiscard]] uint32_t maxStorageBuffers() const { return m_maxStorageBuffers; }
    [[nodiscard]] uint32_t maxSampledImages() const { return m_maxSampledImages; }
    [[nodiscard]] uint32_t maxStorageImages() const { return m_maxStorageImages; }
    [[nodiscard]] uint32_t maxCubemaps() const { return m_maxCubemaps; }

    [[nodiscard]] uint32_t currentStorageBufferCount() const { return m_storageBufferCount; }
    [[nodiscard]] uint32_t currentSampledImageCount() const { return m_sampledImageCount; }
    [[nodiscard]] uint32_t currentStorageImageCount() const { return m_storageImageCount; }
    [[nodiscard]] uint32_t currentCubemapCount() const { return m_cubemapCount; }

private:
    vk::Device m_device;
    vk::DescriptorPool m_pool;
    vk::DescriptorSet m_descriptorSet;
    vk::DescriptorSetLayout m_layout;

    static constexpr uint32_t MAX_STORAGE_BUFFERS = 100'000;
    static constexpr uint32_t MAX_SAMPLED_IMAGES = 100'000;  // Can be huge
    static constexpr uint32_t MAX_STORAGE_IMAGES = 10'000;
    static constexpr uint32_t MAX_CUBEMAPS = 1000;

    uint32_t m_maxStorageBuffers = MAX_STORAGE_BUFFERS;
    uint32_t m_maxSampledImages = MAX_SAMPLED_IMAGES;
    uint32_t m_maxStorageImages = MAX_STORAGE_IMAGES;
    uint32_t m_maxCubemaps = MAX_CUBEMAPS;

    uint32_t m_storageBufferCount = 0;
    uint32_t m_sampledImageCount = 0;
    uint32_t m_storageImageCount = 0;
    uint32_t m_cubemapCount = 0;

    void createDescriptorLayout();
    void createDescriptorSet();
};

}
</file>

<file path="include/pnkr/renderer/vulkan/image/vulkan_image.hpp">
#ifndef PNKR_VULKANIMAGE_H
#define PNKR_VULKANIMAGE_H

#include <filesystem>
#include <vk_mem_alloc.h>
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer {

    class VulkanDevice;

    class VulkanImage {
    public:
        VulkanImage(VmaAllocator allocator,
                    uint32_t width,
                    uint32_t height,
                    vk::Format format,
                    vk::ImageTiling tiling,
                    vk::ImageUsageFlags usage,
                    VmaMemoryUsage memoryUsage,
                    vk::ImageAspectFlags aspectFlags = vk::ImageAspectFlagBits::eColor);

        ~VulkanImage();

        VulkanImage(const VulkanImage&) = delete;
        VulkanImage& operator=(const VulkanImage&) = delete;

        VulkanImage(VulkanImage&& other) noexcept;
        VulkanImage& operator=(VulkanImage&& other) noexcept;
        static VulkanImage createFromFile(const VulkanDevice& device,
                                          const std::filesystem::path& filepath,
                                          bool srgb = true);

        static VulkanImage createFromMemory(const VulkanDevice& vulkan_device,
                                            const unsigned char* src_data,
                                            int width,
                                            int height,
                                            bool srgb);

        void transitionLayout(vk::CommandBuffer cmd,
                              vk::ImageLayout oldLayout,
                              vk::ImageLayout newLayout,
                              vk::PipelineStageFlags2 srcStage,
                              vk::PipelineStageFlags2 dstStage);

        [[nodiscard]] vk::Image image() const noexcept { return m_image; }
        [[nodiscard]] vk::ImageView view() const noexcept { return m_view; }
        [[nodiscard]] vk::Format format() const noexcept { return m_format; }
        [[nodiscard]] uint32_t width() const noexcept { return m_width; }
        [[nodiscard]] uint32_t height() const noexcept { return m_height; }

    private:
        void createImageView(vk::Device device, vk::ImageAspectFlags aspectFlags);
        void destroy() noexcept;

        VmaAllocator m_allocator{nullptr};
        vk::Image m_image{};
        vk::ImageView m_view{};
        VmaAllocation m_allocation{nullptr};

        vk::Format m_format{vk::Format::eUndefined};
        uint32_t m_width{0};
        uint32_t m_height{0};
        vk::Device m_device{};
    };

}

#endif
</file>

<file path="include/pnkr/renderer/vulkan/image/vulkan_sampler.hpp">
#ifndef PNKR_VULKAN_SAMPLER_HPP
#define PNKR_VULKAN_SAMPLER_HPP
#pragma once

#include <vulkan/vulkan.hpp>

namespace pnkr::renderer {

    class VulkanSampler {
    public:
        explicit VulkanSampler(vk::Device device,
                              vk::Filter magFilter = vk::Filter::eLinear,
                              vk::Filter minFilter = vk::Filter::eLinear,
                              vk::SamplerAddressMode addressMode = vk::SamplerAddressMode::eRepeat);

        ~VulkanSampler();

        VulkanSampler(const VulkanSampler&) = delete;
        VulkanSampler& operator=(const VulkanSampler&) = delete;

        VulkanSampler(VulkanSampler&& other) noexcept;
        VulkanSampler& operator=(VulkanSampler&& other) noexcept;

        [[nodiscard]] vk::Sampler sampler() const noexcept { return m_sampler; }

    private:
        void destroy() noexcept;

        vk::Device m_device{};
        vk::Sampler m_sampler{};
    };

}

#endif
</file>

<file path="include/pnkr/renderer/vulkan/pipeline/compute_pipeline.hpp">
#ifndef PNKR_COMPUTE_PIPELINE_HPP
#define PNKR_COMPUTE_PIPELINE_HPP
#pragma once

#include <vulkan/vulkan.hpp>
#include <vector>
#include <filesystem>
#include <memory>

namespace pnkr::renderer {

    class Renderer;

    class ComputePipeline {
    public:
        ComputePipeline(vk::Device device, vk::Pipeline pipeline, vk::PipelineLayout layout);
        ~ComputePipeline();

        [[nodiscard]] vk::Pipeline pipeline() const { return m_pipeline; }
        [[nodiscard]] vk::PipelineLayout layout() const { return m_layout; }

    private:
        vk::Device m_device;
        vk::Pipeline m_pipeline;
        vk::PipelineLayout m_layout;
    };

    class ComputePipelineBuilder {
    public:
        explicit ComputePipelineBuilder(Renderer& renderer);

        ComputePipelineBuilder& setShader(const std::filesystem::path& path);
        ComputePipelineBuilder& addDescriptorSetLayout(vk::DescriptorSetLayout layout);
        ComputePipelineBuilder& setPushConstantSize(uint32_t size);

        std::unique_ptr<ComputePipeline> build();

    private:
        Renderer& m_renderer;
        std::filesystem::path m_shaderPath;
        std::vector<vk::DescriptorSetLayout> m_layouts;
        uint32_t m_pushConstantSize = 0;
    };

}
#endif
</file>

<file path="include/pnkr/renderer/vulkan/pipeline/PipelineBuilder.h">
//
// Created by Jose on 12/14/2025.
//

#ifndef PNKR_PIPELINEBUILDER_H
#define PNKR_PIPELINEBUILDER_H
#pragma once

#include "pnkr/core/Handle.h"
#include <vulkan/vulkan.hpp>
#include <string>
#include <filesystem>
#include <vector>
#include "pnkr/renderer/geometry/VertexInputDescription.h"

namespace pnkr::renderer {

class Renderer;

class PipelineBuilder {
public:
    explicit PipelineBuilder(Renderer& renderer);

    // -- Shaders --
    PipelineBuilder& setShaders(const std::filesystem::path& vertSpv, const std::filesystem::path& fragSpv);

    // -- Input Assembly --
    PipelineBuilder& setInputTopology(vk::PrimitiveTopology topology);

    // -- Rasterization --
    PipelineBuilder& setPolygonMode(vk::PolygonMode mode);
    PipelineBuilder& setCullMode(vk::CullModeFlags cullMode, vk::FrontFace frontFace = vk::FrontFace::eCounterClockwise);
    PipelineBuilder& setLineWidth(float width);

    // -- Depth / Stencil --
    PipelineBuilder& enableDepthTest(bool enableWrite, vk::CompareOp op);
    PipelineBuilder& disableDepthTest();

    // -- Blending --
    // Simple preset: Standard Alpha Blending
    PipelineBuilder& enableAlphaBlending();
    // Simple preset: Additive Blending
    PipelineBuilder& enableAdditiveBlending();
    // Default: Opaque (no blending)
    PipelineBuilder& disableBlending();

    // -- Vertex Input --
    // We can accept the raw struct or a helper enum/class later
    // For now, let's keep using the existing VertexInputDescription system
    // but maybe just pass it in.
    // Ideally, we'd have .addVertexAttribute(...) methods, but let's stick to the struct for now.
    // Forward declare VertexInputDescription if possible or include header.

    PipelineBuilder& setPushConstantSize(uint32_t size);
    PipelineBuilder& addDescriptorSetLayout(vk::DescriptorSetLayout layout);
    PipelineBuilder& setVertexInput(const VertexInputDescription& description);
    PipelineBuilder& setRenderingFormats(vk::Format color, vk::Format depth);
    PipelineBuilder& setPushConstantsShaderFlags(vk::ShaderStageFlags pushConstantsShaderStages);
    PipelineBuilder& useBindless();

    [[nodiscard]] PipelineHandle build();

private:
    Renderer& m_renderer;

    // State storage
    std::filesystem::path m_vertPath;
    std::filesystem::path m_fragPath;

    vk::PrimitiveTopology m_topology = vk::PrimitiveTopology::eTriangleList;
    vk::PolygonMode m_polygonMode = vk::PolygonMode::eFill;
    vk::CullModeFlags m_cullMode = vk::CullModeFlagBits::eBack;
    vk::FrontFace m_frontFace = vk::FrontFace::eCounterClockwise;

    vk::Format m_colorFormat;
    vk::Format m_depthFormat;

    float m_lineWidth = 1.0f;

    struct DepthState {
        bool testEnable = true;
        bool writeEnable = true;
        vk::CompareOp compareOp = vk::CompareOp::eLess;
    } m_depthState;

    struct BlendState {
        bool enable = false;
        vk::BlendFactor srcColor = vk::BlendFactor::eOne;
        vk::BlendFactor dstColor = vk::BlendFactor::eZero;
        vk::BlendOp colorOp = vk::BlendOp::eAdd;
        vk::BlendFactor srcAlpha = vk::BlendFactor::eOne;
        vk::BlendFactor dstAlpha = vk::BlendFactor::eZero;
        vk::BlendOp alphaOp = vk::BlendOp::eAdd;
    } m_blendState;

    VertexInputDescription m_vertexInput;
    uint32_t m_pushConstantSize = 0;
    std::vector<vk::DescriptorSetLayout> m_descriptorLayouts;
    vk::ShaderStageFlags m_pushConstantStages;
    bool m_useBindless;
};

} // namespace pnkr::renderer
#endif //PNKR_PIPELINEBUILDER_H
</file>

<file path="include/pnkr/renderer/vulkan/pipeline/PipelineConfig.h">
#pragma once

#include <filesystem>
#include <vulkan/vulkan.hpp>

#include "PipelineBuilder.h"
#include "pnkr/renderer/geometry/VertexInputDescription.h"

namespace pnkr::renderer {

  struct DepthConfig {
    bool testEnable = false;
    bool writeEnable = false;
    vk::CompareOp compareOp = vk::CompareOp::eLess;
  };


  struct PipelineConfig {
    mutable vk::Format m_colorFormat{vk::Format::eUndefined};
    std::filesystem::path m_vertSpvPath;
    std::filesystem::path m_fragSpvPath;
    VertexInputDescription m_vertexInput;
    mutable vk::Format m_depthFormat = vk::Format::eUndefined;
    vk::CullModeFlags m_cullMode = vk::CullModeFlagBits::eBack;
    vk::FrontFace m_frontFace = vk::FrontFace::eCounterClockwise;
    DepthConfig m_depth{};

    std::vector<vk::DescriptorSetLayout> m_descriptorSetLayouts{};
    uint32_t m_pushConstantSize = 0;
    vk::ShaderStageFlags m_pushConstantStages = vk::ShaderStageFlagBits::eVertex;

    struct BlendConfig {
      bool enable = false;
      vk::BlendFactor srcColor = vk::BlendFactor::eOne;
      vk::BlendFactor dstColor = vk::BlendFactor::eZero;
      vk::BlendOp colorOp = vk::BlendOp::eAdd;
      vk::BlendFactor srcAlpha = vk::BlendFactor::eOne;
      vk::BlendFactor dstAlpha = vk::BlendFactor::eZero;
      vk::BlendOp alphaOp = vk::BlendOp::eAdd;
    } m_blend;

    vk::PrimitiveTopology m_topology = vk::PrimitiveTopology::eTriangleList;
    bool m_useBindless;
  };

} // namespace pnkr::renderer
</file>

<file path="include/pnkr/renderer/vulkan/PushConstants.h">
//
// Created by Jose on 12/13/2025.
//

#pragma once
#include <glm/mat4x4.hpp>

struct PushConstants {
  glm::mat4 m_model{1.0f};
  glm::mat4 m_viewProj{1.0f};

  uint32_t materialIndex = UINT32_MAX;  // Access materials[materialIndex]
  uint32_t meshIndex = UINT32_MAX;      // Access meshData[meshIndex]
  uint32_t _pad0 = 0;
  uint32_t _pad1 = 0;

};
</file>

<file path="include/pnkr/renderer/vulkan/vma.cpp">
//
// Created by Jose on 12/13/2025.
//

#define VMA_IMPLEMENTATION
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_buffer.hpp">
#pragma once

#include <vk_mem_alloc.h>
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer {
class VulkanDevice;

class VulkanBuffer {
public:
  VulkanBuffer(VmaAllocator allocator, vk::DeviceSize size,
               vk::BufferUsageFlags usage, VmaMemoryUsage memoryUsage,
               VmaAllocationCreateFlags allocFlags = 0);
  ~VulkanBuffer();

  VulkanBuffer(const VulkanBuffer &) = delete;
  VulkanBuffer &operator=(const VulkanBuffer &) = delete;

  VulkanBuffer(VulkanBuffer &&) noexcept;
  VulkanBuffer &operator=(VulkanBuffer &&) noexcept;

  void *map();
  void unmap();

  static VulkanBuffer
  CreateDeviceLocalAndUpload(const VulkanDevice &device, const void *data,
                             vk::DeviceSize size,
                             vk::BufferUsageFlags finalUsage);

  [[nodiscard]] const vk::Buffer &buffer() const noexcept { return m_buffer; }
  [[nodiscard]] vk::DeviceSize size() const { return m_size; }

private:
  void destroy() noexcept;

  VmaAllocator m_allocator{nullptr};

  // Stored as raw handle for VMA, exposed as vk::Buffer via accessor.
  vk::Buffer m_buffer{VK_NULL_HANDLE};
  VmaAllocation m_allocation{nullptr};

  vk::DeviceSize m_size{0};
  void *m_mapped{nullptr};
};

}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_command_buffer.hpp">
#pragma once

#include <cstdint>
#include <vector>
#include <vulkan/vulkan.hpp>
#include "vulkan_device.hpp"

namespace pnkr::renderer {
class VulkanCommandBuffer {
public:
  VulkanCommandBuffer(const VulkanDevice &vkDevice);
  ~VulkanCommandBuffer();

  VulkanCommandBuffer(const VulkanCommandBuffer &) = delete;
  VulkanCommandBuffer &operator=(const VulkanCommandBuffer &) = delete;

  VulkanCommandBuffer(VulkanCommandBuffer &&) noexcept = delete;
  VulkanCommandBuffer &operator=(VulkanCommandBuffer &&) noexcept = delete;

  [[nodiscard]] uint32_t framesInFlight() const { return m_frames; }
  [[nodiscard]] uint32_t currentFrame() const { return m_frameIndex; }

  void advanceFrame();

  vk::CommandBuffer begin(uint32_t frame);
  void end(uint32_t frame);

  void submit(uint32_t frame, vk::Queue graphicsQueue,
              vk::Semaphore imageAvailableSemaphore,
              vk::Semaphore renderFinishedSemaphore, vk::Fence signalFence,
              vk::PipelineStageFlags waitStage) const;

  [[nodiscard]] vk::CommandBuffer cmd(uint32_t frame) const {
    return m_cmd[frame];
  }
  [[nodiscard]] vk::CommandPool commandPool() const { return m_pool; }
private:
  void createPool(uint32_t graphicsQueueFamilyIndex);
  void allocateBuffers();
  VulkanCommandBuffer(vk::Device device, uint32_t graphicsQueueFamilyIndex,
                      uint32_t framesInFlight);
  vk::Device m_device{};
  vk::CommandPool m_pool{};

  uint32_t m_frames = 0;
  uint32_t m_frameIndex = 0;

  std::vector<vk::CommandBuffer> m_cmd;
};
}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_context.hpp">
#pragma once

#include <vulkan/vulkan.hpp>

namespace pnkr::platform {
class Window;
}

namespace pnkr::renderer {

class VulkanContext {
public:
  explicit VulkanContext(const pnkr::platform::Window &window);
  ~VulkanContext();

  VulkanContext(const VulkanContext &) = delete;
  VulkanContext &operator=(const VulkanContext &) = delete;

  VulkanContext(VulkanContext &&) = delete;
  VulkanContext &operator=(VulkanContext &&) = delete;

  [[nodiscard]] vk::Instance instance() const noexcept { return m_instance; }
  [[nodiscard]] vk::SurfaceKHR surface() const noexcept { return m_surface; }
  [[nodiscard]] const vk::detail::DispatchLoaderDynamic &
  dispatcher() const noexcept {
    return m_dld;
  }
  void initDispatcherPostDevice(vk::Device device);

private:
  void createInstance(const pnkr::platform::Window &window);
  void setupDebugMessenger();
  void createSurface(const pnkr::platform::Window &window);
  void initDispatcherPreInstance();
  void initDispatcherPostInstance();

  vk::detail::DynamicLoader m_dynamicLoader;
  vk::Instance m_instance{};
  vk::SurfaceKHR m_surface{};
  vk::detail::DispatchLoaderDynamic m_dld = {};

#ifndef NDEBUG
  vk::DebugUtilsMessengerEXT m_debugMessenger{};
  void (*(*m_vkGetInstanceProcAddr)(VkInstance_T *, const char *))();
#endif
};

}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_descriptor.hpp">
#pragma once

#include <vulkan/vulkan.hpp>
#include <vector>
#include <memory>

namespace pnkr::renderer {

class VulkanDescriptorAllocator {
public:
  explicit VulkanDescriptorAllocator(vk::Device device);
  ~VulkanDescriptorAllocator();

  VulkanDescriptorAllocator(const VulkanDescriptorAllocator&) = delete;
  VulkanDescriptorAllocator& operator=(const VulkanDescriptorAllocator&) = delete;

  vk::DescriptorSet allocate(vk::DescriptorSetLayout layout);
  void reset();
  [[nodiscard]] vk::Device device() const noexcept { return m_device; }
private:
  vk::DescriptorPool createPool();

  vk::Device m_device{};
  vk::DescriptorPool m_currentPool{};
  std::vector<vk::DescriptorPool> m_usedPools;
  std::vector<vk::DescriptorPool> m_freePools;
};

class VulkanDescriptorLayoutCache {
public:
  explicit VulkanDescriptorLayoutCache(vk::Device device);
  ~VulkanDescriptorLayoutCache();

  VulkanDescriptorLayoutCache(const VulkanDescriptorLayoutCache&) = delete;
  VulkanDescriptorLayoutCache& operator=(const VulkanDescriptorLayoutCache&) = delete;

  vk::DescriptorSetLayout createLayout(const vk::DescriptorSetLayoutCreateInfo& info);
  void cleanup();

private:
  struct DescriptorLayoutInfo {
    std::vector<vk::DescriptorSetLayoutBinding> bindings;

    bool operator==(const DescriptorLayoutInfo& other) const;
    size_t hash() const;
  };

  struct DescriptorLayoutHash {
    std::size_t operator()(const DescriptorLayoutInfo& info) const {
      return info.hash();
    }
  };

  vk::Device m_device{};
  std::unordered_map<DescriptorLayoutInfo, vk::DescriptorSetLayout, DescriptorLayoutHash> m_layoutCache;
};

class VulkanDescriptorBuilder {
  friend class VulkanDescriptorAllocator;
public:
  static VulkanDescriptorBuilder begin(VulkanDescriptorLayoutCache* cache,
                                       VulkanDescriptorAllocator* allocator);

  VulkanDescriptorBuilder& bindImage(uint32_t binding,
                                     vk::DescriptorImageInfo* imageInfo,
                                     vk::DescriptorType type,
                                     vk::ShaderStageFlags stageFlags);

  VulkanDescriptorBuilder& bindBuffer(uint32_t binding,
                                      vk::DescriptorBufferInfo* bufferInfo,
                                      vk::DescriptorType type,
                                      vk::ShaderStageFlags stageFlags);

  bool build(vk::DescriptorSet& set, vk::DescriptorSetLayout& layout);
  bool build(vk::DescriptorSet& set);

private:
  std::vector<vk::WriteDescriptorSet> m_writes;
  std::vector<vk::DescriptorSetLayoutBinding> m_bindings;

  VulkanDescriptorLayoutCache* m_cache{nullptr};
  VulkanDescriptorAllocator* m_allocator{nullptr};
};

}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_device.hpp">
#pragma once

#include <cstdint>
#include <vk_mem_alloc.h>
#include <vulkan/vulkan.hpp>

#include "vulkan_context.hpp"

namespace pnkr::renderer {

struct QueueFamilyIndices {
  uint32_t graphics = UINT32_MAX;
  uint32_t present = UINT32_MAX;

  [[nodiscard]] bool complete() const noexcept {
    return graphics != UINT32_MAX && present != UINT32_MAX;
  }
};

class VulkanDevice {
public:
  void create_upload_pool();
  VulkanDevice(VulkanContext &vk_context);
  void createAllocator();
  ~VulkanDevice();

  VulkanDevice(const VulkanDevice &) = delete;
  VulkanDevice &operator=(const VulkanDevice &) = delete;

  [[nodiscard]] vk::PhysicalDevice physicalDevice() const noexcept {
    return m_physicalDevice;
  }
  [[nodiscard]] vk::Device device() const noexcept { return m_device; }

  [[nodiscard]] const QueueFamilyIndices &queueFamilies() const noexcept {
    return m_indices;
  }

  [[nodiscard]] vk::Queue graphicsQueue() const noexcept {
    return m_graphicsQueue;
  }
  [[nodiscard]] vk::Queue presentQueue() const noexcept {
    return m_presentQueue;
  }
  uint32_t graphicsQueueFamily() const { return m_graphicsQueueFamilyIndex; }
  uint32_t presentQueueFamily() const { return m_presentQueueFamilyIndex; }
  uint32_t framesInFlight() const { return m_framesInFlight; }
  VmaAllocator m_allocator = nullptr;
  vk::CommandPool m_uploadPool;
  VmaAllocator allocator() const { return m_allocator; }
  void immediateSubmit(std::function<void(vk::CommandBuffer)> &&record) const;

private:
  void pickPhysicalDevice(vk::Instance instance, vk::SurfaceKHR surface);
  void createLogicalDevice(vk::SurfaceKHR surface);

  static QueueFamilyIndices findQueueFamilies(vk::PhysicalDevice pd,
                                              vk::SurfaceKHR surface);
  static bool supportsDeviceExtensions(vk::PhysicalDevice pd);

  vk::PhysicalDevice m_physicalDevice{};
  vk::Device m_device{};
  QueueFamilyIndices m_indices{};

  uint32_t m_graphicsQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  uint32_t m_presentQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  uint32_t m_framesInFlight = 2;
  vk::Queue m_graphicsQueue{};
  vk::Queue m_presentQueue{};
  VulkanContext &m_context;
};

}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_pipeline.hpp">
#pragma once
#include <vulkan/vulkan.hpp>

#include "pnkr/renderer/geometry/VertexInputDescription.h"
#include "pipeline/PipelineConfig.h"

namespace pnkr::renderer {

class VulkanPipeline {
public:
  using Config = PipelineConfig;

  VulkanPipeline(vk::Device device,
                 const Config &config);
  void reset() noexcept;
  ~VulkanPipeline();

  VulkanPipeline(const VulkanPipeline &) = delete;
  VulkanPipeline &operator=(const VulkanPipeline &) = delete;

  VulkanPipeline(VulkanPipeline &&) noexcept;
  VulkanPipeline &operator=(VulkanPipeline &&) noexcept;

  [[nodiscard]] vk::Pipeline pipeline() const noexcept { return m_pipeline; }
  [[nodiscard]] vk::PipelineLayout layout() const noexcept { return m_layout; }
  [[nodiscard]] vk::Format colorFormat() const noexcept {
    return m_colorFormat;
  }
  const Config &config() const { return m_config; }

private:
  void createShaderModules(const Config &config);
  void createPipelineLayout();
  void createGraphicsPipeline(const PipelineConfig &config);

  Config m_config;
  vk::Device m_device{};
  vk::Format m_colorFormat{vk::Format::eUndefined};

  vk::ShaderModule m_vert{};
  vk::ShaderModule m_frag{};
  vk::PipelineLayout m_layout{};
  vk::Pipeline m_pipeline{};
  VertexInputDescription m_vertexInput;
};

}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_render_target.h">
//
// Created by Jose on 12/14/2025.
//

#ifndef PNKR_VULKANRENDERTARGET_H
#define PNKR_VULKANRENDERTARGET_H
#pragma once
#include <array>
#include "pnkr/renderer/vulkan/image/vulkan_image.hpp"
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer {

    class VulkanRenderTarget {
    public:
        VulkanRenderTarget(VmaAllocator allocator,
                     vk::Device device,
                     uint32_t width,
                     uint32_t height,
                     vk::Format colorFormat,
                     vk::Format depthFormat);

        ~VulkanRenderTarget() = default;

        // Non-copyable, movable
        VulkanRenderTarget(const VulkanRenderTarget&) = delete;
        VulkanRenderTarget& operator=(const VulkanRenderTarget&) = delete;
        VulkanRenderTarget(VulkanRenderTarget&&) = default;
        VulkanRenderTarget& operator=(VulkanRenderTarget&&) = default;

        [[nodiscard]] const VulkanImage& colorImage() const { return m_colorImage; }
        [[nodiscard]] const VulkanImage& depthImage() const { return m_depthImage; }
        [[nodiscard]] vk::Extent2D extent() const { return {m_width, m_height}; }
        [[nodiscard]] vk::Viewport viewport() const;
        [[nodiscard]] vk::Rect2D scissor() const;

        // Helper to start rendering into this target
        void beginRendering(vk::CommandBuffer cmd,
                            vk::ClearValue colorClear = vk::ClearValue{vk::ClearColorValue{std::array<float, 4>{0.1f, 0.1f, 0.1f, 1.0f}}},
                            vk::ClearValue depthClear = vk::ClearValue{vk::ClearDepthStencilValue{1.0f, 0}});

        void endRendering(vk::CommandBuffer cmd);

        // Transition layouts for drawing
        void transitionToAttachment(vk::CommandBuffer cmd);

        // Transition color for reading (sampling/transfer)
        void transitionToRead(vk::CommandBuffer cmd);

    private:
        uint32_t m_width;
        uint32_t m_height;
        VulkanImage m_colorImage;
        VulkanImage m_depthImage;
    };

} // namespace pnkr::renderer

#endif //PNKR_VULKANRENDERTARGET_H
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_swapchain.hpp">
#pragma once

#include <vector>
#include <vma/vk_mem_alloc.h>
#include <vulkan/vulkan.hpp>

namespace pnkr::platform {
class Window;
}

namespace pnkr::renderer {
class VulkanSwapchain {
public:
  VulkanSwapchain(vk::PhysicalDevice physicalDevice, vk::Device device,
                  vk::SurfaceKHR surface, uint32_t graphicsQueueFamily,
                  uint32_t presentQueueFamily, pnkr::platform::Window &window,
                  VmaAllocator allocator);

  ~VulkanSwapchain();

  VulkanSwapchain(const VulkanSwapchain &) = delete;
  VulkanSwapchain &operator=(const VulkanSwapchain &) = delete;

  void recreate(vk::PhysicalDevice physicalDevice, vk::Device device,
                vk::SurfaceKHR surface, uint32_t graphicsQueueFamily,
                uint32_t presentQueueFamily, platform::Window &window);

  [[nodiscard]] vk::SwapchainKHR swapchain() const noexcept {
    return m_swapchain;
  }
  [[nodiscard]] vk::Format imageFormat() const noexcept { return m_format; }
  [[nodiscard]] vk::Extent2D extent() const noexcept { return m_extent; }

  [[nodiscard]] const std::vector<vk::Image> &images() const noexcept {
    return m_images;
  }
  [[nodiscard]] const std::vector<vk::ImageView> &imageViews() const noexcept {
    return m_imageViews;
  }

  vk::Result acquireNextImage(uint64_t timeoutNs, vk::Semaphore imageAvailable,
                              vk::Fence fence, uint32_t &outImageIndex);

  vk::Result present(vk::Queue presentQueue, uint32_t imageIndex,
                     vk::Semaphore renderFinished);
  vk::ImageLayout &imageLayout(uint32_t index) { return m_imageLayouts[index]; }
  vk::ImageLayout imageLayout(uint32_t index) const {
    return m_imageLayouts[index];
  }
  vk::Format depthFormat() const noexcept { return m_depthFormat; }
  vk::ImageView depthImageView() const noexcept { return m_depthView; }
  bool hasDepth() const noexcept {
    return depthFormat() != vk::Format::eUndefined && depthImageView();
  }
  vk::Image depthImage() const noexcept { return m_depthImage; }

private:
  void createDepthResources();
  void destroyDepthResources();

  VmaAllocator m_allocator{nullptr};

  vk::Format m_depthFormat = vk::Format::eD32Sfloat;
  vk::Image m_depthImage{};
  VmaAllocation m_depthAlloc{nullptr};
  vk::ImageView m_depthView{};

  bool m_depthNeedsInitBarrier = true;

  void destroy(vk::Device device);

  void createSwapchain(vk::PhysicalDevice physicalDevice, vk::Device device,
                       vk::SurfaceKHR surface, uint32_t graphicsQueueFamily,
                       uint32_t presentQueueFamily,
                       pnkr::platform::Window &window);

  void createImageViews(vk::Device device);

  static vk::SurfaceFormatKHR
  chooseSurfaceFormat(const std::vector<vk::SurfaceFormatKHR> &formats);
  static vk::PresentModeKHR
  choosePresentMode(const std::vector<vk::PresentModeKHR> &modes);
  static vk::Extent2D chooseExtent(const vk::SurfaceCapabilitiesKHR &caps,
                                   pnkr::platform::Window &window);

  vk::SwapchainKHR m_swapchain{nullptr};
  vk::Format m_format{};
  vk::Extent2D m_extent{};
  vk::Device m_device{nullptr};

  std::vector<vk::Image> m_images;
  std::vector<vk::ImageView> m_imageViews;
  std::vector<vk::ImageLayout> m_imageLayouts;
};
}
</file>

<file path="include/pnkr/renderer/vulkan/vulkan_sync_manager.h">
#pragma once
#include <vector>
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer {
class VulkanSyncManager {
public:
  // framesInFlight: for fences and acquire semaphores (limit CPU ahead of GPU)
  // swapchainImageCount: for render finished semaphores (limit GPU ahead of
  // Display)
  VulkanSyncManager(vk::Device device, uint32_t framesInFlight,
                    uint32_t swapchainImageCount);
  ~VulkanSyncManager();

  VulkanSyncManager(const VulkanSyncManager &) = delete;
  VulkanSyncManager &operator=(const VulkanSyncManager &) = delete;

  // Recreate image-dependent semaphores (call on swapchain resize)
  void updateSwapchainSize(uint32_t swapchainImageCount);

  // Frame-bound (use current frame index)
  [[nodiscard]] vk::Semaphore
  imageAvailableSemaphore(uint32_t frameIndex) const {
    return m_imageAvailableSemaphores[frameIndex];
  }

  [[nodiscard]] vk::Fence inFlightFence(uint32_t frameIndex) const {
    return m_inFlightFences[frameIndex];
  }

  // Image-bound (use swapchain image index)
  [[nodiscard]] vk::Semaphore
  renderFinishedSemaphore(uint32_t imageIndex) const {
    return m_renderFinishedSemaphores[imageIndex];
  }

  void waitForFrame(uint32_t frameIndex) const;
  void resetFrame(uint32_t frameIndex) const;

private:
  void destroyImageSemaphores();

  vk::Device m_device;
  uint32_t m_framesInFlight;

  std::vector<vk::Semaphore> m_imageAvailableSemaphores; // [Frame]
  std::vector<vk::Fence> m_inFlightFences;               // [Frame]

  std::vector<vk::Semaphore> m_renderFinishedSemaphores; // [ImageIndex]
};
} // namespace pnkr::renderer
</file>

<file path="include/pnkr/rhi/rhi_buffer.hpp">
#pragma once

#include "rhi_types.hpp"
#include <cstdint>

namespace pnkr::renderer::rhi
{
    struct BufferDescriptor
    {
        uint64_t size;
        BufferUsage usage;
        MemoryUsage memoryUsage;
        const char* debugName = nullptr;
    };

    class RHIBuffer
    {
    public:
        virtual ~RHIBuffer() = default;

        // Map/unmap for CPU access
        virtual void* map() = 0;
        virtual void unmap() = 0;

        // Upload data (convenience for map/memcpy/unmap)
        virtual void uploadData(const void* data, uint64_t size, uint64_t offset = 0) = 0;

        // Getters
        virtual uint64_t size() const = 0;
        virtual BufferUsage usage() const = 0;
        virtual MemoryUsage memoryUsage() const = 0;

        // Backend-specific handle (for interop)
        virtual void* nativeHandle() const = 0;
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_command_buffer.hpp">
#pragma once

#include "rhi_types.hpp"
#include <vector>

#include "rhi_texture.hpp"
#include "rhi_descriptor.hpp"

namespace pnkr::renderer::rhi
{
    // Forward declarations
    class RHIBuffer;
    class RHITexture;
    class RHIPipeline;

    // Memory barrier - renamed to avoid Windows macro conflict
    struct RHIMemoryBarrier
    {
        RHIBuffer* buffer = nullptr;
        RHITexture* texture = nullptr;
        ShaderStage srcAccessStage;
        ShaderStage dstAccessStage;
        // For textures
        ResourceLayout oldLayout = ResourceLayout::Undefined;
        ResourceLayout newLayout = ResourceLayout::Undefined;
    };

    // Buffer to texture copy region
    struct BufferTextureCopyRegion
    {
        uint64_t bufferOffset = 0;
        uint32_t bufferRowLength = 0;
        uint32_t bufferImageHeight = 0;

        TextureSubresource textureSubresource;

        struct {
            int32_t x = 0;
            int32_t y = 0;
            int32_t z = 0;
        } textureOffset;

        Extent3D textureExtent;
    };

    // Rendering attachment
    struct RenderingAttachment
    {
        RHITexture* texture;
        LoadOp loadOp;
        StoreOp storeOp;
        ClearValue clearValue;
    };

    // Dynamic rendering info
    struct RenderingInfo
    {
        Rect2D renderArea;
        std::vector<RenderingAttachment> colorAttachments;
        RenderingAttachment* depthAttachment = nullptr;
        RenderingAttachment* stencilAttachment = nullptr;
    };

    class RHICommandBuffer
    {
    public:
        virtual ~RHICommandBuffer() = default;

        // Command buffer lifecycle
        virtual void begin() = 0;
        virtual void end() = 0;
        virtual void reset() = 0;

        // Rendering commands
        virtual void beginRendering(const RenderingInfo& info) = 0;
        virtual void endRendering() = 0;

        // Pipeline binding
        virtual void bindPipeline(RHIPipeline* pipeline) = 0;

        // Vertex/index buffers
        virtual void bindVertexBuffer(uint32_t binding, RHIBuffer* buffer, uint64_t offset = 0) = 0;
        virtual void bindIndexBuffer(RHIBuffer* buffer, uint64_t offset = 0, bool use16Bit = false) = 0;

        // Draw commands
        virtual void draw(uint32_t vertexCount, uint32_t instanceCount = 1,
                         uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0;
        virtual void drawIndexed(uint32_t indexCount, uint32_t instanceCount = 1,
                                uint32_t firstIndex = 0, int32_t vertexOffset = 0,
                                uint32_t firstInstance = 0) = 0;

        // Compute dispatch
        virtual void dispatch(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) = 0;

        // Push constants
        virtual void pushConstants(RHIPipeline* pipeline, ShaderStage stages,
                                  uint32_t offset, uint32_t size, const void* data) = 0;

        // Descriptor sets
        virtual void bindDescriptorSet(RHIPipeline* pipeline, uint32_t setIndex,
                                      RHIDescriptorSet* descriptorSet) = 0;
        virtual void bindDescriptorSet(RHIPipeline* pipeline, uint32_t setIndex,
                                      void* nativeDescriptorSet) = 0;

        // Dynamic state
        virtual void setViewport(const Viewport& viewport) = 0;
        virtual void setScissor(const Rect2D& scissor) = 0;

        // Memory barriers and layout transitions
        virtual void pipelineBarrier(
            ShaderStage srcStage,
            ShaderStage dstStage,
            const std::vector<RHIMemoryBarrier>& barriers) = 0;

        // Copy operations
        virtual void copyBuffer(RHIBuffer* src, RHIBuffer* dst,
                               uint64_t srcOffset, uint64_t dstOffset, uint64_t size) = 0;
        virtual void copyBufferToTexture(RHIBuffer* src, RHITexture* dst,
                                        const BufferTextureCopyRegion& region) = 0;

        // Backend handle
        virtual void* nativeHandle() const = 0;
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_descriptor.hpp">
#pragma once

#include <cstdint>
#include "rhi_pipeline.hpp"

namespace pnkr::renderer::rhi
{
    class RHIBuffer;
    class RHITexture;
    class RHISampler;

    class RHIDescriptorSetLayout
    {
    public:
        virtual ~RHIDescriptorSetLayout() = default;
        virtual void* nativeHandle() const = 0;
        virtual const DescriptorSetLayout& description() const = 0;
    };

    class RHIDescriptorSet
    {
    public:
        virtual ~RHIDescriptorSet() = default;

        virtual void updateBuffer(uint32_t binding,
                                  RHIBuffer* buffer,
                                  uint64_t offset,
                                  uint64_t range) = 0;
        virtual void updateTexture(uint32_t binding,
                                   RHITexture* texture,
                                   RHISampler* sampler) = 0;

        virtual void* nativeHandle() const = 0;
    };
} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_device.hpp">
#pragma once

#include "rhi_types.hpp"
#include <memory>
#include <string>
#include <vector>

namespace pnkr::renderer::rhi
{
    // Forward declarations
    class RHIBuffer;
    class RHITexture;
    class RHIPipeline;
    class RHISwapchain;
    class RHICommandBuffer;
    class RHISampler;
    class RHIDescriptorSetLayout;
    class RHIDescriptorSet;

    // Physical device capabilities
    struct DeviceCapabilities
    {
        std::string deviceName;
        uint32_t vendorID;
        uint32_t deviceID;
        bool discreteGPU;

        // Limits
        uint32_t maxImageDimension2D;
        uint32_t maxImageDimension3D;
        uint32_t maxFramebufferWidth;
        uint32_t maxFramebufferHeight;
        uint32_t maxColorAttachments;

        // Features
        bool geometryShader;
        bool tessellationShader;
        bool samplerAnisotropy;
        bool textureCompressionBC;
        bool bindlessTextures;
        bool rayTracing;
        bool meshShading;
    };

    // Queue family information
    struct QueueFamilyInfo
    {
        uint32_t familyIndex;
        uint32_t queueCount;
        bool supportsGraphics;
        bool supportsCompute;
        bool supportsTransfer;
    };

    // Device creation descriptor
    struct DeviceDescriptor
    {
        std::vector<const char*> requiredExtensions;
        std::vector<const char*> optionalExtensions;
        bool enableValidation = false;
        bool enableBindless = false;
        bool enableRayTracing = false;
    };

    // Abstract physical device
    class RHIPhysicalDevice
    {
    public:
        virtual ~RHIPhysicalDevice() = default;

        virtual const DeviceCapabilities& capabilities() const = 0;
        virtual std::vector<QueueFamilyInfo> queueFamilies() const = 0;
        virtual bool supportsPresentation(uint32_t queueFamily) const = 0;
    };

    // Abstract logical device
    class RHIDevice
    {
    public:
        virtual ~RHIDevice() = default;

        // Resource creation
        virtual std::unique_ptr<RHIBuffer> createBuffer(
            uint64_t size,
            BufferUsage usage,
            MemoryUsage memoryUsage) = 0;

        virtual std::unique_ptr<RHITexture> createTexture(
            const Extent3D& extent,
            Format format,
            TextureUsage usage,
            uint32_t mipLevels = 1,
            uint32_t arrayLayers = 1) = 0;

        virtual std::unique_ptr<RHITexture> createCubemap(
            const Extent3D& extent,
            Format format,
            TextureUsage usage,
            uint32_t mipLevels = 1) = 0;

        virtual std::unique_ptr<RHISampler> createSampler(
            Filter minFilter,
            Filter magFilter,
            SamplerAddressMode addressMode) = 0;

        virtual std::unique_ptr<RHICommandBuffer> createCommandBuffer() = 0;

        // Pipeline creation (will be detailed later)
        virtual std::unique_ptr<RHIPipeline> createGraphicsPipeline(
            const struct GraphicsPipelineDescriptor& desc) = 0;

        virtual std::unique_ptr<RHIPipeline> createComputePipeline(
            const struct ComputePipelineDescriptor& desc) = 0;

        // Descriptor sets/layouts
        virtual std::unique_ptr<RHIDescriptorSetLayout> createDescriptorSetLayout(
            const struct DescriptorSetLayout& desc) = 0;
        virtual std::unique_ptr<RHIDescriptorSet> allocateDescriptorSet(
            RHIDescriptorSetLayout* layout) = 0;

        // Synchronization
        virtual void waitIdle() = 0;
        virtual void waitForFences(const std::vector<uint64_t>& fenceValues) = 0;

        // Queue submission
        virtual void submitCommands(
            RHICommandBuffer* commandBuffer,
            const std::vector<uint64_t>& waitSemaphores = {},
            const std::vector<uint64_t>& signalSemaphores = {}) = 0;

        // Device queries
        virtual const RHIPhysicalDevice& physicalDevice() const = 0;
        virtual uint32_t graphicsQueueFamily() const = 0;
        virtual uint32_t computeQueueFamily() const = 0;
        virtual uint32_t transferQueueFamily() const = 0;

        // Bindless Registration
        virtual BindlessHandle registerBindlessTexture(RHITexture* texture, RHISampler* sampler) = 0;
        virtual BindlessHandle registerBindlessCubemap(RHITexture* texture, RHISampler* sampler) = 0;
        virtual BindlessHandle registerBindlessBuffer(RHIBuffer* buffer) = 0;

        // To bind the global set to a command buffer
        virtual void* getBindlessDescriptorSetNative() = 0; 
        virtual RHIDescriptorSetLayout* getBindlessDescriptorSetLayout() = 0;
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_factory.hpp">
#pragma once

#include "rhi_types.hpp"
#include "rhi_device.hpp"
#include "rhi_swapchain.hpp"
#include <memory>
#include <vector>

namespace pnkr::platform { class Window; }

namespace pnkr::renderer::rhi
{
    class RHIFactory
    {
    public:
        // Enumerate available physical devices
        static std::vector<std::unique_ptr<RHIPhysicalDevice>>
            enumeratePhysicalDevices(RHIBackend backend);

        // Create device
        static std::unique_ptr<RHIDevice> createDevice(
            RHIBackend backend,
            RHIPhysicalDevice* physicalDevice,
            const DeviceDescriptor& desc);

        // Auto-select best device
        static std::unique_ptr<RHIDevice> createDeviceAuto(
            RHIBackend backend,
            const DeviceDescriptor& desc);

        // Create swapchain for a window
        static std::unique_ptr<RHISwapchain> createSwapchain(
            RHIDevice* device,
            platform::Window& window,
            Format preferredFormat = Format::B8G8R8A8_SRGB);
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_pipeline_builder.hpp">
#pragma once

#include "pnkr/rhi/rhi_pipeline.hpp"
#include <vector>

#include "rhi_shader.hpp"

namespace pnkr::renderer::rhi
{
    class RHIPipelineBuilder
    {
    public:
        RHIPipelineBuilder();

        // --- Shaders (Auto-Reflection) ---
        // Clears existing shaders and merges reflection data from the provided shaders.
        RHIPipelineBuilder& setShaders(const Shader* vert, const Shader* frag);
        RHIPipelineBuilder& setComputeShader(const Shader* comp);


        template <typename T>
        RHIPipelineBuilder& useVertexType()
        {
            m_vertexStride = sizeof(T);
            auto layout = T::getLayout();
            m_cppLayout.clear();
            for (auto& l : layout) m_cppLayout.push_back({l.m_semantic, l.m_offset, l.m_format});
            return *this;
        }


        // --- Input Assembly ---
        RHIPipelineBuilder& setTopology(PrimitiveTopology topology);

        // --- Rasterization ---
        RHIPipelineBuilder& setPolygonMode(PolygonMode mode);
        RHIPipelineBuilder& setCullMode(CullMode mode, bool frontFaceCCW = true);
        RHIPipelineBuilder& setLineWidth(float width);

        // --- Depth / Stencil ---
        RHIPipelineBuilder& enableDepthTest(bool writeEnable = true, CompareOp op = CompareOp::Less);
        RHIPipelineBuilder& disableDepthTest();

        // --- Blending ---
        RHIPipelineBuilder& setNoBlend();
        RHIPipelineBuilder& setAlphaBlend();
        RHIPipelineBuilder& setAdditiveBlend();

        // --- Output Formats ---
        RHIPipelineBuilder& setColorFormat(Format format);
        RHIPipelineBuilder& setColorFormats(const std::vector<Format>& formats);
        RHIPipelineBuilder& setDepthFormat(Format format);

        // --- Manual Overrides (Optional) ---
        RHIPipelineBuilder& addPushConstant(ShaderStage stages, uint32_t offset, uint32_t size);
        RHIPipelineBuilder& setDescriptorSetLayouts(const std::vector<DescriptorSetLayout>& layouts);

        // --- Debug ---
        RHIPipelineBuilder& setName(const char* name);

        // --- Build ---
        [[nodiscard]] GraphicsPipelineDescriptor buildGraphics() const;
        [[nodiscard]] ComputePipelineDescriptor buildCompute() const;

    private:
        GraphicsPipelineDescriptor m_gfxDesc;
        ComputePipelineDescriptor m_compDesc;
        std::vector<ReflectedInput> m_reflectedInputAttributes;

        struct CppElement
        {
            VertexSemantic semantic;
            uint32_t offset;
            Format format;
        };

        std::vector<CppElement> m_cppLayout;
        uint32_t m_vertexStride = 0;

        // Helper to merge reflection data into the target descriptor
        void mergeReflection(const ShaderReflectionData& reflection);

        // Internal storage for merged reflection before finalize
        std::vector<DescriptorSetLayout> m_mergedLayouts;
        std::vector<PushConstantRange> m_mergedPushConstants;
    };
} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_pipeline.hpp">
#pragma once

#include "rhi_types.hpp"
#include "rhi_descriptor.hpp"
#include <vector>
#include <string>



namespace pnkr::renderer::rhi
{
    class RHIDescriptorSetLayout;
    // Shader module

    struct ShaderModuleDescriptor
    {
        ShaderStage stage;
        std::vector<uint32_t> spirvCode;  // SPIR-V bytecode
        std::string entryPoint = "main";
    };

    // Rasterization state
    struct RasterizationState
    {
        PolygonMode polygonMode = PolygonMode::Fill;
        CullMode cullMode = CullMode::Back;
        bool frontFaceCCW = true;
        float lineWidth = 1.0f;
    };

    // Depth/stencil state
    struct DepthStencilState
    {
        bool depthTestEnable = true;
        bool depthWriteEnable = true;
        CompareOp depthCompareOp = CompareOp::Less;
        bool stencilTestEnable = false;
    };

    // Blend state
    struct BlendAttachment
    {
        bool blendEnable = false;
        BlendFactor srcColorBlendFactor = BlendFactor::One;
        BlendFactor dstColorBlendFactor = BlendFactor::Zero;
        BlendOp colorBlendOp = BlendOp::Add;
        BlendFactor srcAlphaBlendFactor = BlendFactor::One;
        BlendFactor dstAlphaBlendFactor = BlendFactor::Zero;
        BlendOp alphaBlendOp = BlendOp::Add;
    };

    struct BlendState
    {
        std::vector<BlendAttachment> attachments;
    };

    // Push constant range
    struct PushConstantRange
    {
        ShaderStage stages;
        uint32_t offset;
        uint32_t size;
    };

    // Descriptor set layout binding
    struct DescriptorBinding
    {
        uint32_t binding;
        DescriptorType type;
        uint32_t count = 1;
        ShaderStage stages;
    };

    struct DescriptorSetLayout
    {
        std::vector<DescriptorBinding> bindings;
    };

    // Graphics pipeline descriptor
    struct GraphicsPipelineDescriptor
    {
        // Shaders
        std::vector<ShaderModuleDescriptor> shaders;

        // Vertex input
        std::vector<VertexInputBinding> vertexBindings;
        std::vector<VertexInputAttribute> vertexAttributes;

        // Input assembly
        PrimitiveTopology topology = PrimitiveTopology::TriangleList;

        // Rasterization
        RasterizationState rasterization;

        // Depth/stencil
        DepthStencilState depthStencil;

        // Blending
        BlendState blend;

        // Render target formats
        std::vector<Format> colorFormats;
        Format depthFormat = Format::Undefined;

        // Resource layouts
        std::vector<DescriptorSetLayout> descriptorSets;
        std::vector<PushConstantRange> pushConstants;

        const char* debugName = nullptr;
    };

    // Compute pipeline descriptor
    struct ComputePipelineDescriptor
    {
        ShaderModuleDescriptor shader;
        std::vector<DescriptorSetLayout> descriptorSets;
        std::vector<PushConstantRange> pushConstants;
        const char* debugName = nullptr;
    };

    class RHIPipeline
    {
    public:
        virtual ~RHIPipeline() = default;

        virtual PipelineBindPoint bindPoint() const = 0;
        virtual void* nativeHandle() const = 0;
        virtual RHIDescriptorSetLayout* descriptorSetLayout(uint32_t setIndex) const = 0;
        virtual uint32_t descriptorSetLayoutCount() const = 0;
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_sampler.hpp">
#pragma once

#include "rhi_types.hpp"

namespace pnkr::renderer::rhi
{
    class RHISampler
    {
    public:
        virtual ~RHISampler() = default;

        // Backend-specific handle
        virtual void* nativeHandle() const = 0;
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_shader.hpp">
#pragma once

#include "pnkr/rhi/rhi_types.hpp"
#include "pnkr/rhi/rhi_pipeline.hpp" // For DescriptorSetLayout definitions
#include <vector>
#include <string>
#include <filesystem>
#include <unordered_map>

namespace pnkr::renderer::rhi {

    struct ReflectedInput {
        uint32_t location;
        VertexSemantic semantic;
    };

    struct ShaderReflectionData {
        std::vector<DescriptorSetLayout> descriptorSets;
        std::vector<PushConstantRange> pushConstants;
        std::vector<ReflectedInput> inputAttributes; // Only for Vertex Stage
        std::string entryPoint = "main";
    };

    struct ReflectionConfig {
        // Map specific resource names to their descriptor counts
        std::unordered_map<std::string, uint32_t> bindlessOverrides = {
            {"bindlessTextures", 100000},
            {"bindlessStorageBuffers", 100000},
            {"bindlessStorageImages", 10000}
        };

        // Default size for runtime arrays not explicitly configured
        uint32_t defaultBindlessSize = 1000;

        // Enable/disable runtime array detection
        bool enableRuntimeArrayDetection = true;
    };

    class Shader {
    public:
        Shader(ShaderStage stage, const std::vector<uint32_t>& spirvCode, const ReflectionConfig& config = {});
        static std::unique_ptr<Shader> load(ShaderStage stage, const std::filesystem::path& path, const ReflectionConfig& config = {});

        [[nodiscard]] ShaderStage stage() const { return m_stage; }
        [[nodiscard]] const std::vector<uint32_t>& code() const { return m_code; }
        [[nodiscard]] const ShaderReflectionData& reflection() const { return m_reflection; }

    private:
        ShaderStage m_stage;
        std::vector<uint32_t> m_code;
        ShaderReflectionData m_reflection;
        ReflectionConfig m_config;
        void reflect();
    };
}
</file>

<file path="include/pnkr/rhi/rhi_swapchain.hpp">
#pragma once

#include "pnkr/rhi/rhi_types.hpp"
#include <cstdint>

namespace pnkr::platform { class Window; }

namespace pnkr::renderer::rhi
{
    class RHICommandBuffer;
    class RHITexture;

    struct SwapchainFrame
    {
        uint32_t imageIndex = 0;
        RHITexture* color = nullptr; // non-owning
    };

    class RHISwapchain
    {
    public:
        virtual ~RHISwapchain() = default;

        virtual Format colorFormat() const = 0;
        virtual Extent2D extent() const = 0;
        virtual uint32_t imageCount() const = 0;
        virtual uint32_t framesInFlight() const = 0;

        // Contract:
        // - cmd must NOT be in recording state (swapchain will reset/begin it once the frame fence is satisfied).
        // - On success, out.color is a valid backbuffer texture for this frame.
        // - The swapchain will record a transition to ColorAttachment for the acquired image.
        virtual bool beginFrame(uint32_t frameIndex, RHICommandBuffer* cmd, SwapchainFrame& out) = 0;

        // Contract:
        // - cmd must be in recording state and already contains all rendering commands targeting the acquired image.
        // - The swapchain will record a transition to Present, end the command buffer, submit, and present.
        virtual bool endFrame(uint32_t frameIndex, RHICommandBuffer* cmd) = 0;

        // Explicit swapchain rebuild (used on OUT_OF_DATE / resize).
        virtual void recreate(uint32_t width, uint32_t height) = 0;
    };
} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_texture.hpp">
#pragma once

#include "rhi_types.hpp"

namespace pnkr::renderer::rhi
{
    enum class TextureType
    {
        Texture1D,
        Texture2D,
        Texture3D,
        TextureCube
    };

    struct TextureDescriptor
    {
        TextureType type = TextureType::Texture2D;
        Extent3D extent;
        Format format;
        TextureUsage usage;
        uint32_t mipLevels = 1;
        uint32_t arrayLayers = 1;
        const char* debugName = nullptr;
    };

    struct TextureSubresource
    {
        uint32_t mipLevel = 0;
        uint32_t arrayLayer = 0;
    };

    class RHITexture
    {
    public:
        virtual ~RHITexture() = default;

        // Upload texture data
        virtual void uploadData(
            const void* data,
            uint64_t dataSize,
            const TextureSubresource& subresource = {}) = 0;

        // Generate mipmaps
        virtual void generateMipmaps() = 0;

        // Getters
        virtual const Extent3D& extent() const = 0;
        virtual Format format() const = 0;
        virtual uint32_t mipLevels() const = 0;
        virtual uint32_t arrayLayers() const = 0;
        virtual TextureUsage usage() const = 0;

        // Backend-specific handle
        virtual void* nativeHandle() const = 0;
        virtual void* nativeView() const = 0;  // Image view
    };

} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/rhi_types.hpp">
#pragma once

#include <cstdint>
#include <string>
#include <vector>

namespace pnkr::renderer::rhi
{
    // Backend selection
    enum class RHIBackend
    {
        Vulkan,
        DirectX12,
        Metal,
        Auto // Auto-detect best available
    };

    enum class ResourceLayout
    {
        Undefined,
        General,
        ColorAttachment,
        DepthStencilAttachment,
        DepthStencilReadOnly,
        ShaderReadOnly,
        TransferSrc,
        TransferDst,
        Present
    };

    // Resource formats (map to VkFormat, DXGI_FORMAT, MTLPixelFormat)
    enum class Format
    {
        Undefined,

        // Color formats
        R8_UNORM,
        R8G8_UNORM,
        R8G8B8_UNORM,
        R8G8B8A8_UNORM,
        R8G8B8A8_SRGB,
        B8G8R8A8_UNORM,
        B8G8R8A8_SRGB,

        R16_SFLOAT,
        R16G16_SFLOAT,
        R16G16B16A16_SFLOAT,

        R32_SFLOAT,
        R32G32_SFLOAT,
        R32G32B32_SFLOAT,
        R32G32B32A32_SFLOAT,

        // Depth/stencil formats
        D16_UNORM,
        D32_SFLOAT,
        D24_UNORM_S8_UINT,
        D32_SFLOAT_S8_UINT,

        // Compressed formats
        BC1_RGB_UNORM,
        BC1_RGB_SRGB,
        BC3_UNORM,
        BC3_SRGB,
        BC7_UNORM,
        BC7_SRGB
    };

    // Buffer usage flags
    enum class BufferUsage : uint32_t
    {
        None = 0,
        TransferSrc = 1 << 0,
        TransferDst = 1 << 1,
        UniformBuffer = 1 << 2,
        StorageBuffer = 1 << 3,
        IndexBuffer = 1 << 4,
        VertexBuffer = 1 << 5,
        IndirectBuffer = 1 << 6
    };

    // Texture usage flags
    enum class TextureUsage : uint32_t
    {
        None = 0,
        TransferSrc = 1 << 0,
        TransferDst = 1 << 1,
        Sampled = 1 << 2,
        Storage = 1 << 3,
        ColorAttachment = 1 << 4,
        DepthStencilAttachment = 1 << 5,
        InputAttachment = 1 << 6
    };

    // Memory properties
    enum class MemoryUsage
    {
        GPUOnly, // Device local (VRAM)
        CPUToGPU, // Upload heap
        GPUToCPU, // Readback heap
        CPUOnly // Staging
    };

    // Shader stages
    enum class ShaderStage : uint32_t
    {
        None = 0,
        Vertex = 1 << 0,
        Fragment = 1 << 1,
        Geometry = 1 << 2,
        Compute = 1 << 3,
        TessControl = 1 << 4,
        TessEval = 1 << 5,
        RenderTarget = 1 << 6,
        Transfer = 1 << 7,
        Host = 1 << 8,
        All = 0x7FFFFFFF
    };

    // Primitive topology
    enum class PrimitiveTopology
    {
        PointList,
        LineList,
        LineStrip,
        TriangleList,
        TriangleStrip,
        TriangleFan
    };

    // Polygon mode
    enum class PolygonMode
    {
        Fill,
        Line,
        Point
    };

    // Cull mode
    enum class CullMode
    {
        None,
        Front,
        Back,
        FrontAndBack
    };

    // Blend factors
    enum class BlendFactor
    {
        Zero,
        One,
        SrcColor,
        OneMinusSrcColor,
        DstColor,
        OneMinusDstColor,
        SrcAlpha,
        OneMinusSrcAlpha,
        DstAlpha,
        OneMinusDstAlpha
    };

    // Blend operations
    enum class BlendOp
    {
        Add,
        Subtract,
        ReverseSubtract,
        Min,
        Max
    };

    // Compare operations
    enum class CompareOp
    {
        Never,
        Less,
        Equal,
        LessOrEqual,
        Greater,
        NotEqual,
        GreaterOrEqual,
        Always
    };

    // Texture filters
    enum class Filter
    {
        Nearest,
        Linear
    };

    // Sampler address modes
    enum class SamplerAddressMode
    {
        Repeat,
        MirroredRepeat,
        ClampToEdge,
        ClampToBorder
    };

    // Load operations
    enum class LoadOp
    {
        Load,
        Clear,
        DontCare
    };

    // Store operations
    enum class StoreOp
    {
        Store,
        DontCare
    };

    // Pipeline bind point
    enum class PipelineBindPoint
    {
        Graphics,
        Compute
    };

    // Descriptor types
    enum class DescriptorType
    {
        Sampler,
        CombinedImageSampler, // Texture + Sampler
        SampledImage,         // Texture without sampler (Separate)
        StorageImage,         // RWTexture / image2D
        UniformBuffer,        // UBO / cbuffer
        StorageBuffer,        // SSBO / StructuredBuffer
        UniformBufferDynamic,
        StorageBufferDynamic,
        InputAttachment       // Subpass input
    };

    enum class VertexSemantic {
        Position,
        Color,
        Normal,
        TexCoord,
        Tangent,
        Bitangent,
        BoneIds,
        Weights,
        Unknown
    };

    struct VertexInputAttribute {
        uint32_t location;
        uint32_t binding;
        Format format;
        uint32_t offset;
        VertexSemantic semantic;
    };

    // Viewport and scissor
    struct Viewport
    {
        float x = 0.0f;
        float y = 0.0f;
        float width = 0.0f;
        float height = 0.0f;
        float minDepth = 0.0f;
        float maxDepth = 1.0f;
    };

    struct Rect2D
    {
        int32_t x = 0;
        int32_t y = 0;
        uint32_t width = 0;
        uint32_t height = 0;
    };

    struct Extent2D
    {
        uint32_t width = 0;
        uint32_t height = 0;
    };

    struct Extent3D
    {
        uint32_t width = 0;
        uint32_t height = 0;
        uint32_t depth = 1;
    };

    // Clear values
    struct ClearColorValue
    {
        union
        {
            float float32[4];
            int32_t int32[4];
            uint32_t uint32[4];
        };
    };

    struct ClearDepthStencilValue
    {
        float depth = 1.0f;
        uint32_t stencil = 0;
    };

    struct ClearValue
    {
        bool isDepthStencil = false;

        union
        {
            ClearColorValue color;
            ClearDepthStencilValue depthStencil;
        };
    };

    // Vertex input
    enum class VertexInputRate
    {
        Vertex,
        Instance
    };

    struct VertexInputBinding
    {
        uint32_t binding;
        uint32_t stride;
        VertexInputRate inputRate;
    };

    // A simple wrapper for an index into the global bindless arrays
    struct BindlessHandle {
        uint32_t index = 0xFFFFFFFF;
        bool isValid() const { return index != 0xFFFFFFFF; }
    };

    // Operator overloads for flags
    inline BufferUsage operator|(BufferUsage a, BufferUsage b)
    {
        return static_cast<BufferUsage>(
            static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
    }

    inline TextureUsage operator|(TextureUsage a, TextureUsage b)
    {
        return static_cast<TextureUsage>(
            static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
    }

    inline ShaderStage operator|(ShaderStage a, ShaderStage b)
    {
        return static_cast<ShaderStage>(
            static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
    }
} // namespace pnkr::renderer::rhi
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_buffer.hpp">
#pragma once

#include "pnkr/rhi/rhi_buffer.hpp"
#include "pnkr/renderer/vulkan/vulkan_buffer.hpp"  // Your existing buffer
#include <vulkan/vulkan.hpp>
#include <vk_mem_alloc.h>

#include "pnkr/rhi/rhi_types.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIBuffer : public RHIBuffer
    {
    public:
        VulkanRHIBuffer(vk::Device device,
                        VmaAllocator allocator,
                        const BufferDescriptor& desc);
        ~VulkanRHIBuffer() override;

        // RHIBuffer interface
        void* map() override;
        void unmap() override;
        void uploadData(const void* data, uint64_t size, uint64_t offset = 0) override;

        uint64_t size() const override { return m_size; }
        BufferUsage usage() const override { return m_usage; }
        MemoryUsage memoryUsage() const override { return m_memoryUsage; }
        void* nativeHandle() const override { return m_buffer; }

        // Vulkan-specific accessors
        vk::Buffer buffer() const { return m_buffer; }
        VmaAllocation allocation() const { return m_allocation; }

    private:
        vk::Device m_device;
        VmaAllocator m_allocator;
        vk::Buffer m_buffer;
        VmaAllocation m_allocation;
        uint64_t m_size;
        BufferUsage m_usage;
        MemoryUsage m_memoryUsage;
        void* m_mappedData = nullptr;
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_command_buffer.hpp">
#pragma once

#include "pnkr/rhi/rhi_command_buffer.hpp"
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIDevice;
    class VulkanRHIPipeline;

    class VulkanRHICommandBuffer : public RHICommandBuffer
    {
    public:
        explicit VulkanRHICommandBuffer(VulkanRHIDevice* device);
        ~VulkanRHICommandBuffer() override;

        // Disable copy
        VulkanRHICommandBuffer(const VulkanRHICommandBuffer&) = delete;
        VulkanRHICommandBuffer& operator=(const VulkanRHICommandBuffer&) = delete;

        // RHICommandBuffer interface
        void begin() override;
        void end() override;
        void reset() override;

        void beginRendering(const RenderingInfo& info) override;
        void endRendering() override;

        void bindPipeline(RHIPipeline* pipeline) override;

        void bindVertexBuffer(uint32_t binding, RHIBuffer* buffer, uint64_t offset = 0) override;
        void bindIndexBuffer(RHIBuffer* buffer, uint64_t offset = 0, bool use16Bit = false) override;

        void draw(uint32_t vertexCount, uint32_t instanceCount = 1,
                 uint32_t firstVertex = 0, uint32_t firstInstance = 0) override;
        void drawIndexed(uint32_t indexCount, uint32_t instanceCount = 1,
                        uint32_t firstIndex = 0, int32_t vertexOffset = 0,
                        uint32_t firstInstance = 0) override;

        void dispatch(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) override;

        void pushConstants(RHIPipeline* pipeline, ShaderStage stages,
                          uint32_t offset, uint32_t size, const void* data) override;

        void bindDescriptorSet(RHIPipeline* pipeline, uint32_t setIndex,
                              RHIDescriptorSet* descriptorSet) override;
        void bindDescriptorSet(RHIPipeline* pipeline, uint32_t setIndex,
                              void* nativeDescriptorSet) override;

        void setViewport(const Viewport& viewport) override;
        void setScissor(const Rect2D& scissor) override;

        void pipelineBarrier(
            ShaderStage srcStage,
            ShaderStage dstStage,
            const std::vector<RHIMemoryBarrier>& barriers) override;

        void copyBuffer(RHIBuffer* src, RHIBuffer* dst,
                       uint64_t srcOffset, uint64_t dstOffset, uint64_t size) override;
        void copyBufferToTexture(RHIBuffer* src, RHITexture* dst,
                                const BufferTextureCopyRegion& region) override;

        void* nativeHandle() const override {
            return static_cast<VkCommandBuffer>(m_commandBuffer);
        }

        // Vulkan-specific accessors
        vk::CommandBuffer commandBuffer() const { return m_commandBuffer; }
        bool isRecording() const { return m_recording; }

    private:
        VulkanRHIDevice* m_device;
        vk::CommandBuffer m_commandBuffer;
        bool m_recording = false;

        // Cached pipeline for descriptor set binding
        VulkanRHIPipeline* m_boundPipeline = nullptr;
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_descriptor.hpp">
#pragma once

#include "pnkr/rhi/rhi_descriptor.hpp"
#include "pnkr/rhi/rhi_pipeline.hpp"
#include <unordered_map>
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIDevice;

    class VulkanRHIDescriptorSetLayout : public RHIDescriptorSetLayout
    {
    public:
        VulkanRHIDescriptorSetLayout(VulkanRHIDevice* device,
                                     vk::DescriptorSetLayout layout,
                                     const DescriptorSetLayout& desc,
                                     bool ownsLayout = true);
        ~VulkanRHIDescriptorSetLayout() override;

        void* nativeHandle() const override
        {
            return static_cast<VkDescriptorSetLayout>(m_layout);
        }

        vk::DescriptorSetLayout layout() const { return m_layout; }
        DescriptorType descriptorType(uint32_t binding) const;
        const DescriptorSetLayout& description() const override;

    private:
        VulkanRHIDevice* m_device = nullptr;
        vk::DescriptorSetLayout m_layout{};
        DescriptorSetLayout m_desc;
        std::unordered_map<uint32_t, DescriptorType> m_bindingTypes;
        bool m_ownsLayout = true;
    };

    class VulkanRHIDescriptorSet : public RHIDescriptorSet
    {
    public:
        VulkanRHIDescriptorSet(VulkanRHIDevice* device,
                               VulkanRHIDescriptorSetLayout* layout,
                               vk::DescriptorSet set);

        void updateBuffer(uint32_t binding,
                          RHIBuffer* buffer,
                          uint64_t offset,
                          uint64_t range) override;
        void updateTexture(uint32_t binding,
                           RHITexture* texture,
                           RHISampler* sampler) override;

        void* nativeHandle() const override
        {
            return static_cast<VkDescriptorSet>(m_set);
        }

    private:
        VulkanRHIDevice* m_device = nullptr;
        VulkanRHIDescriptorSetLayout* m_layout = nullptr;
        vk::DescriptorSet m_set{};
    };
} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_device.hpp">
#pragma once

#include "pnkr/rhi/rhi_device.hpp"
#include "pnkr/rhi/rhi_descriptor.hpp"
#include <vulkan/vulkan.hpp>
#include <vk_mem_alloc.h>
#include <memory>
#include <vector>

namespace pnkr::platform { class Window; }

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIPhysicalDevice : public RHIPhysicalDevice
    {
    public:
        explicit VulkanRHIPhysicalDevice(vk::PhysicalDevice physicalDevice, vk::Instance instance);
        ~VulkanRHIPhysicalDevice() override = default;

        // RHIPhysicalDevice interface
        const DeviceCapabilities& capabilities() const override { return m_capabilities; }
        std::vector<QueueFamilyInfo> queueFamilies() const override { return m_queueFamilies; }
        bool supportsPresentation(uint32_t queueFamily) const override;

        // Vulkan-specific accessors
        vk::PhysicalDevice physicalDevice() const { return m_physicalDevice; }
        vk::Instance instance() const { return m_instance; }

    private:
        vk::PhysicalDevice m_physicalDevice;
        vk::Instance m_instance;
        DeviceCapabilities m_capabilities;
        std::vector<QueueFamilyInfo> m_queueFamilies;

        void queryCapabilities();
        void queryQueueFamilies();
    };

    class VulkanRHIDevice : public RHIDevice
    {
    public:
        VulkanRHIDevice(std::unique_ptr<VulkanRHIPhysicalDevice> physicalDevice,
                        const DeviceDescriptor& desc);
        ~VulkanRHIDevice() override;

        // Disable copy
        VulkanRHIDevice(const VulkanRHIDevice&) = delete;
        VulkanRHIDevice& operator=(const VulkanRHIDevice&) = delete;

        // RHIDevice interface - Resource creation
        std::unique_ptr<RHIBuffer> createBuffer(
            uint64_t size,
            BufferUsage usage,
            MemoryUsage memoryUsage) override;

        std::unique_ptr<RHITexture> createTexture(
            const Extent3D& extent,
            Format format,
            TextureUsage usage,
            uint32_t mipLevels = 1,
            uint32_t arrayLayers = 1) override;
        std::unique_ptr<RHITexture>
        createCubemap(const Extent3D& extent, Format format, TextureUsage usage, uint32_t mipLevels) override;

        std::unique_ptr<RHISampler> createSampler(
            Filter minFilter,
            Filter magFilter,
            SamplerAddressMode addressMode) override;

        std::unique_ptr<RHICommandBuffer> createCommandBuffer() override;

        std::unique_ptr<RHIPipeline> createGraphicsPipeline(
            const GraphicsPipelineDescriptor& desc) override;

        std::unique_ptr<RHIPipeline> createComputePipeline(
            const ComputePipelineDescriptor& desc) override;

        std::unique_ptr<RHIDescriptorSetLayout> createDescriptorSetLayout(
            const DescriptorSetLayout& desc) override;
        std::unique_ptr<RHIDescriptorSet> allocateDescriptorSet(
            RHIDescriptorSetLayout* layout) override;

        // Synchronization
        void waitIdle() override;
        void waitForFences(const std::vector<uint64_t>& fenceValues) override;

        // Queue submission
        void submitCommands(
            RHICommandBuffer* commandBuffer,
            const std::vector<uint64_t>& waitSemaphores = {},
            const std::vector<uint64_t>& signalSemaphores = {}) override;

        // Device queries
        const RHIPhysicalDevice& physicalDevice() const override { return *m_physicalDevice; }
        uint32_t graphicsQueueFamily() const override { return m_graphicsQueueFamily; }
        uint32_t computeQueueFamily() const override { return m_computeQueueFamily; }
        uint32_t transferQueueFamily() const override { return m_transferQueueFamily; }

        // Bindless Registration
        BindlessHandle registerBindlessTexture(RHITexture* texture, RHISampler* sampler) override;
        BindlessHandle registerBindlessCubemap(RHITexture* texture, RHISampler* sampler) override;
        BindlessHandle registerBindlessBuffer(RHIBuffer* buffer) override;
        // To bind the global set to a command buffer
        void* getBindlessDescriptorSetNative() override;
        RHIDescriptorSetLayout* getBindlessDescriptorSetLayout() override;

        // Vulkan-specific accessors
        vk::Device device() const { return m_device; }
        vk::Instance instance() const { return m_physicalDevice->instance(); }
        vk::PhysicalDevice vkPhysicalDevice() const { return m_physicalDevice->physicalDevice(); }
        vk::Queue graphicsQueue() const { return m_graphicsQueue; }
        vk::Queue computeQueue() const { return m_computeQueue; }
        vk::Queue transferQueue() const { return m_transferQueue; }
        VmaAllocator allocator() const { return m_allocator; }
        vk::CommandPool commandPool() const { return m_commandPool; }

        // Utility methods
        vk::ShaderModule createShaderModule(const std::vector<uint32_t>& spirvCode);
        void destroyShaderModule(vk::ShaderModule module);

    private:
        void initBindless(); // Called during device creation

        vk::DescriptorPool m_bindlessPool;
        vk::DescriptorSet m_bindlessSet;
        std::unique_ptr<RHIDescriptorSetLayout> m_bindlessLayout;
    
        uint32_t m_textureIndexCounter = 0;
        uint32_t m_bufferIndexCounter = 0;
        uint32_t m_cubemapIndexCounter = 0;
    
        static constexpr uint32_t MAX_BINDLESS_RESOURCES = 100000;

        std::unique_ptr<VulkanRHIPhysicalDevice> m_physicalDevice;
        vk::Device m_device;
        VmaAllocator m_allocator;

        // Queue families and queues
        uint32_t m_graphicsQueueFamily = VK_QUEUE_FAMILY_IGNORED;
        uint32_t m_computeQueueFamily = VK_QUEUE_FAMILY_IGNORED;
        uint32_t m_transferQueueFamily = VK_QUEUE_FAMILY_IGNORED;
        vk::Queue m_graphicsQueue;
        vk::Queue m_computeQueue;
        vk::Queue m_transferQueue;

        // Command pool
        vk::CommandPool m_commandPool;

        // Validation
        bool m_validationEnabled = false;
        vk::Semaphore m_timelineSemaphore;
        vk::DescriptorPool m_descriptorPool{};

        // Initialization helpers
        void createLogicalDevice(const DeviceDescriptor& desc);
        void selectQueueFamilies();
        void createAllocator();
        void createCommandPool();
        void createTimelineSemaphore();
        void createDescriptorPool();
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_pipeline.hpp">
#pragma once

#include "pnkr/rhi/rhi_pipeline.hpp"
#include <vulkan/vulkan.hpp>
#include <vector>
#include <memory>

#include "vulkan_descriptor.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIDevice;
    class VulkanRHIDescriptorSetLayout;

    class VulkanRHIPipeline : public RHIPipeline
    {
    public:
        // Constructor for graphics pipeline
        VulkanRHIPipeline(VulkanRHIDevice* device,
                         const GraphicsPipelineDescriptor& desc);

        // Constructor for compute pipeline
        VulkanRHIPipeline(VulkanRHIDevice* device,
                         const ComputePipelineDescriptor& desc);

        ~VulkanRHIPipeline() override;

        // Disable copy
        VulkanRHIPipeline(const VulkanRHIPipeline&) = delete;
        VulkanRHIPipeline& operator=(const VulkanRHIPipeline&) = delete;

        // RHIPipeline interface
        PipelineBindPoint bindPoint() const override { return m_bindPoint; }
        void* nativeHandle() const override {
            return static_cast<VkPipeline>(m_pipeline);
        }

        // Vulkan-specific accessors
        vk::Pipeline pipeline() const { return m_pipeline; }
        vk::PipelineLayout pipelineLayout() const { return m_pipelineLayout; }
        RHIDescriptorSetLayout* descriptorSetLayout(uint32_t setIndex) const override;
        uint32_t descriptorSetLayoutCount() const override;

    private:
        VulkanRHIDevice* m_device;
        vk::Pipeline m_pipeline;
        vk::PipelineLayout m_pipelineLayout;
        std::vector<std::unique_ptr<VulkanRHIDescriptorSetLayout>> m_descriptorSetLayouts;
        std::vector<vk::ShaderModule> m_shaderModules;
        PipelineBindPoint m_bindPoint;

        // Pipeline creation helpers
        void createGraphicsPipeline(const GraphicsPipelineDescriptor& desc);
        void createComputePipeline(const ComputePipelineDescriptor& desc);

        // Layout creation
        void createDescriptorSetLayouts(const std::vector<DescriptorSetLayout>& layouts);
        void createPipelineLayout(const std::vector<PushConstantRange>& pushConstants);

        // Shader module management
        vk::ShaderModule createShaderModule(const ShaderModuleDescriptor& desc);
        void cleanupShaderModules();
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_sampler.hpp">
#pragma once

#include "pnkr/rhi/rhi_sampler.hpp"
#include <vulkan/vulkan.hpp>

#include "pnkr/rhi/rhi_device.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIDevice;

    class VulkanRHISampler : public RHISampler
    {
    public:
        VulkanRHISampler(VulkanRHIDevice* device,
                        Filter minFilter,
                        Filter magFilter,
                        SamplerAddressMode addressMode);
        ~VulkanRHISampler() override;

        // Disable copy
        VulkanRHISampler(const VulkanRHISampler&) = delete;
        VulkanRHISampler& operator=(const VulkanRHISampler&) = delete;

        // RHISampler interface
        void* nativeHandle() const override {
            return static_cast<VkSampler>(m_sampler);
        }

        // Vulkan-specific
        vk::Sampler sampler() const { return m_sampler; }

    private:
        VulkanRHIDevice* m_device;
        vk::Sampler m_sampler;
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_swapchain.hpp">
#pragma once

#include "pnkr/rhi/rhi_swapchain.hpp"
#include "pnkr/rhi/rhi_texture.hpp"
#include <vulkan/vulkan.hpp>

#include <memory>
#include <vector>

namespace pnkr::platform { class Window; }

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIDevice;

    // Non-owning RHITexture wrapper for a swapchain image.
    class VulkanRHISwapchainImage final : public RHITexture
    {
    public:
        VulkanRHISwapchainImage(vk::Image image, vk::ImageView view, const Extent3D& extent, Format fmt)
            : m_image(image), m_view(view), m_extent(extent), m_format(fmt) {}

        void uploadData(const void*, uint64_t, const TextureSubresource& = {}) override {}
        void generateMipmaps() override {}

        const Extent3D& extent() const override { return m_extent; }
        Format format() const override { return m_format; }
        uint32_t mipLevels() const override { return 1; }
        uint32_t arrayLayers() const override { return 1; }
        TextureUsage usage() const override { return TextureUsage::ColorAttachment | TextureUsage::TransferDst; }

        void* nativeHandle() const override { return static_cast<VkImage>(m_image); }
        void* nativeView() const override { return static_cast<VkImageView>(m_view); }

        vk::Image image() const { return m_image; }
        vk::ImageView imageView() const { return m_view; }

    private:
        vk::Image m_image{};
        vk::ImageView m_view{};
        Extent3D m_extent{};
        Format m_format{Format::Undefined};
    };

    class VulkanRHISwapchain final : public RHISwapchain
    {
    public:
        VulkanRHISwapchain(VulkanRHIDevice* device, platform::Window& window, Format preferredFormat);
        ~VulkanRHISwapchain() override;

        Format colorFormat() const override { return m_rhiFormat; }
        Extent2D extent() const override { return { m_extent.width, m_extent.height }; }
        uint32_t imageCount() const override { return static_cast<uint32_t>(m_images.size()); }
        uint32_t framesInFlight() const override { return m_framesInFlight; }

        bool beginFrame(uint32_t frameIndex, RHICommandBuffer* cmd, SwapchainFrame& out) override;
        bool endFrame(uint32_t frameIndex, RHICommandBuffer* cmd) override;

        void recreate(uint32_t width, uint32_t height) override;

    private:
        VulkanRHIDevice* m_device{};
        platform::Window* m_window{};

        vk::SurfaceKHR m_surface{};
        vk::SwapchainKHR m_swapchain{};

        vk::Format m_vkFormat{vk::Format::eUndefined};
        Format m_rhiFormat{Format::Undefined};
        vk::Extent2D m_extent{};

        std::vector<vk::Image> m_images;
        std::vector<vk::ImageView> m_views;
        std::vector<std::unique_ptr<VulkanRHISwapchainImage>> m_wrapped;
        std::vector<ResourceLayout> m_layouts;

        uint32_t m_currentImage = 0;

        // Sync: binary semaphores for acquire/present, fences to throttle CPU
        uint32_t m_framesInFlight = 2;
        std::vector<vk::Fence> m_inFlightFences;
        std::vector<vk::Semaphore> m_imageAvailable;
        // IMPORTANT: render-finished semaphores must be per swapchain image (not per frame), to avoid WSI semaphore reuse hazards.
        std::vector<vk::Semaphore> m_renderFinished; // indexed by acquired imageIndex
        std::vector<vk::Fence> m_imagesInFlight; // per swapchain image

        void createSurface();
        void createSwapchain(Format preferredFormat, uint32_t width, uint32_t height);
        void destroySwapchain();

        void createSyncObjects();
        void destroySyncObjects();

        vk::SurfaceFormatKHR chooseSurfaceFormat(const std::vector<vk::SurfaceFormatKHR>& formats, Format preferred) const;
        vk::PresentModeKHR choosePresentMode(const std::vector<vk::PresentModeKHR>& modes) const;
        vk::Extent2D chooseExtent(const vk::SurfaceCapabilitiesKHR& caps, uint32_t width, uint32_t height) const;
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_texture.hpp">
#pragma once

#include "pnkr/rhi/rhi_texture.hpp"
#include <vulkan/vulkan.hpp>
#include <vk_mem_alloc.h>

#include "pnkr/rhi/rhi_texture.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanRHIDevice;

    class VulkanRHITexture : public RHITexture
    {
    public:
        VulkanRHITexture(VulkanRHIDevice* device, const TextureDescriptor& desc);
        ~VulkanRHITexture() override;

        // Disable copy
        VulkanRHITexture(const VulkanRHITexture&) = delete;
        VulkanRHITexture& operator=(const VulkanRHITexture&) = delete;

        // RHITexture interface
        void uploadData(
            const void* data,
            uint64_t dataSize,
            const TextureSubresource& subresource = {}) override;

        void generateMipmaps() override;

        const Extent3D& extent() const override { return m_extent; }
        Format format() const override { return m_format; }
        uint32_t mipLevels() const override { return m_mipLevels; }
        uint32_t arrayLayers() const override { return m_arrayLayers; }
        TextureUsage usage() const override { return m_usage; }

        void* nativeHandle() const override {
            return static_cast<VkImage>(m_image);
        }
        void* nativeView() const override {
            return static_cast<VkImageView>(m_imageView);
        }

        // Vulkan-specific accessors
        vk::Image image() const { return m_image; }
        vk::ImageView imageView() const { return m_imageView; }
        VmaAllocation allocation() const { return m_allocation; }
        vk::ImageLayout currentLayout() const { return m_currentLayout; }

        // Layout transition (internal use)
        void transitionLayout(vk::ImageLayout newLayout, vk::CommandBuffer cmd);

    private:
        VulkanRHIDevice* m_device;
        vk::Image m_image;
        vk::ImageView m_imageView;
        VmaAllocation m_allocation;

        Extent3D m_extent;
        Format m_format;
        TextureUsage m_usage;
        uint32_t m_mipLevels = 1;
        uint32_t m_arrayLayers = 1;

        vk::ImageLayout m_currentLayout = vk::ImageLayout::eUndefined;

        void createImage(const TextureDescriptor& desc);
        void createImageView(const TextureDescriptor& desc);

        // Helper for staging buffer upload
        void uploadDataInternal(const void* data, uint64_t dataSize,
                               const TextureSubresource& subresource);
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/rhi/vulkan/vulkan_utils.hpp">
#pragma once

#include "pnkr/rhi/rhi_types.hpp"
#include <vulkan/vulkan.hpp>

namespace pnkr::renderer::rhi::vulkan
{
    class VulkanUtils
    {
    public:
        // Format conversions
        static vk::Format toVkFormat(Format format);
        static Format fromVkFormat(vk::Format format);

        // Buffer usage conversions
        static vk::BufferUsageFlags toVkBufferUsage(BufferUsage usage);
        static BufferUsage fromVkBufferUsage(vk::BufferUsageFlags flags);

        // Texture usage conversions
        static vk::ImageUsageFlags toVkImageUsage(TextureUsage usage);
        static TextureUsage fromVkImageUsage(vk::ImageUsageFlags flags);

        // Memory usage to VMA flags
        static VmaMemoryUsage toVmaMemoryUsage(MemoryUsage usage);

        // Shader stage conversions
        static vk::ShaderStageFlags toVkShaderStage(ShaderStage stage);
        static ShaderStage fromVkShaderStage(vk::ShaderStageFlags flags);
        static vk::PipelineStageFlags2 toVkPipelineStage(ShaderStage stage);

        static vk::ImageLayout toVkImageLayout(ResourceLayout layout);

        // Topology conversions
        static vk::PrimitiveTopology toVkTopology(PrimitiveTopology topology);
        static PrimitiveTopology fromVkTopology(vk::PrimitiveTopology topology);

        // Polygon mode conversions
        static vk::PolygonMode toVkPolygonMode(PolygonMode mode);
        static PolygonMode fromVkPolygonMode(vk::PolygonMode mode);

        // Cull mode conversions
        static vk::CullModeFlags toVkCullMode(CullMode mode);
        static CullMode fromVkCullMode(vk::CullModeFlags flags);

        // Compare op conversions
        static vk::CompareOp toVkCompareOp(CompareOp op);
        static CompareOp fromVkCompareOp(vk::CompareOp op);

        // Blend factor conversions
        static vk::BlendFactor toVkBlendFactor(BlendFactor factor);
        static BlendFactor fromVkBlendFactor(vk::BlendFactor factor);

        // Blend op conversions
        static vk::BlendOp toVkBlendOp(BlendOp op);
        static BlendOp fromVkBlendOp(vk::BlendOp op);

        // Filter conversions
        static vk::Filter toVkFilter(Filter filter);
        static Filter fromVkFilter(vk::Filter filter);

        // Sampler address mode conversions
        static vk::SamplerAddressMode toVkAddressMode(SamplerAddressMode mode);
        static SamplerAddressMode fromVkAddressMode(vk::SamplerAddressMode mode);

        // Load/store op conversions
        static vk::AttachmentLoadOp toVkLoadOp(LoadOp op);
        static vk::AttachmentStoreOp toVkStoreOp(StoreOp op);

        // Descriptor type conversions
        static vk::DescriptorType toVkDescriptorType(DescriptorType type);
        static DescriptorType fromVkDescriptorType(vk::DescriptorType type);

        // Viewport/rect conversions
        static vk::Viewport toVkViewport(const Viewport& viewport);
        static vk::Rect2D toVkRect2D(const Rect2D& rect);
        static vk::Extent2D toVkExtent2D(const Extent2D& extent);
        static vk::Extent3D toVkExtent3D(const Extent3D& extent);

        // Clear value conversions
        static vk::ClearValue toVkClearValue(const ClearValue& clearValue);
    };

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="include/pnkr/ui/imgui_layer.hpp">
#pragma once
#include <vulkan/vulkan.hpp>
#include <SDL3/SDL_events.h>

#include "pnkr/renderer/renderer.hpp"

namespace pnkr::ui
{
    class ImGuiLayer
    {
    public:
        void init(pnkr::renderer::Renderer& renderer, pnkr::platform::Window* window);
        void shutdown();

        // Pass SDL events here
        void handleEvent(const SDL_Event& event);

        // Start a new ImGui frame
        void beginFrame();

        void endFrame();

    private:
        vk::DescriptorPool m_descriptorPool;
        pnkr::renderer::Renderer* m_renderer = nullptr;
    };
}
</file>

<file path="src/core/implementations.cpp">
// Centralized single-header implementations to avoid ODR bloat.



#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image.h>
#include <stb_image_write.h>
</file>

<file path="src/core/logger.cpp">
#include "pnkr/core/logger.hpp"

namespace pnkr::core {

std::shared_ptr<spdlog::logger> Logger::sLogger;

void Logger::init(const std::string &pattern) {
  if (sLogger) {
    return; // Already initialized
  }

  auto consoleSink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
  const auto logger = std::make_shared<spdlog::logger>("pnkr", consoleSink);

  logger->set_pattern(pattern);

#ifdef DEBUG
  logger->set_level(spdlog::level::debug);
#else
  logger->set_level(spdlog::level::info);
#endif

  spdlog::register_logger(logger);
  sLogger = logger;

  info("Logger initialized");
}

} // namespace pnkr::core
</file>

<file path="src/platform/window.cpp">
#include "pnkr/platform/window.hpp"
#include "pnkr/core/logger.hpp"
#include <stdexcept>

namespace pnkr::platform
{
    Window::Window(const std::string& title, int width, int height,
                   SDL_WindowFlags flags)
    {
        if (!SDL_Init(SDL_INIT_VIDEO))
        {
            throw std::runtime_error(std::string("SDL_Init failed: ") + SDL_GetError());
        }

        SDL_Window* rawWindow =
            SDL_CreateWindow(title.c_str(), width, height,
                             flags | SDL_WINDOW_VULKAN // Enable Vulkan support
            );

        if (rawWindow == nullptr)
        {
            SDL_Quit();
            throw std::runtime_error(std::string("SDL_CreateWindow failed: ") +
                SDL_GetError());
        }

        m_window.reset(rawWindow);

        pnkr::core::Logger::info("Window created: {}x{}", width, height);
    }

    Window::~Window() { SDL_Quit(); }

    void Window::processEvents(Input* input, const EventCallback& callback) noexcept
    {
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            // 1. Pass to optional generic callback (e.g., ImGui)
            if (callback) {
                callback(event);
            }

            // 2. Pass to Input system
            if (input)
            {
                input->processEvent(event);
            }

            // 3. Handle Window lifecycle
            switch (event.type)
            {
            case SDL_EVENT_WINDOW_CLOSE_REQUESTED:
                m_running = false;
                break;

            case SDL_EVENT_WINDOW_RESIZED:
                pnkr::core::Logger::debug("Window resized to {}x{}", event.window.data1,
                                          event.window.data2);
                break;

            case SDL_EVENT_WINDOW_MINIMIZED:
                pnkr::core::Logger::debug("Window minimized");
                break;

            case SDL_EVENT_WINDOW_RESTORED:
                pnkr::core::Logger::debug("Window restored");
                break;

            default:
                break;
            }
        }
    }

    void Window::setTitle(const std::string& title) const
    {
        SDL_SetWindowTitle(m_window.get(), title.c_str());
    }

    int Window::width() const noexcept
    {
        int width = 0;
        SDL_GetWindowSize(m_window.get(), &width, nullptr);
        return width;
    }

    int Window::height() const noexcept
    {
        int height = 0;
        SDL_GetWindowSize(m_window.get(), nullptr, &height);
        return height;
    }
} // namespace pnkr::platform
</file>

<file path="src/renderer/debug/DebugLayer.cpp">
#include "pnkr/renderer/debug/DebugLayer.hpp"
#include "pnkr/rhi/rhi_device.hpp"
#include "pnkr/rhi/rhi_buffer.hpp"
#include "pnkr/rhi/rhi_pipeline.hpp"
#include "pnkr/renderer/geometry/Vertex.h"
#include <filesystem>
#include <fstream>
#include <cstring>

namespace pnkr::renderer::debug
{
    DebugLayer::DebugLayer() = default;
    DebugLayer::~DebugLayer() = default;

    void DebugLayer::initialize(pnkr::renderer::RHIRenderer* renderer)
    {
        if (m_initialized || !renderer)
        {
            return;
        }

        m_renderer = renderer;

        // Reserve vertex storage
        m_vertices.reserve(m_maxVertices);

        createPipeline();
        createVertexBuffer();

        m_initialized = true;
    }

    // Scene integration methods removed for simplicity - DebugLayer can work standalone or with scenes

    void DebugLayer::clear()
    {
        m_vertices.clear();
    }

    void DebugLayer::line(const glm::vec3& start, const glm::vec3& end, const glm::vec3& color)
    {
        if (m_vertices.size() + 2 >= m_maxVertices)
        {
            return;
        }

        m_vertices.push_back({start, color});
        m_vertices.push_back({end, color});
    }

    void DebugLayer::box(const glm::vec3& min, const glm::vec3& max, const glm::vec3& color)
    {
        glm::vec3 corners[8] = {
            glm::vec3(min.x, min.y, min.z),
            glm::vec3(max.x, min.y, min.z),
            glm::vec3(max.x, max.y, min.z),
            glm::vec3(min.x, max.y, min.z),
            glm::vec3(min.x, min.y, max.z),
            glm::vec3(max.x, min.y, max.z),
            glm::vec3(max.x, max.y, max.z),
            glm::vec3(min.x, max.y, max.z)
        };

        // Bottom edges
        line(corners[0], corners[1], color);
        line(corners[1], corners[2], color);
        line(corners[2], corners[3], color);
        line(corners[3], corners[0], color);

        // Top edges
        line(corners[4], corners[5], color);
        line(corners[5], corners[6], color);
        line(corners[6], corners[7], color);
        line(corners[7], corners[4], color);

        // Vertical edges
        line(corners[0], corners[4], color);
        line(corners[1], corners[5], color);
        line(corners[2], corners[6], color);
        line(corners[3], corners[7], color);
    }

    void DebugLayer::box(const glm::mat4& transform, const glm::vec3& size, const glm::vec3& color)
    {
        glm::vec3 halfSize = size * 0.5f;
        glm::vec3 min = -halfSize;
        glm::vec3 max = halfSize;

        glm::vec3 corners[8] = {
            glm::vec3(transform * glm::vec4(min.x, min.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, min.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, max.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(min.x, max.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(min.x, min.y, max.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, min.y, max.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, max.y, max.z, 1.0f)),
            glm::vec3(transform * glm::vec4(min.x, max.y, max.z, 1.0f))
        };

        // Bottom edges
        line(corners[0], corners[1], color);
        line(corners[1], corners[2], color);
        line(corners[2], corners[3], color);
        line(corners[3], corners[0], color);

        // Top edges
        line(corners[4], corners[5], color);
        line(corners[5], corners[6], color);
        line(corners[6], corners[7], color);
        line(corners[7], corners[4], color);

        // Vertical edges
        line(corners[0], corners[4], color);
        line(corners[1], corners[5], color);
        line(corners[2], corners[6], color);
        line(corners[3], corners[7], color);
    }

    void DebugLayer::plane(const glm::vec3& origin, const glm::vec3& v1, const glm::vec3& v2,
                           int segments1, int segments2, const glm::vec3& color)
    {
        if (segments1 <= 0 || segments2 <= 0)
        {
            return;
        }

        glm::vec3 step1 = v1 / static_cast<float>(segments1);
        glm::vec3 step2 = v2 / static_cast<float>(segments2);

        // Draw grid lines parallel to v1
        for (int i = 0; i <= segments1; ++i)
        {
            glm::vec3 start = origin + static_cast<float>(i) * step1 - v2 * 0.5f;
            glm::vec3 end = origin + static_cast<float>(i) * step1 + v2 * 0.5f;
            line(start, end, color);
        }

        // Draw grid lines parallel to v2
        for (int j = 0; j <= segments2; ++j)
        {
            glm::vec3 start = origin - v1 * 0.5f + static_cast<float>(j) * step2;
            glm::vec3 end = origin + v1 * 0.5f + static_cast<float>(j) * step2;
            line(start, end, color);
        }
    }

    void DebugLayer::frustum(const glm::mat4& viewProj, const glm::vec3& color)
    {
        // Define frustum corners in NDC space
        glm::vec3 corners[8] = {
            glm::vec3(-1, -1, -1),
            glm::vec3( 1, -1, -1),
            glm::vec3( 1,  1, -1),
            glm::vec3(-1,  1, -1),
            glm::vec3(-1, -1,  1),
            glm::vec3( 1, -1,  1),
            glm::vec3( 1,  1,  1),
            glm::vec3(-1,  1,  1)
        };

        glm::mat4 invViewProj = glm::inverse(viewProj);

        // Transform corners to world space
        for (int i = 0; i < 8; ++i)
        {
            glm::vec4 corner = invViewProj * glm::vec4(corners[i], 1.0f);
            corners[i] = glm::vec3(corner.x / corner.w, corner.y / corner.w, corner.z / corner.w);
        }

        // Near plane
        line(corners[0], corners[1], color);
        line(corners[1], corners[2], color);
        line(corners[2], corners[3], color);
        line(corners[3], corners[0], color);

        // Far plane
        line(corners[4], corners[5], color);
        line(corners[5], corners[6], color);
        line(corners[6], corners[7], color);
        line(corners[7], corners[4], color);

        // Connecting edges
        line(corners[0], corners[4], color);
        line(corners[1], corners[5], color);
        line(corners[2], corners[6], color);
        line(corners[3], corners[7], color);
    }

    void DebugLayer::circle(const glm::vec3& center, float radius, const glm::vec3& color, int segments)
    {
        if (segments < 3)
        {
            segments = 3;
        }

        float angleStep = 2.0f * glm::pi<float>() / static_cast<float>(segments);

        glm::vec3 prevPoint = center + glm::vec3(radius, 0, 0);

        for (int i = 1; i <= segments; ++i)
        {
            float angle = static_cast<float>(i) * angleStep;
            glm::vec3 currPoint = center + glm::vec3(glm::cos(angle) * radius, glm::sin(angle) * radius, 0);
            line(prevPoint, currPoint, color);
            prevPoint = currPoint;
        }
    }

    void DebugLayer::sphere(const glm::vec3& center, float radius, const glm::vec3& color, int segments)
    {
        if (segments < 3)
        {
            segments = 3;
        }

        // Draw latitude circles
        for (int lat = 0; lat <= segments; ++lat)
        {
            float theta = glm::pi<float>() * static_cast<float>(lat) / static_cast<float>(segments);
            float sinTheta = glm::sin(theta);
            float cosTheta = glm::cos(theta);

            glm::vec3 prevPoint = center + glm::vec3(radius * sinTheta, radius * cosTheta, 0);

            for (int lon = 1; lon <= segments; ++lon)
            {
                float phi = 2.0f * glm::pi<float>() * static_cast<float>(lon) / static_cast<float>(segments);
                float sinPhi = glm::sin(phi);
                float cosPhi = glm::cos(phi);

                glm::vec3 currPoint = center + glm::vec3(
                    radius * sinTheta * cosPhi,
                    radius * cosTheta,
                    radius * sinTheta * sinPhi
                );

                line(prevPoint, currPoint, color);
                prevPoint = currPoint;
            }
        }

        // Draw longitude circles
        for (int lon = 0; lon < segments; ++lon)
        {
            float phi = 2.0f * glm::pi<float>() * static_cast<float>(lon) / static_cast<float>(segments);
            float sinPhi = glm::sin(phi);
            float cosPhi = glm::cos(phi);

            glm::vec3 prevPoint = center + glm::vec3(0, radius, 0);

            for (int lat = 1; lat <= segments; ++lat)
            {
                float theta = glm::pi<float>() * static_cast<float>(lat) / static_cast<float>(segments);
                float sinTheta = glm::sin(theta);
                float cosTheta = glm::cos(theta);

                glm::vec3 currPoint = center + glm::vec3(
                    radius * sinTheta * cosPhi,
                    radius * cosTheta,
                    radius * sinTheta * sinPhi
                );

                line(prevPoint, currPoint, color);
                prevPoint = currPoint;
            }
        }
    }

    void DebugLayer::render(const pnkr::renderer::RHIFrameContext& ctx, const glm::mat4& viewProj)
    {
        if (!m_initialized || m_vertices.empty())
        {
            return;
        }

        // Update current frame offset
        m_currentFrameIndex = ctx.frameIndex % kMaxFrames;

        // Calculate offset for this frame
        uint32_t frameOffset = m_currentFrameIndex * m_maxVertices;

        // Check if we need to resize the buffer
        uint32_t requiredSize = (frameOffset + m_vertices.size()) * sizeof(LineVertex);
        if (m_vertexBuffer && requiredSize > m_vertexBuffer->size())
        {
            createVertexBuffer();
        }

        // Upload vertex data
        uploadVertexData();

        // Bind pipeline and set state
        m_renderer->bindPipeline(ctx.commandBuffer, m_pipeline);

        // Bind vertex buffer
        ctx.commandBuffer->bindVertexBuffer(0, m_vertexBuffer.get(), frameOffset * sizeof(LineVertex));

        // Set push constants (MVP matrix)
        PushConstants pc;
        pc.mvp = viewProj;
        m_renderer->pushConstants(ctx.commandBuffer, m_pipeline,
            rhi::ShaderStage::Vertex, pc);

        // Draw lines
        ctx.commandBuffer->draw(m_vertices.size(), 1, 0, 0);
    }

    void DebugLayer::createPipeline()
    {
        // Define vertex input
        std::vector<rhi::VertexInputBinding> bindings = {
            {0, sizeof(LineVertex), rhi::VertexInputRate::Vertex}
        };

        std::vector<rhi::VertexInputAttribute> attributes = {
            {0, 0, rhi::Format::R32G32B32_SFLOAT, offsetof(LineVertex, position), rhi::VertexSemantic::Position},
            {1, 0, rhi::Format::R32G32B32_SFLOAT, offsetof(LineVertex, color), rhi::VertexSemantic::Color}
        };

        // Define push constants
        std::vector<rhi::PushConstantRange> pushConstants = {
            {rhi::ShaderStage::Vertex, 0, sizeof(PushConstants)}
        };

        // Load SPIR-V shaders
        auto loadSpirvShader = [](const std::filesystem::path& shaderPath, rhi::ShaderStage stage) {
            std::ifstream file(shaderPath, std::ios::binary);
            if (!file.is_open())
            {
                throw std::runtime_error("Failed to open SPIR-V shader file: " + shaderPath.string());
            }

            // Read file into vector of bytes
            std::vector<uint32_t> spirv;
            file.seekg(0, std::ios::end);
            size_t fileSize = file.tellg();
            file.seekg(0, std::ios::beg);

            spirv.resize(fileSize / sizeof(uint32_t));
            file.read(reinterpret_cast<char*>(spirv.data()), fileSize);

            return rhi::ShaderModuleDescriptor{stage, spirv, "main"};
        };

        // Try to load compiled SPIR-V shaders from current directory first
        std::filesystem::path shaderDir = std::filesystem::current_path() / "shaders";
        if (!std::filesystem::exists(shaderDir)) {
            // Fallback to engine source directory
            shaderDir = std::filesystem::path(__FILE__).parent_path() / "shaders";
        }

        auto vertShader = loadSpirvShader(shaderDir / "line_canvas.vert.spv", rhi::ShaderStage::Vertex);
        auto fragShader = loadSpirvShader(shaderDir / "line_canvas.frag.spv", rhi::ShaderStage::Fragment);

        // Create graphics pipeline descriptor
        rhi::GraphicsPipelineDescriptor desc{};
        desc.shaders = {vertShader, fragShader};
        desc.vertexBindings = bindings;
        desc.vertexAttributes = attributes;
        desc.topology = rhi::PrimitiveTopology::LineList;

        // Rasterization state
        desc.rasterization.polygonMode = rhi::PolygonMode::Fill;
        desc.rasterization.cullMode = rhi::CullMode::None;
        desc.rasterization.lineWidth = 1.0f;

        // Depth stencil state
        desc.depthStencil.depthTestEnable = true;
        desc.depthStencil.depthWriteEnable = true;
        desc.depthStencil.depthCompareOp = rhi::CompareOp::LessOrEqual;

        // Color blend state
        desc.blend.attachments = {{.blendEnable = false}};

        // Render target formats
        desc.colorFormats = {m_renderer->getDrawColorFormat()};
        desc.depthFormat = m_renderer->getDrawDepthFormat();

        desc.pushConstants = pushConstants;
        desc.debugName = "DebugLayer Pipeline";

        // Create pipeline through RHIRenderer
        m_pipeline = m_renderer->createGraphicsPipeline(desc);
    }

    void DebugLayer::createVertexBuffer()
    {
        // Create buffer through device
        m_vertexBuffer = m_renderer->device()->createBuffer(
            m_maxVertices * kMaxFrames * sizeof(LineVertex),
            rhi::BufferUsage::VertexBuffer,
            rhi::MemoryUsage::CPUToGPU);
    }

    // createDebugMesh method removed - not needed for the simplified approach

    void DebugLayer::uploadVertexData()
    {
        if (m_vertices.empty())
        {
            return;
        }

        uint32_t frameOffset = m_currentFrameIndex * m_maxVertices;
        uint32_t uploadSize = m_vertices.size() * sizeof(LineVertex);

        // Use the convenient uploadData method
        m_vertexBuffer->uploadData(m_vertices.data(), uploadSize, frameOffset * sizeof(LineVertex));
    }
} // namespace pnkr::renderer::debug
</file>

<file path="src/renderer/debug/LineCanvas3D.cpp">
#include "pnkr/renderer/debug/LineCanvas3D.hpp"
#include "pnkr/rhi/rhi_device.hpp"
#include "pnkr/rhi/rhi_buffer.hpp"
#include "pnkr/rhi/rhi_pipeline.hpp"
#include <filesystem>
#include <fstream>
#include <cstring>

namespace pnkr::renderer::debug
{
    LineCanvas3D::LineCanvas3D() = default;
    LineCanvas3D::~LineCanvas3D() = default;

    void LineCanvas3D::initialize(pnkr::renderer::RHIRenderer* renderer)
    {
        if (m_initialized || !renderer)
        {
            return;
        }

        m_renderer = renderer;

        // Reserve vertex storage
        m_vertices.reserve(m_maxVertices);

        createPipeline();
        createVertexBuffer();

        m_initialized = true;
    }

    void LineCanvas3D::beginFrame()
    {
        if (!m_initialized)
        {
            return;
        }

        m_frameActive = true;
        m_vertices.clear();
    }

    void LineCanvas3D::endFrame()
    {
        if (!m_initialized || !m_frameActive)
        {
            return;
        }

        m_frameActive = false;
    }

    void LineCanvas3D::line(const glm::vec3& start, const glm::vec3& end, const glm::vec3& color)
    {
        if (!m_frameActive || m_vertices.size() + 2 >= m_maxVertices)
        {
            return;
        }

        m_vertices.push_back({start, color});
        m_vertices.push_back({end, color});
    }

    void LineCanvas3D::box(const glm::vec3& min, const glm::vec3& max, const glm::vec3& color)
    {
        glm::vec3 corners[8] = {
            glm::vec3(min.x, min.y, min.z),
            glm::vec3(max.x, min.y, min.z),
            glm::vec3(max.x, max.y, min.z),
            glm::vec3(min.x, max.y, min.z),
            glm::vec3(min.x, min.y, max.z),
            glm::vec3(max.x, min.y, max.z),
            glm::vec3(max.x, max.y, max.z),
            glm::vec3(min.x, max.y, max.z)
        };

        // Bottom edges
        line(corners[0], corners[1], color);
        line(corners[1], corners[2], color);
        line(corners[2], corners[3], color);
        line(corners[3], corners[0], color);

        // Top edges
        line(corners[4], corners[5], color);
        line(corners[5], corners[6], color);
        line(corners[6], corners[7], color);
        line(corners[7], corners[4], color);

        // Vertical edges
        line(corners[0], corners[4], color);
        line(corners[1], corners[5], color);
        line(corners[2], corners[6], color);
        line(corners[3], corners[7], color);
    }

    void LineCanvas3D::box(const glm::mat4& transform, const glm::vec3& size, const glm::vec3& color)
    {
        glm::vec3 halfSize = size * 0.5f;
        glm::vec3 min = -halfSize;
        glm::vec3 max = halfSize;

        glm::vec3 corners[8] = {
            glm::vec3(transform * glm::vec4(min.x, min.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, min.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, max.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(min.x, max.y, min.z, 1.0f)),
            glm::vec3(transform * glm::vec4(min.x, min.y, max.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, min.y, max.z, 1.0f)),
            glm::vec3(transform * glm::vec4(max.x, max.y, max.z, 1.0f)),
            glm::vec3(transform * glm::vec4(min.x, max.y, max.z, 1.0f))
        };

        // Bottom edges
        line(corners[0], corners[1], color);
        line(corners[1], corners[2], color);
        line(corners[2], corners[3], color);
        line(corners[3], corners[0], color);

        // Top edges
        line(corners[4], corners[5], color);
        line(corners[5], corners[6], color);
        line(corners[6], corners[7], color);
        line(corners[7], corners[4], color);

        // Vertical edges
        line(corners[0], corners[4], color);
        line(corners[1], corners[5], color);
        line(corners[2], corners[6], color);
        line(corners[3], corners[7], color);
    }

    void LineCanvas3D::plane(const glm::vec3& origin, const glm::vec3& v1, const glm::vec3& v2,
                            int segments1, int segments2, const glm::vec3& color)
    {
        if (segments1 <= 0 || segments2 <= 0)
        {
            return;
        }

        glm::vec3 step1 = v1 / static_cast<float>(segments1);
        glm::vec3 step2 = v2 / static_cast<float>(segments2);

        // Draw grid lines parallel to v1
        for (int i = 0; i <= segments1; ++i)
        {
            glm::vec3 start = origin + static_cast<float>(i) * step1 - v2 * 0.5f;
            glm::vec3 end = origin + static_cast<float>(i) * step1 + v2 * 0.5f;
            line(start, end, color);
        }

        // Draw grid lines parallel to v2
        for (int j = 0; j <= segments2; ++j)
        {
            glm::vec3 start = origin - v1 * 0.5f + static_cast<float>(j) * step2;
            glm::vec3 end = origin + v1 * 0.5f + static_cast<float>(j) * step2;
            line(start, end, color);
        }
    }

    void LineCanvas3D::frustum(const glm::mat4& viewProj, const glm::vec3& color)
    {
        // Define frustum corners in NDC space
        glm::vec3 corners[8] = {
            glm::vec3(-1, -1, -1),
            glm::vec3( 1, -1, -1),
            glm::vec3( 1,  1, -1),
            glm::vec3(-1,  1, -1),
            glm::vec3(-1, -1,  1),
            glm::vec3( 1, -1,  1),
            glm::vec3( 1,  1,  1),
            glm::vec3(-1,  1,  1)
        };

        glm::mat4 invViewProj = glm::inverse(viewProj);

        // Transform corners to world space
        for (int i = 0; i < 8; ++i)
        {
            glm::vec4 corner = invViewProj * glm::vec4(corners[i], 1.0f);
            corners[i] = glm::vec3(corner.x / corner.w, corner.y / corner.w, corner.z / corner.w);
        }

        // Near plane
        line(corners[0], corners[1], color);
        line(corners[1], corners[2], color);
        line(corners[2], corners[3], color);
        line(corners[3], corners[0], color);

        // Far plane
        line(corners[4], corners[5], color);
        line(corners[5], corners[6], color);
        line(corners[6], corners[7], color);
        line(corners[7], corners[4], color);

        // Connecting edges
        line(corners[0], corners[4], color);
        line(corners[1], corners[5], color);
        line(corners[2], corners[6], color);
        line(corners[3], corners[7], color);
    }

    void LineCanvas3D::circle(const glm::vec3& center, float radius, const glm::vec3& color, int segments)
    {
        if (segments < 3)
        {
            segments = 3;
        }

        float angleStep = 2.0f * glm::pi<float>() / static_cast<float>(segments);

        glm::vec3 prevPoint = center + glm::vec3(radius, 0, 0);

        for (int i = 1; i <= segments; ++i)
        {
            float angle = static_cast<float>(i) * angleStep;
            glm::vec3 currPoint = center + glm::vec3(glm::cos(angle) * radius, glm::sin(angle) * radius, 0);
            line(prevPoint, currPoint, color);
            prevPoint = currPoint;
        }
    }

    void LineCanvas3D::sphere(const glm::vec3& center, float radius, const glm::vec3& color, int segments)
    {
        if (segments < 3)
        {
            segments = 3;
        }

        // Draw latitude circles
        for (int lat = 0; lat <= segments; ++lat)
        {
            float theta = glm::pi<float>() * static_cast<float>(lat) / static_cast<float>(segments);
            float sinTheta = glm::sin(theta);
            float cosTheta = glm::cos(theta);

            glm::vec3 prevPoint = center + glm::vec3(radius * sinTheta, radius * cosTheta, 0);

            for (int lon = 1; lon <= segments; ++lon)
            {
                float phi = 2.0f * glm::pi<float>() * static_cast<float>(lon) / static_cast<float>(segments);
                float sinPhi = glm::sin(phi);
                float cosPhi = glm::cos(phi);

                glm::vec3 currPoint = center + glm::vec3(
                    radius * sinTheta * cosPhi,
                    radius * cosTheta,
                    radius * sinTheta * sinPhi
                );

                line(prevPoint, currPoint, color);
                prevPoint = currPoint;
            }
        }

        // Draw longitude circles
        for (int lon = 0; lon < segments; ++lon)
        {
            float phi = 2.0f * glm::pi<float>() * static_cast<float>(lon) / static_cast<float>(segments);
            float sinPhi = glm::sin(phi);
            float cosPhi = glm::cos(phi);

            glm::vec3 prevPoint = center + glm::vec3(0, radius, 0);

            for (int lat = 1; lat <= segments; ++lat)
            {
                float theta = glm::pi<float>() * static_cast<float>(lat) / static_cast<float>(segments);
                float sinTheta = glm::sin(theta);
                float cosTheta = glm::cos(theta);

                glm::vec3 currPoint = center + glm::vec3(
                    radius * sinTheta * cosPhi,
                    radius * cosTheta,
                    radius * sinTheta * sinPhi
                );

                line(prevPoint, currPoint, color);
                prevPoint = currPoint;
            }
        }
    }

    void LineCanvas3D::render(const pnkr::renderer::RHIFrameContext& ctx, const glm::mat4& viewProj)
    {
        if (!m_initialized || m_vertices.empty())
        {
            return;
        }

        // Update current frame offset
        m_currentFrameIndex = ctx.frameIndex % kMaxFrames;

        // Calculate offset for this frame
        uint32_t frameOffset = m_currentFrameIndex * m_maxVertices;

        // Check if we need to resize the buffer
        uint32_t requiredSize = (frameOffset + m_vertices.size()) * sizeof(LineVertex);
        if (m_vertexBuffer && requiredSize > m_vertexBuffer->size())
        {
            createVertexBuffer();
        }

        // Upload vertex data
        uploadVertexData();

        // Bind pipeline and set state
        m_renderer->bindPipeline(ctx.commandBuffer, m_pipeline);

        // Bind vertex buffer
        ctx.commandBuffer->bindVertexBuffer(0, m_vertexBuffer.get(), frameOffset * sizeof(LineVertex));

        // Set push constants (MVP matrix)
        PushConstants pc;
        pc.mvp = viewProj;
        m_renderer->pushConstants(ctx.commandBuffer, m_pipeline,
            rhi::ShaderStage::Vertex, pc);

        // Draw lines
        ctx.commandBuffer->draw(m_vertices.size(), 1, 0, 0);
    }

    void LineCanvas3D::createPipeline()
    {
        // Define vertex input
        std::vector<rhi::VertexInputBinding> bindings = {
            {0, sizeof(LineVertex), rhi::VertexInputRate::Vertex}
        };

        std::vector<rhi::VertexInputAttribute> attributes = {
            {0, 0, rhi::Format::R32G32B32_SFLOAT, offsetof(LineVertex, position), rhi::VertexSemantic::Position},
            {1, 0, rhi::Format::R32G32B32_SFLOAT, offsetof(LineVertex, color), rhi::VertexSemantic::Color}
        };

        // Define push constants
        std::vector<rhi::PushConstantRange> pushConstants = {
            {rhi::ShaderStage::Vertex, 0, sizeof(PushConstants)}
        };

        // Load SPIR-V shaders
        auto loadSpirvShader = [](const std::filesystem::path& shaderPath, rhi::ShaderStage stage) {
            std::ifstream file(shaderPath, std::ios::binary);
            if (!file.is_open())
            {
                throw std::runtime_error("Failed to open SPIR-V shader file: " + shaderPath.string());
            }

            // Read file into vector of bytes
            std::vector<uint32_t> spirv;
            file.seekg(0, std::ios::end);
            size_t fileSize = file.tellg();
            file.seekg(0, std::ios::beg);

            spirv.resize(fileSize / sizeof(uint32_t));
            file.read(reinterpret_cast<char*>(spirv.data()), fileSize);

            return rhi::ShaderModuleDescriptor{stage, spirv, "main"};
        };

        // Try to load compiled SPIR-V shaders from current directory first
        std::filesystem::path shaderDir = std::filesystem::current_path() / "shaders";
        if (!std::filesystem::exists(shaderDir)) {
            // Fallback to engine source directory
            shaderDir = std::filesystem::path(__FILE__).parent_path() / "shaders";
        }

        auto vertShader = loadSpirvShader(shaderDir / "line_canvas.vert.spv", rhi::ShaderStage::Vertex);
        auto fragShader = loadSpirvShader(shaderDir / "line_canvas.frag.spv", rhi::ShaderStage::Fragment);

        // Create graphics pipeline descriptor
        rhi::GraphicsPipelineDescriptor desc{};
        desc.shaders = {vertShader, fragShader};
        desc.vertexBindings = bindings;
        desc.vertexAttributes = attributes;
        desc.topology = rhi::PrimitiveTopology::LineList;

        // Rasterization state
        desc.rasterization.polygonMode = rhi::PolygonMode::Fill;
        desc.rasterization.cullMode = rhi::CullMode::None;
        desc.rasterization.lineWidth = 1.0f;

        // Depth stencil state
        desc.depthStencil.depthTestEnable = true;
        desc.depthStencil.depthWriteEnable = true;
        desc.depthStencil.depthCompareOp = rhi::CompareOp::LessOrEqual;

        // Color blend state
        desc.blend.attachments = {{.blendEnable = false}};

        // Render target formats
        desc.colorFormats = {m_renderer->getDrawColorFormat()};
        desc.depthFormat = m_renderer->getDrawDepthFormat();

        desc.pushConstants = pushConstants;
        desc.debugName = "LineCanvas3D Pipeline";

        // Create pipeline through RHIRenderer
        m_pipeline = m_renderer->createGraphicsPipeline(desc);
    }

    void LineCanvas3D::createVertexBuffer()
    {
        // Create buffer through device
        m_vertexBuffer = m_renderer->device()->createBuffer(
            m_maxVertices * kMaxFrames * sizeof(LineVertex),
            rhi::BufferUsage::VertexBuffer,
            rhi::MemoryUsage::CPUToGPU);
    }

    void LineCanvas3D::uploadVertexData()
    {
        if (m_vertices.empty())
        {
            return;
        }

        uint32_t frameOffset = m_currentFrameIndex * m_maxVertices;
        uint32_t uploadSize = m_vertices.size() * sizeof(LineVertex);

        // Use the convenient uploadData method
        m_vertexBuffer->uploadData(m_vertices.data(), uploadSize, frameOffset * sizeof(LineVertex));
    }
} // namespace pnkr::renderer::debug
</file>

<file path="src/renderer/debug/shaders/line_canvas.frag">
#version 450

layout(location = 0) in vec3 vColor;
layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(vColor, 1.0);
}
</file>

<file path="src/renderer/debug/shaders/line_canvas.vert">
#version 450

layout(push_constant) uniform PushConstants {
    mat4 mvp;
} pc;

layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inColor;

layout(location = 0) out vec3 vColor;

void main() {
    gl_Position = pc.mvp * vec4(inPosition, 1.0);
    vColor = inColor;
}
</file>

<file path="src/renderer/geometry/mesh.cpp">
//
// Created by Jose on 12/13/2025.
//

#include "pnkr/renderer/geometry/mesh.h"

#include "pnkr/renderer/geometry/Vertex.h"
#include "pnkr/renderer/vulkan/vulkan_buffer.hpp"

namespace pnkr::renderer {
class VulkanDevice;
}

pnkr::renderer::Mesh::Mesh(VulkanDevice &device,
                           const std::vector<Vertex> &vertices,
                           const std::vector<std::uint32_t> &indices)
    : m_vertexBuffer(VulkanBuffer::CreateDeviceLocalAndUpload(
          device, vertices.data(), vertices.size() * sizeof(Vertex),
          vk::BufferUsageFlagBits::eVertexBuffer)),
      m_indexBuffer(VulkanBuffer::CreateDeviceLocalAndUpload(
          device, indices.data(), indices.size() * sizeof(std::uint32_t),
          vk::BufferUsageFlagBits::eIndexBuffer)),
      m_indexCount(static_cast<std::uint32_t>(indices.size())) {}

void pnkr::renderer::Mesh::bind(vk::CommandBuffer cmd) const {
  vk::DeviceSize offsets[] = {0};
  cmd.bindVertexBuffers(0, 1, &m_vertexBuffer.buffer(), offsets);
  cmd.bindIndexBuffer(m_indexBuffer.buffer(), 0, vk::IndexType::eUint32);
}

void pnkr::renderer::Mesh::draw(vk::CommandBuffer cmd) const {
  cmd.drawIndexed(m_indexCount, 1, 0, 0, 0);
}
</file>

<file path="src/renderer/renderer.cpp">
#include "pnkr/renderer/renderer.hpp"

#include <imgui.h>
#include <imgui_impl_vulkan.h>

#include "pnkr/platform/window.hpp"
#include "pnkr/core/logger.hpp"
#include "pnkr/renderer/vulkan/vulkan_command_buffer.hpp"
#include "pnkr/renderer/vulkan/vulkan_context.hpp"
#include "pnkr/renderer/vulkan/vulkan_device.hpp"
#include "pnkr/renderer/vulkan/vulkan_pipeline.hpp"
#include "pnkr/renderer/vulkan/vulkan_swapchain.hpp"
#include "pnkr/renderer/vulkan/vulkan_sync_manager.h"
#include "pnkr/renderer/vulkan/vulkan_descriptor.hpp"
#include "pnkr/renderer/vulkan/vulkan_render_target.h"
#include <array>

namespace pnkr::renderer
{
    Renderer::Renderer(platform::Window& window,
                       [[maybe_unused]] const RendererConfig& config)
        : m_window(window)
          , m_useBindlessForCurrentFrame(config.m_useBindless)
    {
        m_context = std::make_unique<VulkanContext>(window);
        m_device = std::make_unique<VulkanDevice>(*m_context);

        m_swapchain = std::make_unique<VulkanSwapchain>(
            m_device->physicalDevice(), m_device->device(), m_context->surface(),
            m_device->queueFamilies().graphics, m_device->queueFamilies().present,
            window, m_device->allocator());

        m_commandBuffer = std::make_unique<VulkanCommandBuffer>(*m_device);

        // Tracy GPU context calibration using a one-time command buffer
        {
            vk::CommandBufferAllocateInfo allocInfo{};
            allocInfo.commandPool = m_commandBuffer->commandPool();
            allocInfo.level = vk::CommandBufferLevel::ePrimary;
            allocInfo.commandBufferCount = 1;

            vk::CommandBuffer tmpCmd = m_device->device().allocateCommandBuffers(allocInfo)[0];

            vk::CommandBufferBeginInfo beginInfo{vk::CommandBufferUsageFlagBits::eOneTimeSubmit};
            tmpCmd.begin(beginInfo);

            m_tracyCtx = PNKR_PROFILE_GPU_CONTEXT(
                static_cast<VkPhysicalDevice>(m_device->physicalDevice()),
                static_cast<VkDevice>(m_device->device()),
                static_cast<VkQueue>(m_device->graphicsQueue()),
                static_cast<VkCommandBuffer>(tmpCmd)
            );

            tmpCmd.end();

            vk::SubmitInfo submitInfo{};
            submitInfo.commandBufferCount = 1;
            submitInfo.pCommandBuffers = &tmpCmd;

            m_device->graphicsQueue().submit(submitInfo, nullptr);
            m_device->device().waitIdle();

            m_device->device().freeCommandBuffers(m_commandBuffer->commandPool(), tmpCmd);
        }

        m_mainTarget = std::make_unique<VulkanRenderTarget>(
            m_device->allocator(),
            m_device->device(),
            m_swapchain->extent().width,
            m_swapchain->extent().height,
            vk::Format::eR16G16B16A16Sfloat, // HDR Color
            vk::Format::eD32Sfloat // High precision depth
        );


        if (config.m_enableBindless) {
            m_bindless = std::make_unique<BindlessManager>(
                m_device->device(),
                m_device->physicalDevice()
            );
            core::Logger::info("[Renderer] Bindless support AVAILABLE (toggle at runtime)");
        } else {
            core::Logger::info("[Renderer] Bindless support DISABLED (set config.enableBindless=true to enable)");
        }

        m_sync = std::make_unique<VulkanSyncManager>(
            m_device->device(), m_device->framesInFlight(),
            static_cast<uint32_t>(m_swapchain->images().size()));

        m_descriptorAllocator = std::make_unique<VulkanDescriptorAllocator>(m_device->device());
        m_descriptorLayoutCache = std::make_unique<VulkanDescriptorLayoutCache>(m_device->device());
        m_defaultSampler = std::make_unique<VulkanSampler>(m_device->device());
        createTextureDescriptorSetLayout();

        // Default 1x1 white texture to safely bind when materials reference no texture
        const unsigned char white[4] = {255, 255, 255, 255};
        m_whiteTexture = createTextureFromPixels(white, 1, 1, 4, true);
    }

    void Renderer::createTextureDescriptorSetLayout()
    {
        vk::DescriptorSetLayoutBinding samplerBinding{};
        samplerBinding.binding = 0;
        samplerBinding.descriptorType = vk::DescriptorType::eCombinedImageSampler;
        samplerBinding.descriptorCount = 1;
        samplerBinding.stageFlags = vk::ShaderStageFlagBits::eFragment;

        vk::DescriptorSetLayoutCreateInfo layoutInfo{};
        layoutInfo.bindingCount = 1;
        layoutInfo.pBindings = &samplerBinding;

        m_textureSetLayout = m_device->device().createDescriptorSetLayout(layoutInfo);
    }


    TextureHandle Renderer::createTextureFromPixels(const unsigned char* pixels,
                                                    int width,
                                                    int height,
                                                    int channels,
                                                    bool srgb)
    {
        // 1. Validate inputs
        if (width <= 0 || height <= 0 || !pixels)
        {
            throw std::runtime_error("Invalid texture data");
        }

        std::vector<unsigned char> rgbaPixels;

        const unsigned char* srcData = pixels;

        // Normalize to RGBA to match staging buffer size expectations
        if (channels != 4)
        {
            if (channels <= 0)
            {
                throw std::runtime_error("Unsupported channel count for texture");
            }

            rgbaPixels.resize(width * height * 4);
            for (int i = 0; i < width * height; ++i)
            {
                const unsigned char r = pixels[i * channels + 0];
                const unsigned char g = (channels >= 2) ? pixels[i * channels + 1] : r;
                const unsigned char b = (channels >= 3) ? pixels[i * channels + 2] : r;
                const unsigned char a = (channels >= 4) ? pixels[i * channels + 3] : 255;

                rgbaPixels[i * 4 + 0] = r;
                rgbaPixels[i * 4 + 1] = g;
                rgbaPixels[i * 4 + 2] = b;
                rgbaPixels[i * 4 + 3] = a;
            }
            srcData = rgbaPixels.data();
        }


        auto texture = std::make_unique<VulkanImage>(
            VulkanImage::createFromMemory(*m_device, srcData, width, height, srgb)
        );
        BindlessIndex bindlessIndex = m_bindless->registerSampledImage(
            texture->view(),
            m_defaultSampler->sampler()
        );
        // 4. Create Descriptor
        vk::DescriptorImageInfo imageInfo{};
        imageInfo.sampler = m_defaultSampler->sampler();
        imageInfo.imageView = texture->view();
        imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;

        vk::DescriptorSet descriptorSet;
        VulkanDescriptorBuilder::begin(m_descriptorLayoutCache.get(), m_descriptorAllocator.get())
            .bindImage(0, &imageInfo, vk::DescriptorType::eCombinedImageSampler,
                       vk::ShaderStageFlagBits::eFragment)
            .build(descriptorSet);

        TextureHandle handle{static_cast<uint32_t>(m_textures.size())};
        m_textures.push_back(std::move(texture));
        m_textureDescriptors.push_back(descriptorSet);
        m_textureBindlessIndices.push_back(bindlessIndex);

        return handle;
    }

    uint32_t Renderer::getTextureBindlessIndex(TextureHandle handle) const
    {
        if (false) {
            // Return 0 as dummy - caller should check isBindlessEnabled()
            return 0;
        }

        if (!handle || handle.id >= m_textureBindlessIndices.size()) {
            // Fallback to white texture
            return m_textureBindlessIndices[m_whiteTexture.id].raw();
        }

        return m_textureBindlessIndices[handle.id].raw();
    }

    TextureHandle Renderer::loadTexture(const std::filesystem::path& filepath, bool srgb)
    {
        auto texture = std::make_unique<VulkanImage>(
            VulkanImage::createFromFile(*m_device, filepath, srgb)
        );


        BindlessIndex bindlessIndex = m_bindless->registerSampledImage(
            texture->view(),
            m_defaultSampler->sampler()
        );


        // Create descriptor set for this texture
        vk::DescriptorImageInfo imageInfo{};
        imageInfo.sampler = m_defaultSampler->sampler();
        imageInfo.imageView = texture->view();
        imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;

        vk::DescriptorSet descriptorSet;
        VulkanDescriptorBuilder::begin(m_descriptorLayoutCache.get(), m_descriptorAllocator.get())
            .bindImage(0, &imageInfo, vk::DescriptorType::eCombinedImageSampler,
                       vk::ShaderStageFlagBits::eFragment)
            .build(descriptorSet);

        TextureHandle handle{static_cast<uint32_t>(m_textures.size())};
        m_textures.push_back(std::move(texture));
        m_textureDescriptors.push_back(descriptorSet);
        m_textureBindlessIndices.push_back(bindlessIndex); // NEW
        core::Logger::info("Loaded texture: {} (handle={})", filepath.string(), handle.id);
        return handle;
    }

    vk::DescriptorSet Renderer::getTextureDescriptor(TextureHandle handle) const
    {
        const bool fallback = (!handle) || (handle.id >= m_textureDescriptors.size());
        if (fallback)
        {
            if (m_textureDescriptors.empty() ||
                !m_whiteTexture ||
                m_whiteTexture.id >= m_textureDescriptors.size())
            {
                throw std::runtime_error("Default texture descriptor not initialized");
            }
            return m_textureDescriptors[m_whiteTexture.id];
        }
        return m_textureDescriptors[handle.id];
    }

    vk::DescriptorSetLayout Renderer::getTextureDescriptorLayout() const
    {
        return m_textureSetLayout;
    }


    PipelineHandle Renderer::createPipeline(const VulkanPipeline::Config& cfg)
    {
        PipelineHandle handle{static_cast<uint32_t>(m_pipelines.size())};

        PipelineConfig pipelineCfg = cfg;

        m_pipelines.push_back(std::make_unique<VulkanPipeline>(
            m_device->device(), pipelineCfg));

        pnkr::core::Logger::info("[Renderer] Created pipeline handle={}", handle.id);
        return handle;
    }

    const VulkanPipeline& Renderer::pipeline(PipelineHandle handle) const
    {
        if (handle.id >= m_pipelines.size())
        {
            throw std::runtime_error("[Renderer] Invalid pipeline handle: " +
                std::to_string(handle.id));
        }
        return *m_pipelines[handle.id];
    }

    vk::PipelineLayout Renderer::pipelineLayout(PipelineHandle handle) const
    {
        if (handle.id >= m_pipelines.size())
            throw std::runtime_error("[Renderer] Invalid pipeline handle");
        return m_pipelines[handle.id]->layout();
    }

    MeshHandle Renderer::createMesh(const std::vector<Vertex>& vertices,
                                    const std::vector<uint32_t>& indices)
    {
        if (vertices.empty() || indices.empty())
            throw std::runtime_error("[Renderer] createMesh: empty data");

        MeshHandle handle{static_cast<uint32_t>(m_meshes.size())};

        m_meshes.push_back(std::make_unique<Mesh>(*m_device, vertices, indices));

        pnkr::core::Logger::info("[Renderer] Created mesh handle={}", handle.id);
        return handle;
    }

    void Renderer::bindMesh(vk::CommandBuffer cmd, MeshHandle handle) const
    {
        if (handle.id >= m_meshes.size())
            throw std::runtime_error("[Renderer] Invalid mesh handle: out of range");

        const auto& mesh = m_meshes[handle.id];
        if (!mesh)
            throw std::runtime_error("[Renderer] Invalid mesh handle: null mesh slot");

        mesh->bind(cmd);
    }

    void Renderer::drawMesh(vk::CommandBuffer cmd, MeshHandle handle) const
    {
        if (handle.id >= m_meshes.size())
            throw std::runtime_error("[Renderer] Invalid mesh handle: out of range");

        const auto& mesh = m_meshes[handle.id];
        if (!mesh)
            throw std::runtime_error("[Renderer] Invalid mesh handle: null mesh slot");

        mesh->draw(cmd);
    }


    void Renderer::setRecordFunc(const RecordFunc& callback)
    {
        m_recordCallback = callback;
    }

    void Renderer::bindPipeline(vk::CommandBuffer cmd,
                                PipelineHandle handle) const
    {
        if (handle.id >= m_pipelines.size())
            throw std::runtime_error("[Renderer] Invalid pipeline handle");

        cmd.bindPipeline(vk::PipelineBindPoint::eGraphics,
                         m_pipelines[handle.id]->pipeline());
    }

    Renderer::~Renderer()
    {
        if (m_device && m_device->device())
        {
            m_device->device().waitIdle();
        }

        if (m_tracyCtx)
        {
            PNKR_PROFILE_GPU_DESTROY(m_tracyCtx);
            m_tracyCtx = nullptr;
        }

        // 1) Pipelines first (they may reference descriptor set layouts)
        m_pipelines.clear();

        // 2) Texture descriptors + textures + sampler
        m_textureDescriptors.clear(); // optional, but keeps vectors tidy
        m_textures.clear(); // triggers VulkanImage destructors
        m_defaultSampler.reset(); // destroys vk::Sampler

        if (m_device && m_textureSetLayout)
        {
            m_device->device().destroyDescriptorSetLayout(m_textureSetLayout);
            m_textureSetLayout = nullptr;
        }

        if (m_descriptorLayoutCache)
        {
            m_descriptorLayoutCache->cleanup(); // if you implemented this
        }

        m_descriptorAllocator.reset();
        m_descriptorLayoutCache.reset();

        m_meshes.clear();
        m_swapchain.reset();
        m_sync.reset();
        m_commandBuffer.reset();
        m_device.reset();
        m_context.reset();
    }

    void Renderer::beginFrame(float deltaTime)
    {
        PNKR_PROFILE_FUNCTION();

        if (m_frameInProgress)
            return;
        if (!m_recordCallback)
        {
            throw std::runtime_error(
                "[Renderer] No record callback set (call setRecordFunc first)");
        }

        const uint32_t frame = m_commandBuffer->currentFrame();
        m_deltaTime = deltaTime;
        m_sync->waitForFrame(frame);

        const vk::Result acq = m_swapchain->acquireNextImage(
            UINT64_MAX, m_sync->imageAvailableSemaphore(frame), nullptr,
            m_imageIndex);

        if (acq == vk::Result::eErrorOutOfDateKHR)
        {
            resize(m_window.width(), m_window.height());
            return;
        }
        if (acq != vk::Result::eSuccess && acq != vk::Result::eSuboptimalKHR)
        {
            pnkr::core::Logger::error("[Renderer] acquireNextImage failed: {}",
                                      vk::to_string(acq));
            return;
        }

        m_sync->resetFrame(frame);

        (void)m_commandBuffer->begin(frame);

        vk::CommandBuffer cmd = m_commandBuffer->cmd(frame);
        PNKR_PROFILE_GPU_COLLECT(m_tracyCtx, static_cast<VkCommandBuffer>(cmd));

        m_frameInProgress = true;
    }

    void Renderer::bindPipeline(vk::CommandBuffer cmd, const ComputePipeline& pipeline)
    {
        cmd.bindPipeline(vk::PipelineBindPoint::eCompute, pipeline.pipeline());
    }

    void Renderer::dispatch(vk::CommandBuffer cmd, uint32_t groupX, uint32_t groupY, uint32_t groupZ)
    {
        cmd.dispatch(groupX, groupY, groupZ);
    }


    void Renderer::drawFrame()
    {
        PNKR_PROFILE_FUNCTION();

        if (!m_frameInProgress)
            return;

        const uint32_t frameIndex = m_commandBuffer->currentFrame();
        vk::CommandBuffer cmd = m_commandBuffer->cmd(frameIndex);

        {
            PNKR_PROFILE_GPU_ZONE(m_tracyCtx, static_cast<VkCommandBuffer>(cmd), "Main Render Pass");

            // Render scene into HDR target
            m_mainTarget->transitionToAttachment(cmd);

            vk::ClearValue colorClear{vk::ClearColorValue{std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f}}};
            vk::ClearValue depthClear{vk::ClearDepthStencilValue{1.0f, 0}};
            m_mainTarget->beginRendering(cmd, colorClear, depthClear);

            if (m_recordCallback)
            {
                RenderFrameContext ctx{};
                ctx.m_cmd = cmd;
                ctx.m_frameIndex = frameIndex;
                ctx.m_imageIndex = m_imageIndex;
                ctx.m_extent = m_swapchain->extent();
                ctx.m_deltaTime = m_deltaTime;
                m_recordCallback(ctx);
            }

            m_mainTarget->endRendering(cmd);
        }

        const vk::Image hdrImage = m_mainTarget->colorImage().image();
        const vk::Image swapImage = m_swapchain->images()[m_imageIndex];

        // Post-Process (Compute) OR Blit (Fallback)
        if (m_postProcessCallback)
        {
            vk::ImageLayout oldSwapLayout = m_swapchain->imageLayout(m_imageIndex);

            vk::ImageMemoryBarrier2 preBarriers[2]{};

            // HDR: color attachment -> shader read for compute sampling
            preBarriers[0].srcStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            preBarriers[0].srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            preBarriers[0].dstStageMask = vk::PipelineStageFlagBits2::eComputeShader;
            preBarriers[0].dstAccessMask = vk::AccessFlagBits2::eShaderRead;
            preBarriers[0].oldLayout = vk::ImageLayout::eColorAttachmentOptimal;
            preBarriers[0].newLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
            preBarriers[0].image = hdrImage;
            preBarriers[0].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            // Swapchain: previous layout -> general for storage writes
            preBarriers[1].srcStageMask = (oldSwapLayout == vk::ImageLayout::eUndefined)
                                              ? vk::PipelineStageFlagBits2::eTopOfPipe
                                              : vk::PipelineStageFlagBits2::eAllCommands;
            preBarriers[1].srcAccessMask = (oldSwapLayout == vk::ImageLayout::eUndefined)
                                               ? vk::AccessFlagBits2::eNone
                                               : vk::AccessFlagBits2::eMemoryRead;
            preBarriers[1].dstStageMask = vk::PipelineStageFlagBits2::eComputeShader;
            preBarriers[1].dstAccessMask = vk::AccessFlagBits2::eShaderStorageWrite;
            preBarriers[1].oldLayout = oldSwapLayout;
            preBarriers[1].newLayout = vk::ImageLayout::eGeneral;
            preBarriers[1].image = swapImage;
            preBarriers[1].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            vk::DependencyInfo preDep{};
            preDep.imageMemoryBarrierCount = 2;
            preDep.pImageMemoryBarriers = preBarriers;
            cmd.pipelineBarrier2(preDep);

            m_swapchain->imageLayout(m_imageIndex) = vk::ImageLayout::eGeneral;

            // C. Execute Callback
            m_postProcessCallback(cmd, m_imageIndex, m_swapchain->extent());

            // D. Prepare images for UI rendering
            vk::ImageMemoryBarrier2 postBarriers[2]{};

            postBarriers[0].srcStageMask = vk::PipelineStageFlagBits2::eComputeShader;
            postBarriers[0].srcAccessMask = vk::AccessFlagBits2::eShaderStorageWrite;
            postBarriers[0].dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            postBarriers[0].dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite |
                vk::AccessFlagBits2::eColorAttachmentRead;
            postBarriers[0].oldLayout = vk::ImageLayout::eGeneral;
            postBarriers[0].newLayout = vk::ImageLayout::eColorAttachmentOptimal;
            postBarriers[0].image = swapImage;
            postBarriers[0].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            postBarriers[1].srcStageMask = vk::PipelineStageFlagBits2::eComputeShader;
            postBarriers[1].srcAccessMask = vk::AccessFlagBits2::eShaderRead;
            postBarriers[1].dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            postBarriers[1].dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            postBarriers[1].oldLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
            postBarriers[1].newLayout = vk::ImageLayout::eColorAttachmentOptimal;
            postBarriers[1].image = hdrImage;
            postBarriers[1].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            vk::DependencyInfo postDep{};
            postDep.imageMemoryBarrierCount = 2;
            postDep.pImageMemoryBarriers = postBarriers;
            cmd.pipelineBarrier2(postDep);

            m_swapchain->imageLayout(m_imageIndex) = vk::ImageLayout::eColorAttachmentOptimal;
        }
        else
        {
            vk::ImageLayout oldSwapLayout = m_swapchain->imageLayout(m_imageIndex);

            vk::ImageMemoryBarrier2 barriers[2]{};

            // HDR src for blit
            barriers[0].srcStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            barriers[0].srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            barriers[0].dstStageMask = vk::PipelineStageFlagBits2::eTransfer;
            barriers[0].dstAccessMask = vk::AccessFlagBits2::eTransferRead;
            barriers[0].oldLayout = vk::ImageLayout::eColorAttachmentOptimal;
            barriers[0].newLayout = vk::ImageLayout::eTransferSrcOptimal;
            barriers[0].image = hdrImage;
            barriers[0].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            // Swapchain dst for blit
            barriers[1].srcStageMask = (oldSwapLayout == vk::ImageLayout::eUndefined)
                                           ? vk::PipelineStageFlagBits2::eTopOfPipe
                                           : vk::PipelineStageFlagBits2::eAllCommands;
            barriers[1].srcAccessMask = (oldSwapLayout == vk::ImageLayout::eUndefined)
                                            ? vk::AccessFlagBits2::eNone
                                            : vk::AccessFlagBits2::eMemoryRead;
            barriers[1].dstStageMask = vk::PipelineStageFlagBits2::eTransfer;
            barriers[1].dstAccessMask = vk::AccessFlagBits2::eTransferWrite;
            barriers[1].oldLayout = oldSwapLayout;
            barriers[1].newLayout = vk::ImageLayout::eTransferDstOptimal;
            barriers[1].image = swapImage;
            barriers[1].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            vk::DependencyInfo dep{};
            dep.imageMemoryBarrierCount = 2;
            dep.pImageMemoryBarriers = barriers;
            cmd.pipelineBarrier2(dep);

            // Blit full image
            const vk::Extent2D srcExtent = m_mainTarget->extent();
            const vk::Extent2D dstExtent = m_swapchain->extent();

            vk::ImageBlit2 blit{};
            blit.srcSubresource = {vk::ImageAspectFlagBits::eColor, 0, 0, 1};
            blit.srcOffsets[0] = vk::Offset3D{0, 0, 0};
            blit.srcOffsets[1] = vk::Offset3D{
                static_cast<int32_t>(srcExtent.width), static_cast<int32_t>(srcExtent.height), 1
            };
            blit.dstSubresource = {vk::ImageAspectFlagBits::eColor, 0, 0, 1};
            blit.dstOffsets[0] = vk::Offset3D{0, 0, 0};
            blit.dstOffsets[1] = vk::Offset3D{
                static_cast<int32_t>(dstExtent.width), static_cast<int32_t>(dstExtent.height), 1
            };

            vk::BlitImageInfo2 blitInfo{};
            blitInfo.srcImage = hdrImage;
            blitInfo.srcImageLayout = vk::ImageLayout::eTransferSrcOptimal;
            blitInfo.dstImage = swapImage;
            blitInfo.dstImageLayout = vk::ImageLayout::eTransferDstOptimal;
            blitInfo.filter = vk::Filter::eLinear;
            blitInfo.regionCount = 1;
            blitInfo.pRegions = &blit;

            cmd.blitImage2(blitInfo);

            // Restore layouts for UI rendering
            vk::ImageMemoryBarrier2 postBarriers[2]{};

            postBarriers[0].srcStageMask = vk::PipelineStageFlagBits2::eTransfer;
            postBarriers[0].srcAccessMask = vk::AccessFlagBits2::eTransferRead;
            postBarriers[0].dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            postBarriers[0].dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            postBarriers[0].oldLayout = vk::ImageLayout::eTransferSrcOptimal;
            postBarriers[0].newLayout = vk::ImageLayout::eColorAttachmentOptimal;
            postBarriers[0].image = hdrImage;
            postBarriers[0].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            postBarriers[1].srcStageMask = vk::PipelineStageFlagBits2::eTransfer;
            postBarriers[1].srcAccessMask = vk::AccessFlagBits2::eTransferWrite;
            postBarriers[1].dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            postBarriers[1].dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            postBarriers[1].oldLayout = vk::ImageLayout::eTransferDstOptimal;
            postBarriers[1].newLayout = vk::ImageLayout::eColorAttachmentOptimal;
            postBarriers[1].image = swapImage;
            postBarriers[1].subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            vk::DependencyInfo postDep{};
            postDep.imageMemoryBarrierCount = 2;
            postDep.pImageMemoryBarriers = postBarriers;
            cmd.pipelineBarrier2(postDep);

            m_swapchain->imageLayout(m_imageIndex) = vk::ImageLayout::eColorAttachmentOptimal;
        }

        // 6) ImGui pass using dynamic rendering into the swapchain image (LoadOp=LOAD)
        {
            vk::RenderingAttachmentInfo colorAttach{};
            colorAttach.imageView = m_swapchain->imageViews()[m_imageIndex];
            colorAttach.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
            colorAttach.loadOp = vk::AttachmentLoadOp::eLoad; // Keep previously blitted scene
            colorAttach.storeOp = vk::AttachmentStoreOp::eStore;

            vk::RenderingInfo renderInfo{};
            renderInfo.renderArea = vk::Rect2D({0, 0}, m_swapchain->extent());
            renderInfo.layerCount = 1;
            renderInfo.colorAttachmentCount = 1;
            renderInfo.pColorAttachments = &colorAttach;

            cmd.beginRendering(renderInfo);

            // Make sure you've called ImGui::Render() before this, e.g. in beginImGuiFrame()/UI build path.
            ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), cmd);

            cmd.endRendering();
        }

        // 7) Transition swapchain image to PRESENT
        {
            vk::ImageMemoryBarrier2 presentBarrier{};
            presentBarrier.srcStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
            presentBarrier.srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            presentBarrier.dstStageMask = vk::PipelineStageFlagBits2::eBottomOfPipe; // or none
            presentBarrier.dstAccessMask = vk::AccessFlagBits2::eNone;
            presentBarrier.oldLayout = vk::ImageLayout::eColorAttachmentOptimal;
            presentBarrier.newLayout = vk::ImageLayout::ePresentSrcKHR;
            presentBarrier.image = m_swapchain->images()[m_imageIndex];
            presentBarrier.subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1};

            vk::DependencyInfo dep{};
            dep.imageMemoryBarrierCount = 1;
            dep.pImageMemoryBarriers = &presentBarrier;
            cmd.pipelineBarrier2(dep);

            m_swapchain->imageLayout(m_imageIndex) = vk::ImageLayout::ePresentSrcKHR;
        }
    }


    void Renderer::endFrame()
    {
        if (!m_frameInProgress)
            return;

        const uint32_t frame = m_commandBuffer->currentFrame();

        m_commandBuffer->end(frame);

        // Submit
        m_commandBuffer->submit(
            frame, m_device->graphicsQueue(), m_sync->imageAvailableSemaphore(frame),
            m_sync->renderFinishedSemaphore(m_imageIndex), // Image-specific semaphore
            m_sync->inFlightFence(frame),
            vk::PipelineStageFlagBits::eColorAttachmentOutput);

        // Present
        const vk::Result pres =
            m_swapchain->present(m_device->presentQueue(), m_imageIndex,
                                 m_sync->renderFinishedSemaphore(
                                     m_imageIndex)); // Image-specific semaphore

        if (pres == vk::Result::eErrorOutOfDateKHR ||
            pres == vk::Result::eSuboptimalKHR)
        {
            resize(m_window.width(), m_window.height());
        }
        else if (pres != vk::Result::eSuccess)
        {
            pnkr::core::Logger::error("[Renderer] present failed: {}",
                                      vk::to_string(pres));
        }

        m_commandBuffer->advanceFrame();
        m_frameInProgress = false;
    }

    void Renderer::resize(int /*width*/, int /*height*/)
    {
        if (!m_swapchain)
            return;

        m_device->device().waitIdle();

        const vk::Format oldFmt = m_swapchain->imageFormat();

        m_swapchain->recreate(m_device->physicalDevice(), m_device->device(),
                              m_context->surface(),
                              m_device->queueFamilies().graphics,
                              m_device->queueFamilies().present, m_window);

        m_mainTarget = std::make_unique<VulkanRenderTarget>(
            m_device->allocator(),
            m_device->device(),
            m_swapchain->extent().width,
            m_swapchain->extent().height,
            vk::Format::eR16G16B16A16Sfloat,
            vk::Format::eD32Sfloat
        );

        m_sync->updateSwapchainSize(
            static_cast<uint32_t>(m_swapchain->images().size()));

        if (m_swapchain->imageFormat() != oldFmt)
        {
            for (auto& pipe : m_pipelines)
            {
                if (!pipe)
                    continue;
                auto cfg = pipe->config();
                pipe = std::make_unique<VulkanPipeline>(m_device->device(),
                                                        cfg);
            }
        }
    }
} // namespace pnkr::renderer
</file>

<file path="src/renderer/rhi_renderer.cpp">
#include "pnkr/renderer/rhi_renderer.hpp"
#include "pnkr/rhi/rhi_factory.hpp"
#include "pnkr/renderer/geometry/Vertex.h"
#include "pnkr/core/logger.hpp"

#include <stb_image.h>
#include <algorithm>

namespace pnkr::renderer
{
    RHIRenderer::RHIRenderer(platform::Window& window, const RendererConfig& config)
        : m_window(window)
    {
        core::Logger::info("Creating RHI Renderer");

        // Create device
        rhi::DeviceDescriptor deviceDesc{};
        deviceDesc.enableValidation = true;
        deviceDesc.enableBindless = config.m_enableBindless;
        deviceDesc.requiredExtensions = {
            VK_KHR_SWAPCHAIN_EXTENSION_NAME,
            VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME
        };

        if (config.m_enableBindless)
        {
            deviceDesc.requiredExtensions.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);
        }

        m_device = rhi::RHIFactory::createDeviceAuto(rhi::RHIBackend::Vulkan, deviceDesc);

        if (!m_device)
        {
            throw std::runtime_error("Failed to create RHI device");
        }

        // Check bindless support
        m_bindlessSupported = m_device->physicalDevice().capabilities().bindlessTextures;
        m_useBindless = m_bindlessSupported && config.m_enableBindless;

        // Create swapchain (WSI)
        m_swapchain = rhi::RHIFactory::createSwapchain(
            m_device.get(),
            m_window,
            rhi::Format::B8G8R8A8_SRGB);

        if (!m_swapchain)
        {
            throw std::runtime_error("Failed to create RHI swapchain");
        }

        // Create per-frame command buffers.
        const uint32_t framesInFlight = std::max(1u, m_swapchain->framesInFlight());
        m_commandBuffers.reserve(framesInFlight);
        for (uint32_t i = 0; i < framesInFlight; ++i)
        {
            m_commandBuffers.push_back(m_device->createCommandBuffer());
        }

        // Create default sampler
        m_defaultSampler = m_device->createSampler(
            rhi::Filter::Linear,
            rhi::Filter::Linear,
            rhi::SamplerAddressMode::Repeat
        );

        // Create render targets
        createRenderTargets();

        // Create default resources
        createDefaultResources();

        core::Logger::info("RHI Renderer created successfully");
        core::Logger::info("Bindless rendering: {}", m_useBindless ? "ENABLED" : "DISABLED");
    }

    RHIRenderer::~RHIRenderer()
    {
        if (m_device)
        {
            m_device->waitIdle();
        }

        core::Logger::info("RHI Renderer destroyed");
    }

    void RHIRenderer::beginFrame(float deltaTime)
    {
        if (m_frameInProgress)
        {
            core::Logger::warn("beginFrame called while frame already in progress");
            return;
        }

        if (!m_swapchain)
        {
            core::Logger::error("beginFrame: swapchain not created");
            return;
        }

        m_deltaTime = deltaTime;
        m_frameInProgress = true;

        if (m_commandBuffers.empty())
        {
            core::Logger::error("beginFrame: no command buffers available");
            m_frameInProgress = false;
            return;
        }

        const uint32_t frameSlot = m_frameIndex % static_cast<uint32_t>(m_commandBuffers.size());
        m_activeCommandBuffer = m_commandBuffers[frameSlot].get();

        // Acquire swapchain image and transition it to ColorAttachment.
        // NOTE: swapchain is responsible for waiting on the per-frame fence and resetting/beginning the command buffer.
        if (!m_swapchain->beginFrame(m_frameIndex, m_activeCommandBuffer, m_currentFrame))
        {
            // Swapchain may have been recreated; skip this frame.
            m_activeCommandBuffer = nullptr;
            m_frameInProgress = false;
            return;
        }

        m_backbuffer = m_currentFrame.color;
    }


    void RHIRenderer::drawFrame()
    {
        if (!m_frameInProgress)
        {
            core::Logger::error("drawFrame called without beginFrame");
            return;
        }

        if (!m_recordCallback)
        {
            core::Logger::warn("No record callback set");
            return;
        }

        if (!m_backbuffer || !m_depthTarget)
        {
            core::Logger::error("drawFrame: missing backbuffer or depth target");
            return;
        }

        if (!m_activeCommandBuffer)
        {
            core::Logger::error("drawFrame: command buffer not available");
            return;
        }

        // Transition depth target to attachment layout (track layout across frames).
        if (m_depthLayout != rhi::ResourceLayout::DepthStencilAttachment)
        {
            rhi::RHIMemoryBarrier depthBarrier{};
            depthBarrier.texture = m_depthTarget.get();
            depthBarrier.srcAccessStage = rhi::ShaderStage::None;
            depthBarrier.dstAccessStage = rhi::ShaderStage::RenderTarget;
            depthBarrier.oldLayout = m_depthLayout;
            depthBarrier.newLayout = rhi::ResourceLayout::DepthStencilAttachment;

            m_activeCommandBuffer->pipelineBarrier(
                rhi::ShaderStage::None,
                rhi::ShaderStage::RenderTarget,
                {depthBarrier}
            );

            m_depthLayout = rhi::ResourceLayout::DepthStencilAttachment;
        }

        // Begin rendering into the swapchain backbuffer.
        rhi::RenderingInfo renderingInfo{};
        renderingInfo.renderArea = rhi::Rect2D{
            0, 0,
            m_swapchain->extent().width,
            m_swapchain->extent().height
        };

        // Color attachment (swapchain image)
        rhi::RenderingAttachment colorAttachment{};
        colorAttachment.texture = m_backbuffer;
        colorAttachment.loadOp = rhi::LoadOp::Clear;
        colorAttachment.storeOp = rhi::StoreOp::Store;
        colorAttachment.clearValue.isDepthStencil = false;
        colorAttachment.clearValue.color.float32[0] = 0.1f;
        colorAttachment.clearValue.color.float32[1] = 0.1f;
        colorAttachment.clearValue.color.float32[2] = 0.1f;
        colorAttachment.clearValue.color.float32[3] = 1.0f;
        renderingInfo.colorAttachments.push_back(colorAttachment);

        // Depth attachment
        rhi::RenderingAttachment depthAttachment{};
        depthAttachment.texture = m_depthTarget.get();
        depthAttachment.loadOp = rhi::LoadOp::Clear;
        depthAttachment.storeOp = rhi::StoreOp::Store;
        depthAttachment.clearValue.isDepthStencil = true;
        depthAttachment.clearValue.depthStencil.depth = 1.0f;
        depthAttachment.clearValue.depthStencil.stencil = 0;
        renderingInfo.depthAttachment = &depthAttachment;

        m_activeCommandBuffer->beginRendering(renderingInfo);

        // Viewport/scissor
        rhi::Viewport viewport{};
        viewport.x = 0.0f;
        viewport.y = 0.0f;
        viewport.width = static_cast<float>(m_swapchain->extent().width);
        viewport.height = static_cast<float>(m_swapchain->extent().height);
        viewport.minDepth = 0.0f;
        viewport.maxDepth = 1.0f;
        m_activeCommandBuffer->setViewport(viewport);

        rhi::Rect2D scissor{};
        scissor.x = 0;
        scissor.y = 0;
        scissor.width = m_swapchain->extent().width;
        scissor.height = m_swapchain->extent().height;
        m_activeCommandBuffer->setScissor(scissor);

        // Call user record callback
        RHIFrameContext context{};
        context.commandBuffer = m_activeCommandBuffer;
        context.frameIndex = m_frameIndex;
        context.deltaTime = m_deltaTime;

        m_recordCallback(context);

        m_activeCommandBuffer->endRendering();
    }

    void RHIRenderer::endFrame()
    {
        if (!m_frameInProgress)
        {
            core::Logger::error("endFrame called without beginFrame");
            return;
        }

        if (!m_swapchain)
        {
            core::Logger::error("endFrame: swapchain not created");
            if (m_activeCommandBuffer)
            {
                m_activeCommandBuffer->end();
            }
            m_frameInProgress = false;
            m_activeCommandBuffer = nullptr;
            return;
        }

        // Transition to Present, end, submit, and present.
        if (m_activeCommandBuffer)
        {
            (void)m_swapchain->endFrame(m_frameIndex, m_activeCommandBuffer);
        }

        m_frameInProgress = false;
        m_activeCommandBuffer = nullptr;
        m_frameIndex++;
    }

    void RHIRenderer::resize(int width, int height)
    {
        core::Logger::info("Resizing renderer to {}x{}", width, height);

        if (!m_swapchain)
            return;

        m_device->waitIdle();

        m_swapchain->recreate(static_cast<uint32_t>(width), static_cast<uint32_t>(height));

        // Recreate depth target for new extent.
        createRenderTargets();
    }


    MeshHandle RHIRenderer::createMesh(const std::vector<Vertex>& vertices,
                                       const std::vector<uint32_t>& indices)
    {
        MeshData mesh{};

        // Create vertex buffer
        uint64_t vertexBufferSize = vertices.size() * sizeof(Vertex);
        mesh.vertexBuffer = m_device->createBuffer(
            vertexBufferSize,
            rhi::BufferUsage::VertexBuffer | rhi::BufferUsage::TransferDst,
            rhi::MemoryUsage::GPUOnly
        );

        // Upload vertices (using staging buffer internally)
        uploadToBuffer(mesh.vertexBuffer.get(), vertices.data(), vertexBufferSize);

        // Create index buffer
        uint64_t indexBufferSize = indices.size() * sizeof(uint32_t);
        mesh.indexBuffer = m_device->createBuffer(
            indexBufferSize,
            rhi::BufferUsage::IndexBuffer | rhi::BufferUsage::TransferDst,
            rhi::MemoryUsage::GPUOnly
        );

        // Upload indices
        uploadToBuffer(mesh.indexBuffer.get(), indices.data(), indexBufferSize);

        mesh.vertexCount = static_cast<uint32_t>(vertices.size());
        mesh.indexCount = static_cast<uint32_t>(indices.size());

        MeshHandle handle = static_cast<MeshHandle>(m_meshes.size());
        m_meshes.push_back(std::move(mesh));

        core::Logger::info("Created mesh: {} vertices, {} indices",
                           mesh.vertexCount, mesh.indexCount);

        return handle;
    }


    TextureHandle RHIRenderer::createTexture(const unsigned char* data,
                                             int width, int height, int channels,
                                             bool srgb)
    {
        rhi::Format format;
        switch (channels)
        {
        case 1: format = rhi::Format::R8_UNORM;
            break;
        case 2: format = rhi::Format::R8G8_UNORM;
            break;
        case 3: format = rhi::Format::R8G8B8_UNORM;
            break;
        case 4: format = srgb ? rhi::Format::R8G8B8A8_SRGB : rhi::Format::R8G8B8A8_UNORM;
            break;
        default:
            core::Logger::error("Unsupported channel count: {}", channels);
            return INVALID_TEXTURE_HANDLE;
        }

        auto texture = m_device->createTexture(
            rhi::Extent3D{static_cast<uint32_t>(width), static_cast<uint32_t>(height), 1},
            format,
            rhi::TextureUsage::Sampled | rhi::TextureUsage::TransferDst,
            1, 1
        );

        // Upload texture data
        uint64_t imageSize = width * height * channels;
        texture->uploadData(data, imageSize);

        TextureData texData{};
        texData.texture = std::move(texture);
        texData.bindlessIndex = 0;

        if (m_useBindless && m_device)
        {
            auto bindlessHandle = m_device->registerBindlessTexture(
                texData.texture.get(),
                m_defaultSampler.get()
            );
            texData.bindlessIndex = bindlessHandle.index;
        }

        TextureHandle handle = static_cast<TextureHandle>(m_textures.size());
        m_textures.push_back(std::move(texData));

        core::Logger::info("Created texture: {}x{}, {} channels", width, height, channels);

        return handle;
    }


    TextureHandle RHIRenderer::loadTexture(const std::filesystem::path& filepath, bool srgb)
    {
        int width, height, channels;
        stbi_set_flip_vertically_on_load(true);

        unsigned char* data = stbi_load(filepath.string().c_str(),
                                        &width, &height, &channels, 0);

        if (!data)
        {
            core::Logger::error("Failed to load texture: {}", filepath.string());
            return INVALID_TEXTURE_HANDLE;
        }

        TextureHandle handle = createTexture(data, width, height, channels, srgb);

        stbi_image_free(data);

        core::Logger::info("Loaded texture from: {}", filepath.string());

        return handle;
    }


    TextureHandle RHIRenderer::createCubemap(const std::vector<std::filesystem::path>& faces, bool srgb)
    {
        if (faces.size() != 6) {
            core::Logger::error("createCubemap: Exactly 6 face images required, got {}", faces.size());
            return INVALID_TEXTURE_HANDLE;
        }

        // Load all 6 faces first to validate they have the same dimensions
        std::vector<std::unique_ptr<unsigned char[], void(*)(void*)>> faceData;
        std::vector<int> widths, heights, channels;

        for (const auto& facePath : faces) {
            int w, h, c;
            stbi_set_flip_vertically_on_load(false); // Don't flip for cubemaps
            unsigned char* data = stbi_load(facePath.string().c_str(), &w, &h, &c, STBI_rgb_alpha);

            if (!data) {
                core::Logger::error("Failed to load cubemap face: {}", facePath.string());
                return INVALID_TEXTURE_HANDLE;
            }

            faceData.emplace_back(data, stbi_image_free);
            widths.push_back(w);
            heights.push_back(h);
            channels.push_back(STBI_rgb_alpha);
        }

        // Validate all faces have the same dimensions
        for (size_t i = 1; i < widths.size(); ++i) {
            if (widths[i] != widths[0] || heights[i] != heights[0]) {
                core::Logger::error("All cubemap faces must have the same dimensions");
                return INVALID_TEXTURE_HANDLE;
            }
        }

        // Determine format
        rhi::Format format;
        switch (channels[0]) {
        case 1: format = rhi::Format::R8_UNORM; break;
        case 2: format = rhi::Format::R8G8_UNORM; break;
        case 3: format = rhi::Format::R8G8B8_UNORM; break;
        case 4: format = srgb ? rhi::Format::R8G8B8A8_SRGB : rhi::Format::R8G8B8A8_UNORM; break;
        default:
            core::Logger::error("Unsupported channel count: {}", channels[0]);
            return INVALID_TEXTURE_HANDLE;
        }

        // Create cubemap texture
        auto texture = m_device->createCubemap(
            rhi::Extent3D{static_cast<uint32_t>(widths[0]), static_cast<uint32_t>(heights[0]), 1},
            format,
            rhi::TextureUsage::Sampled | rhi::TextureUsage::TransferDst,
            1   // mipLevels
        );

        // Upload each face
        uint64_t faceSize = widths[0] * heights[0] * 4; // Always use RGBA after STBI_rgb_alpha conversion
        for (uint32_t i = 0; i < 6; ++i) {
            rhi::TextureSubresource subresource{};
            subresource.mipLevel = 0;
            subresource.arrayLayer = i;  // Each face is a different array layer

            texture->uploadData(faceData[i].get(), faceSize, subresource);
        }

        TextureData texData{};
        texData.texture = std::move(texture);
        texData.bindlessIndex = 0;

        if (m_useBindless && m_device) {
            auto bindlessHandle = m_device->registerBindlessCubemap(
                texData.texture.get(),
                m_defaultSampler.get()
            );
            texData.bindlessIndex = bindlessHandle.index;
        }

        TextureHandle handle = static_cast<TextureHandle>(m_textures.size());
        m_textures.push_back(std::move(texData));

        core::Logger::info("Created cubemap: {}x{}, {} faces", widths[0], heights[0], 6);

        return handle;
    }

    PipelineHandle RHIRenderer::createGraphicsPipeline(const rhi::GraphicsPipelineDescriptor& desc)
    {
        auto pipeline = m_device->createGraphicsPipeline(desc);

        PipelineHandle handle = static_cast<PipelineHandle>(m_pipelines.size());
        m_pipelines.push_back(std::move(pipeline));

        core::Logger::info("Created graphics pipeline");

        return handle;
    }

    PipelineHandle RHIRenderer::createComputePipeline(const rhi::ComputePipelineDescriptor& desc)
    {
        auto pipeline = m_device->createComputePipeline(desc);

        PipelineHandle handle = static_cast<PipelineHandle>(m_pipelines.size());
        m_pipelines.push_back(std::move(pipeline));

        core::Logger::info("Created compute pipeline");

        return handle;
    }

    void RHIRenderer::setRecordFunc(const RHIRecordFunc& callback)
    {
        m_recordCallback = callback;
    }

    void RHIRenderer::bindPipeline(rhi::RHICommandBuffer* cmd, PipelineHandle handle)
    {
        if (handle.id >= m_pipelines.size())
        {
            core::Logger::error("Invalid pipeline handle: {}", handle.id);
            return;
        }

        cmd->bindPipeline(m_pipelines[handle.id].get());
    }

    void RHIRenderer::bindMesh(rhi::RHICommandBuffer* cmd, MeshHandle handle)
    {
        if (handle.id >= m_meshes.size())
        {
            core::Logger::error("Invalid mesh handle: {}", handle.id);
            return;
        }

        const auto& mesh = m_meshes[handle.id];
        cmd->bindVertexBuffer(0, mesh.vertexBuffer.get(), 0);
        cmd->bindIndexBuffer(mesh.indexBuffer.get(), 0, false);
    }

    void RHIRenderer::drawMesh(rhi::RHICommandBuffer* cmd, MeshHandle handle)
    {
        if (handle.id >= m_meshes.size())
        {
            core::Logger::error("Invalid mesh handle.id: {}", handle.id);
            return;
        }

        const auto& mesh = m_meshes[handle.id];
        cmd->drawIndexed(mesh.indexCount, 1, 0, 0, 0);
    }

    void RHIRenderer::bindDescriptorSet(rhi::RHICommandBuffer* cmd,
                                        PipelineHandle handle,
                                        uint32_t setIndex,
                                        rhi::RHIDescriptorSet* descriptorSet)
    {
        auto* pipeline = getPipeline(handle);
        if (!pipeline)
        {
            core::Logger::error("Invalid pipeline handle: {}", handle.id);
            return;
        }

        cmd->bindDescriptorSet(pipeline, setIndex, descriptorSet);
    }

    rhi::RHITexture* RHIRenderer::getTexture(TextureHandle handle) const
    {
        if (handle.id >= m_textures.size())
        {
            core::Logger::error("Invalid texture handle: {}", handle.id);
            return nullptr;
        }

        return m_textures[handle.id].texture.get();
    }

    uint32_t RHIRenderer::getTextureBindlessIndex(TextureHandle handle) const
    {
        if (handle.id >= m_textures.size())
        {
            core::Logger::error("Invalid texture handle: {}", handle.id);
            return 0xFFFFFFFFu;
        }

        return m_textures[handle.id].bindlessIndex;
    }

    rhi::Format RHIRenderer::getDrawColorFormat() const
    {
        return m_swapchain ? m_swapchain->colorFormat() : rhi::Format::Undefined;
    }

    rhi::Format RHIRenderer::getDrawDepthFormat() const
    {
        return m_depthTarget->format();
    }

    rhi::Format RHIRenderer::getSwapchainColorFormat() const
    {
        return m_swapchain ? m_swapchain->colorFormat() : rhi::Format::Undefined;
    }

    void RHIRenderer::setBindlessEnabled(bool enabled)
    {
        if (enabled && !m_bindlessSupported)
        {
            core::Logger::warn("Cannot enable bindless: not supported");
            return;
        }

        m_useBindless = enabled;
        core::Logger::info("Bindless rendering: {}", enabled ? "ENABLED" : "DISABLED");
    }

    rhi::RHIPipeline* RHIRenderer::pipeline(PipelineHandle handle)
    {
        return getPipeline(handle);
    }

    void RHIRenderer::createRenderTargets()
    {
        if (!m_swapchain)
        {
            throw std::runtime_error("createRenderTargets: swapchain is null");
        }

        const auto scExtent = m_swapchain->extent();

        // Depth target (device-owned; backbuffer comes from the swapchain).
        m_depthTarget = m_device->createTexture(
            rhi::Extent3D{scExtent.width, scExtent.height, 1},
            rhi::Format::D32_SFLOAT,
            rhi::TextureUsage::DepthStencilAttachment,
            1, 1
        );
        m_depthLayout = rhi::ResourceLayout::Undefined;

        core::Logger::info("Created swapchain/depth targets: {}x{}", scExtent.width, scExtent.height);
    }

    void RHIRenderer::createDefaultResources()
    {
        // Create white texture (1x1 white pixel)
        m_whiteTexture = createWhiteTexture();
    }

    rhi::RHIPipeline* RHIRenderer::getPipeline(PipelineHandle handle)
    {
        if (handle.id >= m_pipelines.size())
        {
            return nullptr;
        }
        return m_pipelines[handle.id].get();
    }

    TextureHandle RHIRenderer::createWhiteTexture()
    {
        unsigned char white[4] = {255, 255, 255, 255};
        return createTexture(white, 1, 1, 4, false);
    }

    void RHIRenderer::uploadToBuffer(rhi::RHIBuffer* target, const void* data, uint64_t size)
    {
        if (!target || !data || size == 0)
        {
            core::Logger::error("uploadToBuffer: invalid target/data/size");
            return;
        }

        auto staging = m_device->createBuffer(size, rhi::BufferUsage::TransferSrc, rhi::MemoryUsage::CPUToGPU);
        staging->uploadData(data, size);

        auto cmd = m_device->createCommandBuffer();
        cmd->begin();
        cmd->copyBuffer(staging.get(), target, 0, 0, size);
        cmd->end();
        m_device->submitCommands(cmd.get());
        m_device->waitIdle();
    }
} // namespace pnkr::renderer
</file>

<file path="src/renderer/scene.cpp">
#include "pnkr/renderer/scene/Scene.hpp"
#include "pnkr/renderer/renderer.hpp"
#include "pnkr/renderer/vulkan/PushConstants.h"
#include <glm/gtc/constants.hpp>
#include <glm/gtx/quaternion.hpp>

namespace pnkr::renderer::scene {

    void Scene::onResize(vk::Extent2D ext) {
        if (ext.width == 0 || ext.height == 0) return;
        if (ext.width == m_lastExtent.width && ext.height == m_lastExtent.height) return;

        m_lastExtent = ext;
        float aspect = static_cast<float>(ext.width) / static_cast<float>(ext.height);
        m_camera.setPerspective(glm::radians(60.0f), aspect, 0.1f, 100.0f);
    }

    void Scene::update(float dt, vk::Extent2D ext, const platform::Input& input) {
        onResize(ext);

        // Update camera controller
        m_cameraController.update(input, dt);
        m_cameraController.applyToCamera(m_camera);

        // Example animation: spin first object
        if (!m_objects.empty()) {
            auto& rot = m_objects[0].xform.m_rotation;
            rot = glm::normalize(glm::rotate(rot, dt, glm::vec3(0.0f, 1.0f, 0.0f)));
        }
    }

    void Scene::record(const RenderFrameContext& ctx, const Renderer& r) const {
        for (const auto& obj : m_objects) {
            PushConstants pc{};
            pc.m_model = obj.xform.mat4();
            pc.m_viewProj = m_camera.viewProj();

            r.pushConstants(ctx.m_cmd, obj.pipe, vk::ShaderStageFlagBits::eVertex, pc);
            r.bindPipeline(ctx.m_cmd, obj.pipe);
            r.bindMesh(ctx.m_cmd, obj.mesh);
            r.drawMesh(ctx.m_cmd, obj.mesh);
        }
    }

} // namespace pnkr::renderer::scene
</file>

<file path="src/renderer/scene/Model.cpp">
// Model.cpp

#include "pnkr/renderer/scene/Model.hpp"
#include "pnkr/renderer/renderer.hpp"
#include "pnkr/renderer/geometry/Vertex.h"
#include "pnkr/core/logger.hpp"

// fastgltf includes
#include <fastgltf/core.hpp>
#include <fastgltf/types.hpp>
#include <fastgltf/tools.hpp>
#include <fastgltf/glm_element_traits.hpp>


#include <cstdint>
#include <functional>
#include <variant>

#include <filesystem>
#include <fstream>
#include <optional>
#include <string>
#include <vector>

#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/matrix_decompose.hpp>
#include <glm/vec4.hpp>

namespace pnkr::renderer::scene
{
    static Transform toTransform(const fastgltf::Node& node)
    {
        Transform t{};
        std::visit(fastgltf::visitor{
                       [&](const fastgltf::TRS& trs)
                       {
                           t.m_translation = glm::make_vec3(trs.translation.data());
                           t.m_rotation = glm::make_quat(trs.rotation.data());
                           t.m_scale = glm::make_vec3(trs.scale.data());
                       },
                       [&](const fastgltf::math::fmat4x4& mat)
                       {
                           glm::mat4 m = glm::make_mat4(mat.data());
                           glm::vec3 skew{};
                           glm::vec4 perspective{};
                           glm::decompose(m, t.m_scale, t.m_rotation, t.m_translation, skew, perspective);
                       }
                   },
                   node.transform);
        return t;
    }

    static std::vector<std::uint8_t> readFileBytes(const std::filesystem::path& p)
    {
        std::ifstream f(p, std::ios::binary);
        if (!f) return {};

        f.seekg(0, std::ios::end);
        const auto sz = static_cast<size_t>(f.tellg());
        f.seekg(0, std::ios::beg);

        std::vector<std::uint8_t> out(sz);
        if (sz) f.read(reinterpret_cast<char*>(out.data()), static_cast<std::streamsize>(sz));
        return out;
    }

    static std::optional<std::size_t> pickImageIndex(const fastgltf::Texture& tex)
    {
        // Prefer standard images first, then extension-backed images.
        if (tex.imageIndex.has_value()) return tex.imageIndex.value();
        if (tex.webpImageIndex.has_value()) return tex.webpImageIndex.value();
        if (tex.ddsImageIndex.has_value()) return tex.ddsImageIndex.value();
        if (tex.basisuImageIndex.has_value()) return tex.basisuImageIndex.value();
        return std::nullopt;
    }

    static fastgltf::URIView getUriView(const fastgltf::sources::URI& u)
    {
        // fastgltf has had a few API variations here; keep this resilient.
        if constexpr (requires { u.uri; }) {
            // In some versions, u.uri is a fastgltf::URI / URIView-like.
            if constexpr (requires { u.uri.string(); }) {
                return fastgltf::URIView{u.uri.string()};
            } else if constexpr (requires { u.uri.c_str(); }) {
                return fastgltf::URIView{std::string_view{u.uri.c_str()}};
            } else {
                return fastgltf::URIView{};
            }
        } else if constexpr (requires { u.uri; }) {
            return u.uri;
        } else {
            return fastgltf::URIView{};
        }
    }

    template <class T>
    static void assignFromBytesLike(std::vector<std::uint8_t>& dst, const T& src)
    {
        if constexpr (requires { src.data(); src.size(); }) {
            const auto* p = reinterpret_cast<const std::uint8_t*>(src.data());
            dst.assign(p, p + src.size());
        }
    }

static std::vector<std::uint8_t> base64Decode(std::string_view in)
{
    static constexpr std::array<std::uint8_t, 256> kDec = [] {
        std::array<std::uint8_t, 256> t{};
        t.fill(0xFF);
        for (int i = 'A'; i <= 'Z'; ++i) t[static_cast<std::uint8_t>(i)] = static_cast<std::uint8_t>(i - 'A');
        for (int i = 'a'; i <= 'z'; ++i) t[static_cast<std::uint8_t>(i)] = static_cast<std::uint8_t>(26 + i - 'a');
        for (int i = '0'; i <= '9'; ++i) t[static_cast<std::uint8_t>(i)] = static_cast<std::uint8_t>(52 + i - '0');
        t[static_cast<std::uint8_t>('+')] = 62;
        t[static_cast<std::uint8_t>('/')] = 63;
        return t;
    }();

    std::vector<std::uint8_t> out;
    out.reserve((in.size() * 3) / 4);

    std::uint32_t buf = 0;
    int bits = 0;
    int pad = 0;

    for (unsigned char c : in) {
        if (std::isspace(c)) continue;
        if (c == '=') { pad++; continue; }

        const std::uint8_t v = kDec[c];
        if (v == 0xFF) continue; // ignore non-base64 chars defensively

        buf = (buf << 6) | v;
        bits += 6;

        if (bits >= 8) {
            bits -= 8;
            out.push_back(static_cast<std::uint8_t>((buf >> bits) & 0xFFu));
        }
    }

    // Trim padding bytes if present
    if (pad > 0 && out.size() >= static_cast<size_t>(pad)) {
        out.resize(out.size() - static_cast<size_t>(pad));
    }

    return out;
}

static std::vector<std::uint8_t> decodeDataUriBytes(std::string_view uri)
{
    // Expected form: data:[<mime>][;base64],<payload>
    if (!uri.starts_with("data:")) return {};

    const auto comma = uri.find(',');
    if (comma == std::string_view::npos) return {};

    const std::string_view meta = uri.substr(5, comma - 5);
    const std::string_view payload = uri.substr(comma + 1);

    const bool isBase64 = (meta.find(";base64") != std::string_view::npos);
    if (!isBase64) {
        // glTF embedded binary/image data is effectively always base64.
        // If you need SVG/text data URIs later, implement URL-percent decoding here.
        return {};
    }

    return base64Decode(payload);
}

static std::vector<std::uint8_t> extractImageBytes(
    const fastgltf::Asset& gltf,
    const fastgltf::Image& image,
    const std::filesystem::path& baseDir)
{
    std::vector<std::uint8_t> bytes;

    std::visit(fastgltf::visitor{
        [&](const fastgltf::sources::BufferView& view) {
            const auto& bv = gltf.bufferViews[view.bufferViewIndex];
            const auto& buf = gltf.buffers[bv.bufferIndex];

            std::visit(fastgltf::visitor{
                [&](const fastgltf::sources::Array& a) {
                    const auto* begin = reinterpret_cast<const std::uint8_t*>(a.bytes.data() + bv.byteOffset);
                    bytes.assign(begin, begin + bv.byteLength);
                },
                [&](const fastgltf::sources::Vector& v) {
                    const auto* begin = reinterpret_cast<const std::uint8_t*>(v.bytes.data() + bv.byteOffset);
                    bytes.assign(begin, begin + bv.byteLength);
                },
                [&](const fastgltf::sources::ByteView& bvSrc) {
                    const auto* begin = reinterpret_cast<const std::uint8_t*>(bvSrc.bytes.data() + bv.byteOffset);
                    bytes.assign(begin, begin + bv.byteLength);
                },
                [](auto&) {}
            }, buf.data);
        },

        [&](const fastgltf::sources::Array& a) {
            const auto* p = reinterpret_cast<const std::uint8_t*>(a.bytes.data());
            bytes.assign(p, p + a.bytes.size());
        },

        [&](const fastgltf::sources::Vector& v) {
            const auto* p = reinterpret_cast<const std::uint8_t*>(v.bytes.data());
            bytes.assign(p, p + v.bytes.size());
        },

        [&](const fastgltf::sources::ByteView& v) {
            const auto* p = reinterpret_cast<const std::uint8_t*>(v.bytes.data());
            bytes.assign(p, p + v.bytes.size());
        },

        [&](const fastgltf::sources::URI& uriSrc) {
            const auto uri = getUriView(uriSrc);
            if (!uri.valid()) return;

            if (uri.isDataUri()) {
                bytes = decodeDataUriBytes(uri.string());
                return;
            }

            if (!uri.isLocalPath()) {
                core::Logger::warn("[Model] Non-local image URI not supported: {}", std::string(uri.string()));
                return;
            }

            const std::filesystem::path p = baseDir / uri.fspath();
            bytes = readFileBytes(p);
        },

        [](auto&) {}
    }, image.data);

    return bytes;
}


    std::unique_ptr<Model> Model::load(RHIRenderer& renderer, const std::filesystem::path& path)
    {
        // Enable common texture extensions so assets using them do not fail parsing.
        fastgltf::Parser parser(
            fastgltf::Extensions::KHR_texture_basisu |
            fastgltf::Extensions::MSFT_texture_dds |
            fastgltf::Extensions::EXT_texture_webp);

        auto data = fastgltf::GltfDataBuffer::FromPath(path);
        if (data.error() != fastgltf::Error::None)
        {
            core::Logger::error("Failed to load glTF file: {}", path.string());
            return nullptr;
        }

        const auto options =
            fastgltf::Options::LoadExternalBuffers |
            fastgltf::Options::LoadExternalImages;

        auto asset = parser.loadGltf(data.get(), path.parent_path(), options);
        if (asset.error() != fastgltf::Error::None)
        {
            core::Logger::error("Failed to parse glTF: Error Code {}", static_cast<int>(asset.error()));
            return nullptr;
        }

        auto& gltf = asset.get();
        auto model = std::make_unique<Model>();

        core::Logger::info("Loading Model (fastgltf): {} (Nodes: {})", path.string(), gltf.nodes.size());

        // --- Textures ---
        model->m_textures.reserve(gltf.textures.size());
        for (const auto& tex : gltf.textures)
        {
            const auto imgIndexOpt = pickImageIndex(tex);
            if (!imgIndexOpt)
            {
                model->m_textures.push_back(INVALID_TEXTURE_HANDLE);
                continue;
            }

            const auto& image = gltf.images[*imgIndexOpt];

            // Extract encoded bytes (supports BufferView/Vector/Array/URI).
            const auto encoded = extractImageBytes(gltf, image, path.parent_path());
            if (encoded.empty())
            {
                core::Logger::warn("[Model] Texture image had no bytes (imageIndex={})", *imgIndexOpt);
                model->m_textures.push_back(INVALID_TEXTURE_HANDLE);
                continue;
            }

            int w = 0, h = 0, comp = 0;
            stbi_uc* pixels = stbi_load_from_memory(
                reinterpret_cast<const stbi_uc*>(encoded.data()),
                static_cast<int>(encoded.size()),
                &w, &h, &comp, 4);

            if (!pixels)
            {
                // If your asset is KTX2/DDS, stb_image won't decode it (expected).
                core::Logger::warn("[Model] stb_image failed for imageIndex={}: {}",
                                   *imgIndexOpt,
                                   (stbi_failure_reason() ? stbi_failure_reason() : "unknown"));
                model->m_textures.push_back(INVALID_TEXTURE_HANDLE);
                continue;
            }

            model->m_textures.push_back(renderer.createTexture(pixels, w, h, 4, true));
            stbi_image_free(pixels);
        }

        // --- Materials ---
        model->m_materials.reserve(gltf.materials.size());
        for (const auto& mat : gltf.materials)
        {
            MaterialData md{};
            const auto& pbr = mat.pbrData;

            md.baseColorFactor = glm::make_vec4(pbr.baseColorFactor.data());

            if (pbr.baseColorTexture.has_value())
            {
                const size_t texIdx = pbr.baseColorTexture.value().textureIndex;
                if (texIdx < model->m_textures.size())
                    md.baseColorTexture = model->m_textures[texIdx];
            }

            model->m_materials.push_back(md);
        }
        if (model->m_materials.empty())
            model->m_materials.push_back({});

        // --- Nodes & Meshes ---
        model->m_nodes.resize(gltf.nodes.size());
        for (auto& n : model->m_nodes) n.parentIndex = -1;

        // Pass 1: fill node basics + children lists
        for (size_t i = 0; i < gltf.nodes.size(); ++i)
        {
            const auto& gNode = gltf.nodes[i];
            auto& myNode = model->m_nodes[i];

            myNode.name = gNode.name;
            myNode.localTransform = toTransform(gNode);

            myNode.children.clear();
            myNode.children.reserve(gNode.children.size());
            for (const auto& childIdx : gNode.children)
                myNode.children.push_back(static_cast<int>(childIdx));
        }

        // Pass 2: set parents (ensures children nodes exist)
        for (size_t i = 0; i < model->m_nodes.size(); ++i)
        {
            for (int child : model->m_nodes[i].children)
            {
                if (child >= 0 && static_cast<size_t>(child) < model->m_nodes.size())
                    model->m_nodes[child].parentIndex = static_cast<int>(i);
            }
        }

        // Mesh primitives
        for (size_t i = 0; i < gltf.nodes.size(); ++i)
        {
            const auto& gNode = gltf.nodes[i];
            auto& myNode = model->m_nodes[i];

            if (!gNode.meshIndex.has_value())
                continue;

            const auto& gMesh = gltf.meshes[gNode.meshIndex.value()];
            for (const auto& gPrim : gMesh.primitives)
            {
                std::vector<Vertex> vertices;
                std::vector<uint32_t> indices;

                auto itPos = gPrim.findAttribute("POSITION");
                if (itPos == gPrim.attributes.end())
                    continue;

                const auto& posAccessor = gltf.accessors[itPos->accessorIndex];
                vertices.resize(posAccessor.count);

                fastgltf::iterateAccessorWithIndex<glm::vec3>(gltf, posAccessor,
                                                             [&](glm::vec3 pos, size_t idx)
                                                             {
                                                                 vertices[idx].m_position = pos;
                                                                 vertices[idx].m_color = glm::vec3(1.0f);
                                                                 vertices[idx].m_normal = glm::vec3(0.0f, 1.0f, 0.0f);
                                                                 vertices[idx].m_texCoord = glm::vec2(0.0f);
                                                                 vertices[idx].m_tangent = glm::vec4(0.0f); // Init tangent
                                                             });

                if (auto it = gPrim.findAttribute("NORMAL"); it != gPrim.attributes.end()) {
                    fastgltf::iterateAccessorWithIndex<glm::vec3>(gltf, gltf.accessors[it->accessorIndex],
                                                                 [&](glm::vec3 norm, size_t idx)
                                                                 {
                                                                     vertices[idx].m_normal = norm;
                                                                 });
                }

                if (auto it = gPrim.findAttribute("TEXCOORD_0"); it != gPrim.attributes.end()) {
                    fastgltf::iterateAccessorWithIndex<glm::vec2>(gltf, gltf.accessors[it->accessorIndex],
                                                                 [&](glm::vec2 uv, size_t idx)
                                                                 {
                                                                     vertices[idx].m_texCoord = uv;
                                                                 });
                }

                // Load Tangents
                if (auto it = gPrim.findAttribute("TANGENT"); it != gPrim.attributes.end()) {
                    fastgltf::iterateAccessorWithIndex<glm::vec4>(gltf, gltf.accessors[it->accessorIndex],
                                                                 [&](glm::vec4 tan, size_t idx)
                                                                 {
                                                                     vertices[idx].m_tangent = tan;
                                                                 });
                }

                // Indices: widen to uint32_t regardless of source component type.
                if (gPrim.indicesAccessor.has_value())
                {
                    const auto& acc = gltf.accessors[gPrim.indicesAccessor.value()];
                    switch (acc.componentType)
                    {
                        case fastgltf::ComponentType::UnsignedByte:
                            fastgltf::iterateAccessor<std::uint8_t>(gltf, acc, [&](std::uint8_t v) { indices.push_back(v); });
                            break;
                        case fastgltf::ComponentType::UnsignedShort:
                            fastgltf::iterateAccessor<std::uint16_t>(gltf, acc, [&](std::uint16_t v) { indices.push_back(v); });
                            break;
                        default:
                            fastgltf::iterateAccessor<std::uint32_t>(gltf, acc, [&](std::uint32_t v) { indices.push_back(v); });
                            break;
                    }
                }
                else
                {
                    indices.resize(vertices.size());
                    for (size_t k = 0; k < vertices.size(); ++k)
                        indices[k] = static_cast<std::uint32_t>(k);
                }

                MeshPrimitive prim{};
                prim.mesh = renderer.createMesh(vertices, indices);
                prim.materialIndex = gPrim.materialIndex.has_value()
                                         ? static_cast<std::uint32_t>(gPrim.materialIndex.value())
                                         : 0;

                myNode.meshPrimitives.push_back(prim);
            }
        }

        model->m_rootNodes.clear();
        for (size_t i = 0; i < model->m_nodes.size(); ++i)
        {
            if (model->m_nodes[i].parentIndex == -1)
                model->m_rootNodes.push_back(static_cast<int>(i));
        }

        model->updateTransforms();
        return model;
    }

    void Model::updateTransforms()
    {
        std::function<void(int, const glm::mat4&)> updateNode =
            [&](int nodeIdx, const glm::mat4& parentMat)
        {
            auto& node = m_nodes[nodeIdx];

            const glm::mat4 localMat = node.localTransform.mat4();
            const glm::mat4 worldMat = parentMat * localMat;

            glm::vec3 s{}, t{}, skew{};
            glm::vec4 p{};
            glm::quat r{};

            glm::decompose(worldMat, s, r, t, skew, p);

            node.worldTransform.m_translation = t;
            node.worldTransform.m_rotation = r;
            node.worldTransform.m_scale = s;

            for (int child : node.children)
                updateNode(child, worldMat);
        };

        for (int root : m_rootNodes)
            updateNode(root, glm::mat4(1.0f));
    }
} // namespace pnkr::renderer::scene
</file>

<file path="src/renderer/scene/RHIScene.cpp">
#include "pnkr/renderer/scene/RHIScene.hpp"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer::scene {

    void RHIScene::update(float dt, int width, int height) {
        // Update camera controller
        (void)dt;
        // Note: This would need input from the application
        // m_cameraController.update(input, dt); // TODO: Pass input from application

        // Apply camera controller to camera
        m_cameraController.applyToCamera(m_camera);

        // Handle resize
        if (width != m_lastWidth || height != m_lastHeight) {
            // Update camera projection if needed
            m_lastWidth = width;
            m_lastHeight = height;
        }
    }

    void RHIScene::render(rhi::RHICommandBuffer* cmd) const {
        // Render skybox first (before opaque objects)
        if (m_skybox) {
            renderSkybox(cmd);
        }

        // Render all objects
        for (const auto& obj : m_objects) {
            if (!obj.mesh || !obj.pipe) {
                continue;
            }

            // Bind pipeline
            m_renderer.bindPipeline(cmd, obj.pipe);

            // Bind mesh
            m_renderer.bindMesh(cmd, obj.mesh);

            // Draw mesh
            m_renderer.drawMesh(cmd, obj.mesh);
        }
    }

    void RHIScene::loadSkybox(const std::vector<std::filesystem::path>& faces) {
        m_skybox = std::make_unique<Skybox>();
        m_skybox->init(m_renderer, faces);

        if (m_skybox) {
            core::Logger::info("Skybox loaded successfully");
        } else {
            core::Logger::error("Failed to load skybox");
        }
    }

    void RHIScene::renderSkybox(rhi::RHICommandBuffer* cmd) const {
        if (m_skybox) {
            // Render skybox with camera
            m_skybox->draw(cmd,  m_camera);
        }
    }

} // namespace pnkr::renderer::scene
</file>

<file path="src/renderer/scene/Skybox.cpp">
#include "pnkr/renderer/scene/Skybox.hpp"
#include "pnkr/core/logger.hpp"
#include "pnkr/rhi/rhi_shader.hpp" // Use the RHI shader abstraction
#include <glm/gtc/matrix_transform.hpp>

namespace pnkr::renderer::scene {

    void Skybox::init(RHIRenderer& renderer, const std::vector<std::filesystem::path>& faces) {
        m_renderer = &renderer;

        // 1. Load the cubemap texture
        // 'false' for sRGB because skyboxes are often HDR or handle gamma manually in shader,
        // but if these are standard JPG/PNGs, you might actually want 'true'.
        // Let's assume Linear data for now.
        m_cubemapHandle = m_renderer->createCubemap(faces, false);

        if (!m_cubemapHandle) {
            core::Logger::error("Failed to create skybox cubemap");
            return;
        }

        // 2. Create the pipeline immediately
        createSkyboxPipeline();

        core::Logger::info("Skybox initialized. Handle: {}", m_cubemapHandle.id);
    }

    void Skybox::destroy() {
        // In a real engine, you'd release the TextureHandle and PipelineHandle
        // back to the renderer here.
        m_cubemapHandle = INVALID_TEXTURE_HANDLE;
        m_pipeline = INVALID_PIPELINE_HANDLE;
    }

    void Skybox::createSkyboxPipeline() {
        // 1. Load Shaders using the RHI Shader abstraction
        // This handles reflection automatically
        auto vertShader = rhi::Shader::load(rhi::ShaderStage::Vertex, "shaders/skybox.vert.spv");
        auto fragShader = rhi::Shader::load(rhi::ShaderStage::Fragment, "shaders/skybox.frag.spv");

        if (!vertShader || !fragShader) {
            core::Logger::error("Failed to load skybox shaders");
            return;
        }

        // 2. Configure Pipeline
        // We use the RHI Pipeline Builder helper to make this clean
        rhi::RHIPipelineBuilder builder;

        builder.setShaders(vertShader.get(), fragShader.get())
               .setTopology(rhi::PrimitiveTopology::TriangleList)
               .setPolygonMode(rhi::PolygonMode::Fill)
               // Cull Front because we are inside the cube
               .setCullMode(rhi::CullMode::Front, true)
               // Depth: Lequal so it draws at the far plane (z=1.0)
               .enableDepthTest(false, rhi::CompareOp::LessOrEqual)
               .setNoBlend()
               .setColorFormat(m_renderer->getDrawColorFormat());
               // Note: If using dynamic rendering, depth format is also needed
               // Depending on RHI implementation, might need .setDepthFormat(...)

        // 3. Build
        // The builder automatically merges the Bindless Layout from the shader reflection
        // provided your shaders utilize the bindless sets (set=1).
        auto desc = builder.buildGraphics();

        // Ensure depth format is set explicitly if the builder didn't do it
        desc.depthFormat = m_renderer->getDrawDepthFormat();

        m_pipeline = m_renderer->createGraphicsPipeline(desc);
    }

    void Skybox::draw(rhi::RHICommandBuffer* cmd, const Camera& camera) {
        if (!m_cubemapHandle || !m_pipeline || !m_renderer) return;

        // 1. Get underlying RHI objects
        rhi::RHIPipeline* rhiPipe = m_renderer->getPipeline(m_pipeline);
        if (!rhiPipe) return;

        // 2. Bind Pipeline
        cmd->bindPipeline(rhiPipe);

        // 3. Bind Bindless Global Set (Set 1)
        if (m_renderer->isBindlessEnabled()) {
            // Retrieve raw pointer to the bindless descriptor set from the device
            void* rawSet = m_renderer->device()->getBindlessDescriptorSetNative();

            // Use the overload that takes a void* (native handle)
            cmd->bindDescriptorSet(rhiPipe, 1, rawSet);
        }

        // 4. Push Constants
        SkyboxPushConstants pc{};
        pc.view = glm::mat4(glm::mat3(camera.view())); // Remove translation
        pc.proj = camera.proj();
        pc.textureIndex = m_renderer->getTextureBindlessIndex(m_cubemapHandle);

        cmd->pushConstants(rhiPipe,
                          rhi::ShaderStage::Vertex | rhi::ShaderStage::Fragment,
                          0,
                          sizeof(pc),
                          &pc);

        // 5. Draw
        cmd->draw(3, 1, 0, 0);
    }

} // namespace pnkr::renderer::scene
</file>

<file path="src/renderer/ui/imgui_layer.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/ui/imgui_layer.hpp"

#include <imgui.h>
#include <imgui_impl_sdl3.h>
#include <imgui_impl_vulkan.h>

#include <array>
#include <stdexcept>

#include "pnkr/engine.hpp"

namespace pnkr::ui {

void ImGuiLayer::init(pnkr::renderer::Renderer& renderer, pnkr::platform::Window* window) {
    m_renderer = &renderer;

    // 1. Create Descriptor Pool for ImGui
    vk::DescriptorPoolSize pool_sizes[] = {
        { vk::DescriptorType::eSampler, 1000 },
        { vk::DescriptorType::eCombinedImageSampler, 1000 },
        { vk::DescriptorType::eSampledImage, 1000 },
        { vk::DescriptorType::eStorageImage, 1000 },
        { vk::DescriptorType::eUniformTexelBuffer, 1000 },
        { vk::DescriptorType::eStorageTexelBuffer, 1000 },
        { vk::DescriptorType::eUniformBuffer, 1000 },
        { vk::DescriptorType::eStorageBuffer, 1000 },
        { vk::DescriptorType::eUniformBufferDynamic, 1000 },
        { vk::DescriptorType::eStorageBufferDynamic, 1000 },
        { vk::DescriptorType::eInputAttachment, 1000 }
    };

    vk::DescriptorPoolCreateInfo pool_info = {};
    pool_info.flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet;
    pool_info.maxSets = 1000 * 2;
    pool_info.poolSizeCount = (uint32_t)std::size(pool_sizes);
    pool_info.pPoolSizes = pool_sizes;

    m_descriptorPool = renderer.device().createDescriptorPool(pool_info);

    // 2. Initialize ImGui Context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    ImGui::StyleColorsDark();

    // 3. Initialize SDL3 Backend
    ImGui_ImplSDL3_InitForVulkan(window->get());

    // 4. Initialize Vulkan Backend with Dynamic Rendering
    ImGui_ImplVulkan_InitInfo init_info = {};
    init_info.Instance = renderer.instance();
    init_info.PhysicalDevice = renderer.physicalDevice();
    init_info.Device = renderer.device();
    init_info.QueueFamily = renderer.graphicsQueueFamilyIndex();
    init_info.Queue = renderer.graphicsQueue();
    init_info.PipelineCache = nullptr;
    init_info.DescriptorPool = m_descriptorPool;
    init_info.Subpass = 0;
    init_info.MinImageCount = 2;
    init_info.ImageCount = 3; 
    init_info.MSAASamples = VK_SAMPLE_COUNT_1_BIT;
    init_info.Allocator = nullptr;
    init_info.CheckVkResultFn = nullptr;

    init_info.UseDynamicRendering = true;

    // Must match the format of the Swapchain where UI is rendered
    const VkFormat swapchainFormat = static_cast<VkFormat>(renderer.getSwapchainColorFormat());

    VkPipelineRenderingCreateInfoKHR pipeline_rendering_create_info = {};
    pipeline_rendering_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR;
    pipeline_rendering_create_info.colorAttachmentCount = 1;
    pipeline_rendering_create_info.pColorAttachmentFormats = &swapchainFormat;

    init_info.PipelineRenderingCreateInfo = pipeline_rendering_create_info;

    ImGui_ImplVulkan_Init(&init_info);

    // 5. Upload Fonts using a temporary command buffer
    vk::CommandPool cmdPool = renderer.commandPool();
    vk::CommandBufferAllocateInfo allocInfo{};
    allocInfo.commandPool = cmdPool;
    allocInfo.level = vk::CommandBufferLevel::ePrimary;
    allocInfo.commandBufferCount = 1;

    vk::CommandBuffer cmd = renderer.device().allocateCommandBuffers(allocInfo)[0];

    vk::CommandBufferBeginInfo beginInfo{};
    beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;
    cmd.begin(beginInfo);

    ImGui_ImplVulkan_CreateFontsTexture();

    cmd.end();

    vk::SubmitInfo submitInfo{};
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmd;

    renderer.graphicsQueue().submit(submitInfo, nullptr);
    renderer.device().waitIdle(); 

    renderer.device().freeCommandBuffers(cmdPool, cmd);
}

void ImGuiLayer::shutdown() {
    if (m_renderer) {
        m_renderer->device().waitIdle();
        ImGui_ImplVulkan_Shutdown();
        ImGui_ImplSDL3_Shutdown();
        ImGui::DestroyContext();
        m_renderer->device().destroyDescriptorPool(m_descriptorPool);
        m_renderer = nullptr;
    }
}

void ImGuiLayer::handleEvent(const SDL_Event& event) {
    ImGui_ImplSDL3_ProcessEvent(&event);
}

void ImGuiLayer::beginFrame() {
    ImGui_ImplVulkan_NewFrame();
    ImGui_ImplSDL3_NewFrame();
    ImGui::NewFrame();
}

void ImGuiLayer::endFrame() {
    // Generate draw data. Renderer::drawFrame() picks this up.
    ImGui::Render();
}

} // namespace pnkr::ui
</file>

<file path="src/renderer/vulkan/bindless/bindless_manager.cpp">
#include "pnkr/renderer/vulkan/bindless/bindless_manager.hpp"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer {

BindlessManager::BindlessManager(vk::Device device, vk::PhysicalDevice physicalDevice)
    : m_device(device)
{
    // Query device limits for descriptor counts
    vk::PhysicalDeviceDescriptorIndexingPropertiesEXT indexingProps;
    vk::PhysicalDeviceProperties2 props;
    props.pNext = &indexingProps;
    physicalDevice.getProperties2(&props);

    // Adjust limits based on device capabilities
    m_maxStorageBuffers =
        std::min(m_maxStorageBuffers,
                 indexingProps.maxDescriptorSetUpdateAfterBindStorageBuffers);
    m_maxSampledImages =
        std::min(m_maxSampledImages,
                 indexingProps.maxDescriptorSetUpdateAfterBindSampledImages);
    m_maxStorageImages =
        std::min(m_maxStorageImages,
                 indexingProps.maxDescriptorSetUpdateAfterBindStorageImages);
    m_maxCubemaps =
        std::min(m_maxCubemaps,
                 indexingProps.maxDescriptorSetUpdateAfterBindSampledImages);

    core::Logger::info("BindlessManager created with limits: "
              "StorageBuffers={}, SampledImages={}, StorageImages={}, Cubemaps={}",
              m_maxStorageBuffers, m_maxSampledImages, m_maxStorageImages, m_maxCubemaps);

    createDescriptorPool();
    createDescriptorLayout();
}

BindlessManager::~BindlessManager()
{
    if (m_pool) {
        m_device.destroyDescriptorPool(m_pool);
    }
    if (m_layout) {
        m_device.destroyDescriptorSetLayout(m_layout);
    }
}

void BindlessManager::createDescriptorPool()
{
    vk::DescriptorPoolSize poolSizes[4];
    poolSizes[0].type = vk::DescriptorType::eStorageBuffer;
    poolSizes[0].descriptorCount = m_maxStorageBuffers;

    poolSizes[1].type = vk::DescriptorType::eCombinedImageSampler;
    poolSizes[1].descriptorCount = m_maxSampledImages;

    poolSizes[2].type = vk::DescriptorType::eStorageImage;
    poolSizes[2].descriptorCount = m_maxStorageImages;

    poolSizes[3].type = vk::DescriptorType::eCombinedImageSampler;
    poolSizes[3].descriptorCount = m_maxCubemaps;

    vk::DescriptorPoolCreateInfo poolInfo{};
    poolInfo.poolSizeCount = 4;
    poolInfo.pPoolSizes = poolSizes;
    poolInfo.maxSets = 1;
    poolInfo.flags = vk::DescriptorPoolCreateFlagBits::eUpdateAfterBind;

    m_pool = m_device.createDescriptorPool(poolInfo);
}

void BindlessManager::createDescriptorLayout()
{
    // Array of bindings
    vk::DescriptorSetLayoutBinding bindings[4];

    // Storage buffers
    bindings[0].binding = 0;
    bindings[0].descriptorType = vk::DescriptorType::eStorageBuffer;
    bindings[0].descriptorCount = m_maxStorageBuffers;
    bindings[0].stageFlags = vk::ShaderStageFlagBits::eAll;
    bindings[0].pImmutableSamplers = nullptr;

    // Sampled images
    bindings[1].binding = 1;
    bindings[1].descriptorType = vk::DescriptorType::eCombinedImageSampler;
    bindings[1].descriptorCount = m_maxSampledImages;
    bindings[1].stageFlags = vk::ShaderStageFlagBits::eAll;
    bindings[1].pImmutableSamplers = nullptr;

    // Storage images
    bindings[2].binding = 2;
    bindings[2].descriptorType = vk::DescriptorType::eStorageImage;
    bindings[2].descriptorCount = m_maxStorageImages;
    bindings[2].stageFlags = vk::ShaderStageFlagBits::eAll;
    bindings[2].pImmutableSamplers = nullptr;

    // Cubemaps (Binding 3)
    bindings[3].binding = 3;
    bindings[3].descriptorType = vk::DescriptorType::eCombinedImageSampler;
    bindings[3].descriptorCount = m_maxCubemaps;
    bindings[3].stageFlags = vk::ShaderStageFlagBits::eAll;
    bindings[3].pImmutableSamplers = nullptr;

    // Enable update-after-bind for dynamic updates
    vk::DescriptorBindingFlags flags =
        vk::DescriptorBindingFlagBits::eUpdateAfterBind |
        vk::DescriptorBindingFlagBits::ePartiallyBound;

    vk::DescriptorBindingFlags bindingFlagsList[4] = {flags, flags, flags, flags};

    vk::DescriptorSetLayoutBindingFlagsCreateInfo bindingFlags{};
    bindingFlags.bindingCount = 4;
    bindingFlags.pBindingFlags = bindingFlagsList;

    vk::DescriptorSetLayoutCreateInfo layoutInfo{};
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;
    layoutInfo.pNext = &bindingFlags;
    layoutInfo.flags = vk::DescriptorSetLayoutCreateFlagBits::eUpdateAfterBindPool;

    m_layout = m_device.createDescriptorSetLayout(layoutInfo);

    vk::DescriptorSetAllocateInfo allocInfo{};
    allocInfo.descriptorPool = m_pool;
    allocInfo.descriptorSetCount = 1;
    allocInfo.pSetLayouts = &m_layout;

    std::vector<vk::DescriptorSet> sets = m_device.allocateDescriptorSets(allocInfo);
    m_descriptorSet = sets[0];
}

BindlessIndex BindlessManager::registerStorageBuffer(
    vk::Buffer buffer,
    vk::DeviceSize offset,
    vk::DeviceSize range)
{
    if (m_storageBufferCount >= m_maxStorageBuffers) {
        core::Logger::error("BindlessManager: Storage buffer limit exceeded!");
        return INVALID_BINDLESS_INDEX;
    }

    uint32_t index = m_storageBufferCount++;

    vk::DescriptorBufferInfo bufferInfo{};
    bufferInfo.buffer = buffer;
    bufferInfo.offset = offset;
    bufferInfo.range = range;

    vk::WriteDescriptorSet write{};
    write.dstSet = m_descriptorSet;
    write.dstBinding = 0;
    write.dstArrayElement = index;
    write.descriptorType = vk::DescriptorType::eStorageBuffer;
    write.descriptorCount = 1;
    write.pBufferInfo = &bufferInfo;

    m_device.updateDescriptorSets(write, nullptr);

    return BindlessIndex{index};
}

BindlessIndex BindlessManager::registerSampledImage(vk::ImageView view, vk::Sampler sampler)
{
    if (m_sampledImageCount >= m_maxSampledImages) {
        core::Logger::error("BindlessManager: Sampled image limit exceeded!");
        return INVALID_BINDLESS_INDEX;
    }

    uint32_t index = m_sampledImageCount++;

    vk::DescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
    imageInfo.imageView = view;
    imageInfo.sampler = sampler;

    vk::WriteDescriptorSet write{};
    write.dstSet = m_descriptorSet;
    write.dstBinding = 1;
    write.dstArrayElement = index;
    write.descriptorType = vk::DescriptorType::eCombinedImageSampler;
    write.descriptorCount = 1;
    write.pImageInfo = &imageInfo;

    m_device.updateDescriptorSets(write, nullptr);

    return BindlessIndex{index};
}

BindlessIndex BindlessManager::registerStorageImage(vk::ImageView view)
{
    if (m_storageImageCount >= m_maxStorageImages) {
        core::Logger::error("BindlessManager: Storage image limit exceeded!");
        return INVALID_BINDLESS_INDEX;
    }

    uint32_t index = m_storageImageCount++;

    vk::DescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = vk::ImageLayout::eGeneral;
    imageInfo.imageView = view;
    imageInfo.sampler = nullptr;

    vk::WriteDescriptorSet write{};
    write.dstSet = m_descriptorSet;
    write.dstBinding = 2;
    write.dstArrayElement = index;
    write.descriptorType = vk::DescriptorType::eStorageImage;
    write.descriptorCount = 1;
    write.pImageInfo = &imageInfo;

    m_device.updateDescriptorSets(write, nullptr);

    return BindlessIndex{index};
}

BindlessIndex BindlessManager::registerCubemap(vk::ImageView view, vk::Sampler sampler)
{
    if (m_cubemapCount >= m_maxCubemaps) {
        core::Logger::error("BindlessManager: Cubemap limit exceeded!");
        return INVALID_BINDLESS_INDEX;
    }

    uint32_t index = m_cubemapCount++;

    vk::DescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
    imageInfo.imageView = view;
    imageInfo.sampler = sampler;

    vk::WriteDescriptorSet write{};
    write.dstSet = m_descriptorSet;
    write.dstBinding = 3;  // Cubemap binding
    write.dstArrayElement = index;
    write.descriptorType = vk::DescriptorType::eCombinedImageSampler;
    write.descriptorCount = 1;
    write.pImageInfo = &imageInfo;

    m_device.updateDescriptorSets(write, nullptr);

    return BindlessIndex{index};
}

void BindlessManager::logStats() const
{
    core::Logger::info("BindlessManager Stats:");
    core::Logger::info("  Storage Buffers: {}/{}", m_storageBufferCount, m_maxStorageBuffers);
    core::Logger::info("  Sampled Images:  {}/{}", m_sampledImageCount, m_maxSampledImages);
    core::Logger::info("  Storage Images:  {}/{}", m_storageImageCount, m_maxStorageImages);
    core::Logger::info("  Cubemaps:         {}/{}", m_cubemapCount, m_maxCubemaps);
}

} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/image/vulkan_image.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/renderer/vulkan/image/vulkan_image.hpp"
#include "pnkr/renderer/vulkan/vulkan_device.hpp"
#include "pnkr/renderer/vulkan/vulkan_buffer.hpp"
#include "pnkr/core/logger.hpp"
#include <filesystem>
#include <cstring>
#include <stb_image.h>

namespace pnkr::renderer
{
    VulkanImage::VulkanImage(VmaAllocator allocator,
                             uint32_t width,
                             uint32_t height,
                             vk::Format format,
                             vk::ImageTiling tiling,
                             vk::ImageUsageFlags usage,
                             VmaMemoryUsage memoryUsage,
                             vk::ImageAspectFlags aspectFlags)
        : m_allocator(allocator)
          , m_format(format)
          , m_width(width)
          , m_height(height)
    {
        // Create image
        vk::ImageCreateInfo imageInfo{};
        imageInfo.imageType = vk::ImageType::e2D;
        imageInfo.extent.width = width;
        imageInfo.extent.height = height;
        imageInfo.extent.depth = 1;
        imageInfo.mipLevels = 1;
        imageInfo.arrayLayers = 1;
        imageInfo.format = format;
        imageInfo.tiling = tiling;
        imageInfo.initialLayout = vk::ImageLayout::eUndefined;
        imageInfo.usage = usage;
        imageInfo.samples = vk::SampleCountFlagBits::e1;
        imageInfo.sharingMode = vk::SharingMode::eExclusive;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = memoryUsage;

        VkImage rawImage;
        VkImageCreateInfo rawImageInfo = static_cast<VkImageCreateInfo>(imageInfo);

        if (vmaCreateImage(m_allocator, &rawImageInfo, &allocInfo,
                           &rawImage, &m_allocation, nullptr) != VK_SUCCESS)
        {
            throw std::runtime_error("Failed to create image");
        }

        m_image = rawImage;

        // Get device from allocator info
        VmaAllocatorInfo allocatorInfo;
        vmaGetAllocatorInfo(m_allocator, &allocatorInfo);
        m_device = allocatorInfo.device;

        // Create image view
        createImageView(m_device, aspectFlags);

        core::Logger::debug("Created VulkanImage {}x{} format={}", width, height,
                            vk::to_string(format));
    }

    VulkanImage::~VulkanImage()
    {
        destroy();
    }


    VulkanImage::VulkanImage(VulkanImage&& other) noexcept
        : m_allocator(other.m_allocator)
          , m_image(other.m_image)
          , m_view(other.m_view)
          , m_allocation(other.m_allocation)
          , m_format(other.m_format)
          , m_width(other.m_width)
          , m_height(other.m_height)
          , m_device(other.m_device)
    {
        other.m_allocator = nullptr;
        other.m_image = nullptr;
        other.m_view = nullptr;
        other.m_allocation = nullptr;
    }

    VulkanImage& VulkanImage::operator=(VulkanImage&& other) noexcept
    {
        if (this != &other)
        {
            destroy();

            m_allocator = other.m_allocator;
            m_image = other.m_image;
            m_view = other.m_view;
            m_allocation = other.m_allocation;
            m_format = other.m_format;
            m_width = other.m_width;
            m_height = other.m_height;
            m_device = other.m_device;

            other.m_allocator = nullptr;
            other.m_image = nullptr;
            other.m_view = nullptr;
            other.m_allocation = nullptr;
        }
        return *this;
    }


    VulkanImage VulkanImage::createFromFile(const VulkanDevice& device,
                                            const std::filesystem::path& filepath,
                                            bool srgb)
    {
        int w, h, c;
        stbi_uc* pixels = stbi_load(filepath.string().c_str(), &w, &h, &c, STBI_rgb_alpha);
        if (!pixels) throw std::runtime_error("Failed load");

        VulkanImage img = createFromMemory(device, pixels, w, h, srgb);
        stbi_image_free(pixels);
        return img;
    }

    VulkanImage VulkanImage::createFromMemory(const VulkanDevice& device,
                                              const unsigned char* pixels,
                                              int width,
                                              int height,
                                              bool srgb)
    {
        vk::DeviceSize imageSize = width * height * 4; // Assume RGBA
        const vk::Format format = srgb
                                      ? vk::Format::eR8G8B8A8Srgb
                                      : vk::Format::eR8G8B8A8Unorm;

        // Create staging buffer
        VulkanBuffer stagingBuffer(
            device.allocator(),
            imageSize,
            vk::BufferUsageFlagBits::eTransferSrc,
            VMA_MEMORY_USAGE_CPU_ONLY,
            VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT
        );

        // Copy pixel data to staging buffer
        void* data = stagingBuffer.map();
        std::memcpy(data, pixels, imageSize);
        stagingBuffer.unmap();


        // Create image
        VulkanImage image(
            device.allocator(),
            static_cast<uint32_t>(width),
            static_cast<uint32_t>(height),
            format,
            vk::ImageTiling::eOptimal,
            vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled,
            VMA_MEMORY_USAGE_GPU_ONLY
        );

        // Transition and copy
        device.immediateSubmit([&](vk::CommandBuffer cmd)
        {
            // Transition to transfer destination
            image.transitionLayout(
                cmd,
                vk::ImageLayout::eUndefined,
                vk::ImageLayout::eTransferDstOptimal,
                vk::PipelineStageFlagBits2::eNone,
                vk::PipelineStageFlagBits2::eTransfer
            );

            // Copy buffer to image
            vk::BufferImageCopy region{};
            region.bufferOffset = 0;
            region.bufferRowLength = 0;
            region.bufferImageHeight = 0;
            region.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
            region.imageSubresource.mipLevel = 0;
            region.imageSubresource.baseArrayLayer = 0;
            region.imageSubresource.layerCount = 1;
            region.imageOffset = vk::Offset3D{0, 0, 0};
            region.imageExtent = vk::Extent3D{
                static_cast<uint32_t>(width),
                static_cast<uint32_t>(height),
                1
            };

            cmd.copyBufferToImage(
                stagingBuffer.buffer(),
                image.image(),
                vk::ImageLayout::eTransferDstOptimal,
                region
            );

            // Transition to shader read
            image.transitionLayout(
                cmd,
                vk::ImageLayout::eTransferDstOptimal,
                vk::ImageLayout::eShaderReadOnlyOptimal,
                vk::PipelineStageFlagBits2::eTransfer,
                vk::PipelineStageFlagBits2::eFragmentShader
            );
        });

        return image;
    }

    void VulkanImage::transitionLayout(vk::CommandBuffer cmd,
                                       vk::ImageLayout oldLayout,
                                       vk::ImageLayout newLayout,
                                       vk::PipelineStageFlags2 srcStage,
                                       vk::PipelineStageFlags2 dstStage)
    {
        vk::ImageMemoryBarrier2 barrier{};
        barrier.oldLayout = oldLayout;
        barrier.newLayout = newLayout;
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.image = m_image;

        // Detect Aspect
        if (newLayout == vk::ImageLayout::eDepthAttachmentOptimal ||
            newLayout == vk::ImageLayout::eDepthStencilAttachmentOptimal)
        {
            barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eDepth;
        }
        else
        {
            barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
        }

        barrier.subresourceRange.baseMipLevel = 0;
        barrier.subresourceRange.levelCount = 1;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = 1;

        // Configure access masks
        if (oldLayout == vk::ImageLayout::eUndefined &&
            newLayout == vk::ImageLayout::eTransferDstOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlagBits2::eNone;
            barrier.dstAccessMask = vk::AccessFlagBits2::eTransferWrite;
        }
        else if (oldLayout == vk::ImageLayout::eTransferDstOptimal &&
            newLayout == vk::ImageLayout::eShaderReadOnlyOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlagBits2::eTransferWrite;
            barrier.dstAccessMask = vk::AccessFlagBits2::eShaderRead;
        }

        else if (oldLayout == vk::ImageLayout::eUndefined &&
            newLayout == vk::ImageLayout::eColorAttachmentOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlagBits2::eNone;
            barrier.dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
        }
        else if (oldLayout == vk::ImageLayout::eUndefined &&
            newLayout == vk::ImageLayout::eDepthAttachmentOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlagBits2::eNone;
            barrier.dstAccessMask = vk::AccessFlagBits2::eDepthStencilAttachmentWrite;
        }
        else if (oldLayout == vk::ImageLayout::eColorAttachmentOptimal &&
            newLayout == vk::ImageLayout::eTransferSrcOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
            barrier.dstAccessMask = vk::AccessFlagBits2::eTransferRead;
        }
        else
        {
            throw std::runtime_error("Unsupported layout transition");
        }

        barrier.srcStageMask = srcStage;
        barrier.dstStageMask = dstStage;

        vk::DependencyInfo depInfo{};
        depInfo.dependencyFlags = vk::DependencyFlags{};
        depInfo.imageMemoryBarrierCount = 1;
        depInfo.pImageMemoryBarriers = &barrier;

        cmd.pipelineBarrier2(depInfo);
    }


    void VulkanImage::createImageView(vk::Device device, vk::ImageAspectFlags aspectFlags)
    {
        vk::ImageViewCreateInfo viewInfo{};
        viewInfo.image = m_image;
        viewInfo.viewType = vk::ImageViewType::e2D;
        viewInfo.format = m_format;
        viewInfo.subresourceRange.aspectMask = aspectFlags;
        viewInfo.subresourceRange.baseMipLevel = 0;
        viewInfo.subresourceRange.levelCount = 1;
        viewInfo.subresourceRange.baseArrayLayer = 0;
        viewInfo.subresourceRange.layerCount = 1;

        m_view = device.createImageView(viewInfo);
    }


    void VulkanImage::destroy() noexcept
    {
        if (m_view)
        {
            m_device.destroyImageView(m_view);
            m_view = nullptr;
        }

        if (m_image && m_allocator)
        {
            vmaDestroyImage(m_allocator, m_image, m_allocation);
            m_image = nullptr;
            m_allocation = nullptr;
        }
    }
} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/image/vulkan_sampler.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/renderer/vulkan/image/vulkan_sampler.hpp"

namespace pnkr::renderer {

    VulkanSampler::VulkanSampler(vk::Device device,
                                 vk::Filter magFilter,
                                 vk::Filter minFilter,
                                 vk::SamplerAddressMode addressMode)
      : m_device(device)
    {
        vk::SamplerCreateInfo samplerInfo{};
        samplerInfo.magFilter = magFilter;
        samplerInfo.minFilter = minFilter;
        samplerInfo.addressModeU = addressMode;
        samplerInfo.addressModeV = addressMode;
        samplerInfo.addressModeW = addressMode;
        samplerInfo.anisotropyEnable = false;
        samplerInfo.maxAnisotropy = 16.0f;
        samplerInfo.borderColor = vk::BorderColor::eIntOpaqueBlack;
        samplerInfo.unnormalizedCoordinates = VK_FALSE;
        samplerInfo.compareEnable = VK_FALSE;
        samplerInfo.compareOp = vk::CompareOp::eAlways;
        samplerInfo.mipmapMode = vk::SamplerMipmapMode::eLinear;
        samplerInfo.mipLodBias = 0.0f;
        samplerInfo.minLod = 0.0f;
        samplerInfo.maxLod = 0.0f;

        m_sampler = device.createSampler(samplerInfo);
    }

    VulkanSampler::~VulkanSampler() {
        destroy();
    }

    VulkanSampler::VulkanSampler(VulkanSampler&& other) noexcept
      : m_device(other.m_device)
      , m_sampler(other.m_sampler)
    {
        other.m_sampler = nullptr;
    }

    VulkanSampler& VulkanSampler::operator=(VulkanSampler&& other) noexcept {
        if (this != &other) {
            destroy();
            m_device = other.m_device;
            m_sampler = other.m_sampler;
            other.m_sampler = nullptr;
        }
        return *this;
    }

    void VulkanSampler::destroy() noexcept {
        if (m_sampler) {
            m_device.destroySampler(m_sampler);
            m_sampler = nullptr;
        }
    }

} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/pipeline/compute_pipeline.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/renderer/vulkan/pipeline/compute_pipeline.hpp"
#include "pnkr/renderer/renderer.hpp"
#include "pnkr/core/logger.hpp"
#include <fstream>

namespace pnkr::renderer {

    // --- Helper: Read File ---
    static std::vector<char> readFile(const std::filesystem::path& filename) {
        std::ifstream file(filename, std::ios::ate | std::ios::binary);
        if (!file.is_open()) {
            throw std::runtime_error("Failed to open file: " + filename.string());
        }
        size_t fileSize = (size_t)file.tellg();
        std::vector<char> buffer(fileSize);
        file.seekg(0);
        file.read(buffer.data(), fileSize);
        return buffer;
    }

    // --- ComputePipeline ---
    ComputePipeline::ComputePipeline(vk::Device device, vk::Pipeline pipeline, vk::PipelineLayout layout)
        : m_device(device), m_pipeline(pipeline), m_layout(layout) {}

    ComputePipeline::~ComputePipeline() {
        if (m_device) {
            m_device.destroyPipeline(m_pipeline);
            m_device.destroyPipelineLayout(m_layout);
        }
    }

    // --- ComputePipelineBuilder ---
    ComputePipelineBuilder::ComputePipelineBuilder(Renderer& renderer) : m_renderer(renderer) {}

    ComputePipelineBuilder& ComputePipelineBuilder::setShader(const std::filesystem::path& path) {
        m_shaderPath = path;
        return *this;
    }

    ComputePipelineBuilder& ComputePipelineBuilder::addDescriptorSetLayout(vk::DescriptorSetLayout layout) {
        m_layouts.push_back(layout);
        return *this;
    }

    ComputePipelineBuilder& ComputePipelineBuilder::setPushConstantSize(uint32_t size) {
        m_pushConstantSize = size;
        return *this;
    }

    std::unique_ptr<ComputePipeline> ComputePipelineBuilder::build() {
        auto device = m_renderer.device();

        // 1. Create Shader Module
        auto code = readFile(m_shaderPath);
        vk::ShaderModuleCreateInfo createInfo{};
        createInfo.codeSize = code.size();
        createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());
        vk::ShaderModule shaderModule = device.createShaderModule(createInfo);

        // 2. Pipeline Layout
        vk::PipelineLayoutCreateInfo layoutInfo{};
        layoutInfo.setLayoutCount = static_cast<uint32_t>(m_layouts.size());
        layoutInfo.pSetLayouts = m_layouts.data();

        vk::PushConstantRange pcRange{};
        if (m_pushConstantSize > 0) {
            pcRange.stageFlags = vk::ShaderStageFlagBits::eCompute;
            pcRange.offset = 0;
            pcRange.size = m_pushConstantSize;
            layoutInfo.pushConstantRangeCount = 1;
            layoutInfo.pPushConstantRanges = &pcRange;
        }

        vk::PipelineLayout pipelineLayout = device.createPipelineLayout(layoutInfo);

        // 3. Compute Pipeline
        vk::ComputePipelineCreateInfo pipelineInfo{};
        pipelineInfo.layout = pipelineLayout;
        pipelineInfo.stage.stage = vk::ShaderStageFlagBits::eCompute;
        pipelineInfo.stage.module = shaderModule;
        pipelineInfo.stage.pName = "main";

        auto result = device.createComputePipeline(nullptr, pipelineInfo);
        if (result.result != vk::Result::eSuccess) {
            throw std::runtime_error("Failed to create compute pipeline");
        }

        device.destroyShaderModule(shaderModule);

        return std::make_unique<ComputePipeline>(device, result.value, pipelineLayout);
    }
}
</file>

<file path="src/renderer/vulkan/pipeline/pipeline_builder.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/renderer/vulkan/pipeline/PipelineBuilder.h"
#include "pnkr/renderer/renderer.hpp"
#include "pnkr/renderer/vulkan/pipeline/PipelineConfig.h" // Reuse existing config struct internally if needed

namespace pnkr::renderer
{
    PipelineBuilder::PipelineBuilder(Renderer& renderer) : m_renderer(renderer)
    {
        m_colorFormat = m_renderer.getDrawColorFormat();
        m_depthFormat = m_renderer.getDrawDepthFormat();
    }

    PipelineBuilder& PipelineBuilder::setRenderingFormats(vk::Format color, vk::Format depth)
    {
        m_colorFormat = color;
        m_depthFormat = depth;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setPushConstantsShaderFlags(vk::ShaderStageFlags pushConstantsShaderStages)
    {
        m_pushConstantStages = pushConstantsShaderStages;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::useBindless()
    {
        m_useBindless = true;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setShaders(const std::filesystem::path& vertSpv,
                                                 const std::filesystem::path& fragSpv)
    {
        m_vertPath = vertSpv;
        m_fragPath = fragSpv;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setInputTopology(vk::PrimitiveTopology topology)
    {
        m_topology = topology;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setPolygonMode(vk::PolygonMode mode)
    {
        m_polygonMode = mode;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setCullMode(vk::CullModeFlags cullMode, vk::FrontFace frontFace)
    {
        m_cullMode = cullMode;
        m_frontFace = frontFace;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setLineWidth(float width)
    {
        m_lineWidth = width;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::enableDepthTest(bool enableWrite, vk::CompareOp op)
    {
        m_depthState.testEnable = true;
        m_depthState.writeEnable = enableWrite;
        m_depthState.compareOp = op;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::disableDepthTest()
    {
        m_depthState.testEnable = false;
        m_depthState.writeEnable = false;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::enableAlphaBlending()
    {
        m_blendState.enable = true;
        m_blendState.srcColor = vk::BlendFactor::eSrcAlpha;
        m_blendState.dstColor = vk::BlendFactor::eOneMinusSrcAlpha;
        m_blendState.colorOp = vk::BlendOp::eAdd;
        m_blendState.srcAlpha = vk::BlendFactor::eOne;
        m_blendState.dstAlpha = vk::BlendFactor::eZero;
        m_blendState.alphaOp = vk::BlendOp::eAdd;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::enableAdditiveBlending()
    {
        m_blendState.enable = true;
        m_blendState.srcColor = vk::BlendFactor::eOne;
        m_blendState.dstColor = vk::BlendFactor::eOne;
        m_blendState.colorOp = vk::BlendOp::eAdd;
        m_blendState.srcAlpha = vk::BlendFactor::eOne;
        m_blendState.dstAlpha = vk::BlendFactor::eZero;
        m_blendState.alphaOp = vk::BlendOp::eAdd;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::disableBlending()
    {
        m_blendState.enable = false;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setPushConstantSize(uint32_t size)
    {
        m_pushConstantSize = size;
        return *this;
    }

    PipelineBuilder& PipelineBuilder::addDescriptorSetLayout(vk::DescriptorSetLayout layout) {
        m_descriptorLayouts.push_back(layout);
        return *this;
    }

    PipelineBuilder& PipelineBuilder::setVertexInput(const VertexInputDescription& description) {
        m_vertexInput = description;
        return *this;
    }


    PipelineHandle PipelineBuilder::build()
    {

        PipelineConfig cfg{};
        cfg.m_vertSpvPath = m_vertPath;
        cfg.m_fragSpvPath = m_fragPath;

        // Descriptor set layouts
        cfg.m_descriptorSetLayouts = m_descriptorLayouts;

        if (m_useBindless) {
            auto bindlessLayout = m_renderer.getBindlessLayout();
            if (bindlessLayout) {
                cfg.m_descriptorSetLayouts.push_back(bindlessLayout);
            }
        }


        cfg.m_vertexInput = m_vertexInput;
        cfg.m_cullMode = m_cullMode;
        cfg.m_frontFace = m_frontFace;

        cfg.m_colorFormat = m_colorFormat;
        cfg.m_depthFormat = m_depthFormat;

        cfg.m_depth.testEnable = m_depthState.testEnable;
        cfg.m_depth.writeEnable = m_depthState.writeEnable;
        cfg.m_depth.compareOp = m_depthState.compareOp;

        cfg.m_pushConstantSize = m_pushConstantSize; // Add this to Config too
        cfg.m_pushConstantStages = m_pushConstantStages;
        return m_renderer.createPipeline(cfg);
    }
} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_buffer.cpp">
#include "pnkr/renderer/vulkan/vulkan_buffer.hpp"
#include "pnkr/renderer/vulkan/vulkan_device.hpp"

#include <stdexcept>
#include <utility>

namespace pnkr::renderer {

VulkanBuffer::VulkanBuffer(VmaAllocator allocator, vk::DeviceSize size,
                           vk::BufferUsageFlags usage,
                           VmaMemoryUsage memoryUsage,
                           VmaAllocationCreateFlags allocFlags)
    : m_allocator(allocator), m_size(size) {

  if (!m_allocator)
    throw std::runtime_error("[VulkanBuffer] allocator is null");
  if (m_size == 0)
    throw std::runtime_error("[VulkanBuffer] size must be > 0");

  VkBufferCreateInfo bufferInfo{};
  bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
  bufferInfo.size = static_cast<VkDeviceSize>(m_size);
  bufferInfo.usage = static_cast<VkBufferUsageFlags>(usage);
  bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

  VmaAllocationCreateInfo allocInfo{};
  allocInfo.usage = memoryUsage;
  allocInfo.flags = allocFlags;
  VkBuffer rawBuffer;
  VkResult res = vmaCreateBuffer(m_allocator, &bufferInfo, &allocInfo,
                                 &rawBuffer, &m_allocation, nullptr);

  m_buffer = vk::Buffer(rawBuffer);

  if (res != VK_SUCCESS) {
    throw std::runtime_error("[VulkanBuffer] vmaCreateBuffer failed");
  }
}

VulkanBuffer::~VulkanBuffer() { destroy(); }

VulkanBuffer::VulkanBuffer(VulkanBuffer &&other) noexcept {
  *this = std::move(other);
}

VulkanBuffer &VulkanBuffer::operator=(VulkanBuffer &&other) noexcept {
  if (this == &other)
    return *this;

  destroy();

  m_allocator = other.m_allocator;
  m_buffer = other.m_buffer;
  m_allocation = other.m_allocation;
  m_size = other.m_size;
  m_mapped = other.m_mapped;

  other.m_allocator = nullptr;
  other.m_buffer = VK_NULL_HANDLE;
  other.m_allocation = nullptr;
  other.m_size = 0;
  other.m_mapped = nullptr;

  return *this;
}

VulkanBuffer VulkanBuffer::CreateDeviceLocalAndUpload(
    const VulkanDevice &device, const void *data, const vk::DeviceSize size,
    const vk::BufferUsageFlags finalUsage) {
  if (!data)
    throw std::runtime_error("[VulkanBuffer] upload: data is null");
  if (size == 0)
    throw std::runtime_error("[VulkanBuffer] upload: size must be > 0");

  // 1) Staging buffer (CPU-visible)
  VulkanBuffer staging(device.allocator(), size,
                       vk::BufferUsageFlagBits::eTransferSrc,
                       VMA_MEMORY_USAGE_AUTO,
                       VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
                           VMA_ALLOCATION_CREATE_MAPPED_BIT);

  // staging.map() is valid due to MAPPED_BIT, but keep it uniform:
  std::memcpy(staging.map(), data, static_cast<std::size_t>(size));
  staging.unmap();

  // 2) GPU buffer (device-local preferred)
  VulkanBuffer gpu(device.allocator(), size,
                   vk::BufferUsageFlagBits::eTransferDst | finalUsage,
                   VMA_MEMORY_USAGE_AUTO);

  // 3) Copy
  device.immediateSubmit([&](vk::CommandBuffer cmd) {
    vk::BufferCopy copy{};
    copy.size = size;
    cmd.copyBuffer(staging.buffer(), gpu.buffer(), 1, &copy);
  });

  return gpu;
}

void VulkanBuffer::destroy() noexcept {
  if (m_mapped) {
    vmaUnmapMemory(m_allocator, m_allocation);
    m_mapped = nullptr;
  }

  if (m_buffer != VK_NULL_HANDLE && m_allocation) {
    vmaDestroyBuffer(m_allocator, m_buffer, m_allocation);
    m_buffer = VK_NULL_HANDLE;
    m_allocation = nullptr;
  }
}

void *VulkanBuffer::map() {
  if (!m_allocation)
    throw std::runtime_error("[VulkanBuffer] map: no allocation");
  if (m_mapped)
    return m_mapped;

  void *data = nullptr;
  VkResult res = vmaMapMemory(m_allocator, m_allocation, &data);
  if (res != VK_SUCCESS || !data) {
    throw std::runtime_error("[VulkanBuffer] vmaMapMemory failed");
  }
  m_mapped = data;
  return m_mapped;
}

void VulkanBuffer::unmap() {
  if (!m_mapped)
    return;
  vmaUnmapMemory(m_allocator, m_allocation);
  m_mapped = nullptr;
}

} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_command_buffer.cpp">
#include "pnkr/renderer/vulkan/vulkan_command_buffer.hpp"
#include "pnkr/core/logger.hpp"

#include <stdexcept>

#include "pnkr/renderer/vulkan/vulkan_device.hpp"

namespace pnkr::renderer {
VulkanCommandBuffer::VulkanCommandBuffer(const VulkanDevice &vkDevice)
    : VulkanCommandBuffer(vkDevice.device(), vkDevice.graphicsQueueFamily(),
                          vkDevice.framesInFlight()) {}

VulkanCommandBuffer::~VulkanCommandBuffer() {
  if (!m_device)
    return;

  // Make sure GPU isn't still using the resources we're about to destroy.
  // In a more advanced engine you'd wait per-fence or on shutdown in Renderer.
  try {
    m_device.waitIdle();
  } catch (...) {
  }

  if (m_pool)
    m_device.destroyCommandPool(m_pool);
}

void VulkanCommandBuffer::advanceFrame() {
  m_frameIndex = (m_frameIndex + 1) % m_frames;
}

vk::CommandBuffer VulkanCommandBuffer::begin(uint32_t frame) {
  if (frame >= m_frames)
    throw std::runtime_error("[VulkanCommandBuffer] frame index out of range");

  m_cmd[frame].reset(vk::CommandBufferResetFlagBits::eReleaseResources);

  vk::CommandBufferBeginInfo cbbi{};
  cbbi.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;

  auto cmd = m_cmd[frame];
  cmd.begin(cbbi);

  return cmd;
}

void VulkanCommandBuffer::end(uint32_t frame) {
  if (frame >= m_frames)
    throw std::runtime_error("[VulkanCommandBuffer] frame index out of range");
  m_cmd[frame].end();
}

void VulkanCommandBuffer::submit(uint32_t frame, vk::Queue graphicsQueue,
                                 vk::Semaphore imageAvailableSemaphore,
                                 vk::Semaphore renderFinishedSemaphore,
                                 vk::Fence signalFence,
                                 vk::PipelineStageFlags waitStage) const {
  if (frame >= m_frames)
    throw std::runtime_error("[VulkanCommandBuffer] frame index out of range");

  const vk::CommandBuffer cmd = m_cmd[frame];

  const vk::Semaphore imageAvailable = imageAvailableSemaphore;
  const vk::Semaphore renderFinished = renderFinishedSemaphore;

  vk::SubmitInfo submit{};

  // Wait on image acquisition before executing command buffer
  submit.waitSemaphoreCount = 1;
  submit.pWaitSemaphores = &imageAvailable;
  submit.pWaitDstStageMask = &waitStage;

  submit.commandBufferCount = 1;
  submit.pCommandBuffers = &cmd;

  // Signal that rendering is finished for present
  submit.signalSemaphoreCount = 1;
  submit.pSignalSemaphores = &renderFinished;

  try {
    // vulkan.hpp submit takes (ArrayProxy, Fence). Pass single submitInfo
    // directly.
    graphicsQueue.submit(submit, signalFence);
  } catch (const vk::SystemError &e) {
    throw std::runtime_error(
        std::string("[VulkanCommandBuffer] queue submit failed: ") + e.what());
  }
}

void VulkanCommandBuffer::createPool(uint32_t graphicsQueueFamilyIndex) {
  vk::CommandPoolCreateInfo cpci{};
  cpci.queueFamilyIndex = graphicsQueueFamilyIndex;

  // Allow resetting individual command buffers (optional), but well reset pool
  // each frame anyway.
  cpci.flags = vk::CommandPoolCreateFlagBits::eResetCommandBuffer;

  m_pool = m_device.createCommandPool(cpci);
  if (!m_pool)
    throw std::runtime_error("[VulkanCommandBuffer] createCommandPool failed");
}

void VulkanCommandBuffer::allocateBuffers() {
  vk::CommandBufferAllocateInfo cbai{};
  cbai.commandPool = m_pool;
  cbai.level = vk::CommandBufferLevel::ePrimary;
  cbai.commandBufferCount = m_frames;

  m_cmd = m_device.allocateCommandBuffers(cbai);
  if (m_cmd.size() != m_frames)
    throw std::runtime_error(
        "[VulkanCommandBuffer] allocateCommandBuffers returned wrong count");
}

VulkanCommandBuffer::VulkanCommandBuffer(vk::Device device,
                                         uint32_t graphicsQueueFamilyIndex,
                                         uint32_t framesInFlight)
    : m_device(device), m_frames(framesInFlight) {
  if (!m_device)
    throw std::runtime_error("[VulkanCommandBuffer] device is null");
  if (m_frames == 0)
    throw std::runtime_error(
        "[VulkanCommandBuffer] framesInFlight must be > 0");

  createPool(graphicsQueueFamilyIndex);
  allocateBuffers();

  core::Logger::info("[VulkanCommandBuffer] Created (framesInFlight={})",
                           m_frames);
}

} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_context.cpp">
//
// Created by Jose on 12/12/2025.
//

#include "pnkr/renderer/vulkan/vulkan_context.hpp"

#include "pnkr/core/logger.hpp"
#include "pnkr/platform/window.hpp"

#include <SDL3/SDL_vulkan.h>
#include <vector>

namespace pnkr::renderer {
#ifndef NDEBUG
static VKAPI_ATTR vk::Bool32 VKAPI_CALL DebugCallback(
    vk::DebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    vk::DebugUtilsMessageTypeFlagsEXT,
    const vk::DebugUtilsMessengerCallbackDataEXT *pCallbackData, void *) {
  using core::Logger;

  const char *msg =
      pCallbackData->pMessage ? pCallbackData->pMessage : "(null)";

  if (messageSeverity & vk::DebugUtilsMessageSeverityFlagBitsEXT::eError) {
    Logger::error("[Vulkan] {}", msg);
  } else if (messageSeverity &
             vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning) {
    Logger::warn("[Vulkan] {}", msg);
  } else if (messageSeverity &
             vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo) {
    Logger::info("[Vulkan] {}", msg);
  } else {
    Logger::debug("[Vulkan] {}", msg);
  }

  return VK_FALSE;
}
#endif

void VulkanContext::initDispatcherPreInstance() {
  auto getInstanceProcAddr =
      m_dynamicLoader.getProcAddress<PFN_vkGetInstanceProcAddr>(
          "vkGetInstanceProcAddr");
  if (!getInstanceProcAddr) {
    throw std::runtime_error("Failed to load vkGetInstanceProcAddr");
  }

  VULKAN_HPP_DEFAULT_DISPATCHER.init(getInstanceProcAddr);

  m_vkGetInstanceProcAddr =
      getInstanceProcAddr; // add a member PFN_vkGetInstanceProcAddr
}

void VulkanContext::initDispatcherPostInstance() {
  VULKAN_HPP_DEFAULT_DISPATCHER.init(m_instance);

  // Build the per-context dynamic dispatcher
  m_dld =
      vk::detail::DispatchLoaderDynamic(m_instance, m_vkGetInstanceProcAddr);
}

void VulkanContext::initDispatcherPostDevice(vk::Device device) {
  VULKAN_HPP_DEFAULT_DISPATCHER.init(device);

  auto getDeviceProcAddr =
      m_dynamicLoader.getProcAddress<PFN_vkGetDeviceProcAddr>(
          "vkGetDeviceProcAddr");
  if (!getDeviceProcAddr) {
    throw std::runtime_error("Failed to load vkGetDeviceProcAddr");
  }

  m_dld = vk::detail::DispatchLoaderDynamic(m_instance, m_vkGetInstanceProcAddr,
                                            device, getDeviceProcAddr);
}

VulkanContext::VulkanContext(const platform::Window &window) {
  // Load instance-level function pointers (DebugUtils lives here).
  initDispatcherPreInstance();
  createInstance(window);

  initDispatcherPostInstance();

#ifndef NDEBUG
  setupDebugMessenger();
#endif

  createSurface(window);

  core::Logger::info("VulkanContext created (instance + surface).");
}

VulkanContext::~VulkanContext() {
  // Destroy in reverse order of creation.
#ifndef NDEBUG
  if (m_debugMessenger) {
    m_instance.destroyDebugUtilsMessengerEXT(m_debugMessenger, nullptr,
                                             VULKAN_HPP_DEFAULT_DISPATCHER);
    m_debugMessenger = nullptr;
  }
#endif

  if (m_surface) {
    m_instance.destroySurfaceKHR(m_surface, nullptr,
                                 VULKAN_HPP_DEFAULT_DISPATCHER);
    m_surface = nullptr;
  }

  m_instance.destroy(nullptr, VULKAN_HPP_DEFAULT_DISPATCHER);
  m_instance = nullptr;
}

void VulkanContext::createInstance(const platform::Window &window) {
  (void)window;
  // Query required instance extensions from SDL.
  unsigned int extCount = 0;
  const char *const *sdlExts = SDL_Vulkan_GetInstanceExtensions(&extCount);
  if (!sdlExts || extCount == 0) {
    throw std::runtime_error(
        "SDL_Vulkan_GetInstanceExtensions returned no extensions");
  }

  std::vector<const char *> extensions(sdlExts, sdlExts + extCount);

#ifndef NDEBUG
  extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
#endif
#ifndef NDEBUG
  // Needed for VK_EXT_debug_utils messenger.
  extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
#endif

  // Validation layers in debug builds.
  std::vector<const char *> layers;
#ifndef NDEBUG
  layers.push_back("VK_LAYER_KHRONOS_validation");
#endif

  vk::ApplicationInfo appInfo{};
  appInfo.pApplicationName = "PNKR";
  appInfo.applicationVersion = VK_MAKE_VERSION(0, 1, 0);
  appInfo.pEngineName = "pnkr_engine";
  appInfo.engineVersion = VK_MAKE_VERSION(0, 1, 0);
  appInfo.apiVersion = VK_API_VERSION_1_3;

#ifndef NDEBUG
  // Hook the debug callback as early as possible via pNext.
  vk::DebugUtilsMessengerCreateInfoEXT debugCreateInfo{};
  debugCreateInfo.messageSeverity =
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eError |
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo;
  debugCreateInfo.messageType =
      vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |
      vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |
      vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance;
  debugCreateInfo.pfnUserCallback = DebugCallback;
#endif

  vk::InstanceCreateInfo createInfo{};
  createInfo.pApplicationInfo = &appInfo;
  createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
  createInfo.ppEnabledExtensionNames = extensions.data();
  createInfo.enabledLayerCount = static_cast<uint32_t>(layers.size());
  createInfo.ppEnabledLayerNames = layers.empty() ? nullptr : layers.data();

#ifndef NDEBUG
  createInfo.pNext = &debugCreateInfo;
#endif

  m_instance =
      vk::createInstance(createInfo, nullptr, VULKAN_HPP_DEFAULT_DISPATCHER);

  core::Logger::info(
      "Vulkan instance created ({} extensions, {} layers).", extensions.size(),
      layers.size());
}

void VulkanContext::createSurface(const platform::Window &window) {
  VkSurfaceKHR rawSurface = VK_NULL_HANDLE;

  if (!SDL_Vulkan_CreateSurface(window.get(),
                                static_cast<VkInstance>(m_instance), nullptr,
                                &rawSurface)) {
    throw std::runtime_error(std::string("SDL_Vulkan_CreateSurface failed: ") +
                             SDL_GetError());
  }

  m_surface = vk::SurfaceKHR(rawSurface);
  core::Logger::info("SDL Vulkan surface created.");
}

#ifndef NDEBUG
void VulkanContext::setupDebugMessenger() {
  vk::DebugUtilsMessengerCreateInfoEXT createInfo{};
  createInfo.messageSeverity =
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eError |
      vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo;
  createInfo.messageType = vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |
                           vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |
                           vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance;
  createInfo.pfnUserCallback = DebugCallback;

  m_debugMessenger = m_instance.createDebugUtilsMessengerEXT(
      createInfo, nullptr, VULKAN_HPP_DEFAULT_DISPATCHER);
  core::Logger::info("Vulkan debug utils messenger created.");
}
#endif
} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_descriptor.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/renderer/vulkan/vulkan_descriptor.hpp"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer {

// ============================================================================
// VulkanDescriptorAllocator
// ============================================================================

VulkanDescriptorAllocator::VulkanDescriptorAllocator(vk::Device device)
  : m_device(device)
{
}

VulkanDescriptorAllocator::~VulkanDescriptorAllocator() {
  if (m_currentPool) {
    m_device.destroyDescriptorPool(m_currentPool);
    m_currentPool = nullptr;
  }

  for (auto pool : m_freePools)  m_device.destroyDescriptorPool(pool);
  for (auto pool : m_usedPools)  m_device.destroyDescriptorPool(pool);

  m_freePools.clear();
  m_usedPools.clear();
}

vk::DescriptorPool VulkanDescriptorAllocator::createPool() {
  std::vector<vk::DescriptorPoolSize> poolSizes = {
    {vk::DescriptorType::eSampler, 1000},
    {vk::DescriptorType::eCombinedImageSampler, 1000},
    {vk::DescriptorType::eSampledImage, 1000},
    {vk::DescriptorType::eStorageImage, 1000},
    {vk::DescriptorType::eUniformTexelBuffer, 1000},
    {vk::DescriptorType::eStorageTexelBuffer, 1000},
    {vk::DescriptorType::eUniformBuffer, 1000},
    {vk::DescriptorType::eStorageBuffer, 1000},
    {vk::DescriptorType::eUniformBufferDynamic, 1000},
    {vk::DescriptorType::eStorageBufferDynamic, 1000},
    {vk::DescriptorType::eInputAttachment, 1000}
  };

  vk::DescriptorPoolCreateInfo poolInfo{};
  poolInfo.flags = vk::DescriptorPoolCreateFlags{};
  poolInfo.maxSets = 1000;
  poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
  poolInfo.pPoolSizes = poolSizes.data();

  return m_device.createDescriptorPool(poolInfo);
}

vk::DescriptorSet VulkanDescriptorAllocator::allocate(vk::DescriptorSetLayout layout) {
  if (!m_currentPool) {
    m_currentPool = createPool();
  }

  vk::DescriptorSetAllocateInfo allocInfo{};
  allocInfo.descriptorPool = m_currentPool;
  allocInfo.descriptorSetCount = 1;
  allocInfo.pSetLayouts = &layout;

  vk::DescriptorSet set;
  auto result = m_device.allocateDescriptorSets(&allocInfo, &set);

  if (result == vk::Result::eErrorOutOfPoolMemory ||
      result == vk::Result::eErrorFragmentedPool) {
    // Current pool is full, grab a new one
    m_usedPools.push_back(m_currentPool);

    if (!m_freePools.empty()) {
      m_currentPool = m_freePools.back();
      m_freePools.pop_back();
    } else {
      m_currentPool = createPool();
    }

    // Retry allocation
    allocInfo.descriptorPool = m_currentPool;
    set = m_device.allocateDescriptorSets(allocInfo)[0];
  } else if (result != vk::Result::eSuccess) {
    throw std::runtime_error("Failed to allocate descriptor set");
  }

  return set;
}

void VulkanDescriptorAllocator::reset() {
  for (auto pool : m_usedPools) {
    m_device.resetDescriptorPool(pool);
    m_freePools.push_back(pool);
  }
  m_usedPools.clear();

  if (m_currentPool) {
    m_device.resetDescriptorPool(m_currentPool);
    m_freePools.push_back(m_currentPool);
    m_currentPool = nullptr;
  }
}

// ============================================================================
// VulkanDescriptorLayoutCache
// ============================================================================

VulkanDescriptorLayoutCache::VulkanDescriptorLayoutCache(vk::Device device)
  : m_device(device)
{
}

VulkanDescriptorLayoutCache::~VulkanDescriptorLayoutCache() {
  cleanup();
}

vk::DescriptorSetLayout VulkanDescriptorLayoutCache::createLayout(
  const vk::DescriptorSetLayoutCreateInfo& info)
{
  DescriptorLayoutInfo layoutInfo;
  layoutInfo.bindings.reserve(info.bindingCount);

  bool isSorted = true;
  int32_t lastBinding = -1;

  for (uint32_t i = 0; i < info.bindingCount; i++) {
    layoutInfo.bindings.push_back(info.pBindings[i]);

    if (static_cast<int32_t>(info.pBindings[i].binding) > lastBinding) {
      lastBinding = info.pBindings[i].binding;
    } else {
      isSorted = false;
    }
  }

  if (!isSorted) {
    std::sort(layoutInfo.bindings.begin(), layoutInfo.bindings.end(),
              [](const vk::DescriptorSetLayoutBinding& a,
                 const vk::DescriptorSetLayoutBinding& b) {
                return a.binding < b.binding;
              });
  }

  auto it = m_layoutCache.find(layoutInfo);
  if (it != m_layoutCache.end()) {
    return it->second;
  }

  vk::DescriptorSetLayout layout = m_device.createDescriptorSetLayout(info);
  m_layoutCache[layoutInfo] = layout;
  return layout;
}

void VulkanDescriptorLayoutCache::cleanup() {
  for (auto& [info, layout] : m_layoutCache) {
    m_device.destroyDescriptorSetLayout(layout);
  }
  m_layoutCache.clear();
}

bool VulkanDescriptorLayoutCache::DescriptorLayoutInfo::operator==(
  const DescriptorLayoutInfo& other) const
{
  if (bindings.size() != other.bindings.size()) {
    return false;
  }

  for (size_t i = 0; i < bindings.size(); i++) {
    if (bindings[i].binding != other.bindings[i].binding ||
        bindings[i].descriptorType != other.bindings[i].descriptorType ||
        bindings[i].descriptorCount != other.bindings[i].descriptorCount ||
        bindings[i].stageFlags != other.bindings[i].stageFlags) {
      return false;
    }
  }

  return true;
}

size_t VulkanDescriptorLayoutCache::DescriptorLayoutInfo::hash() const {
  size_t result = std::hash<size_t>()(bindings.size());

  for (const auto& b : bindings) {
    size_t bindingHash = b.binding |
                        static_cast<uint32_t>(b.descriptorType) << 8 |
                        static_cast<uint32_t>(b.stageFlags) << 16;

    result ^= std::hash<size_t>()(bindingHash);
  }

  return result;
}

// ============================================================================
// VulkanDescriptorBuilder
// ============================================================================

VulkanDescriptorBuilder VulkanDescriptorBuilder::begin(
  VulkanDescriptorLayoutCache* cache,
  VulkanDescriptorAllocator* allocator)
{
  VulkanDescriptorBuilder builder;
  builder.m_cache = cache;
  builder.m_allocator = allocator;
  return builder;
}

VulkanDescriptorBuilder& VulkanDescriptorBuilder::bindImage(
  uint32_t binding,
  vk::DescriptorImageInfo* imageInfo,
  vk::DescriptorType type,
  vk::ShaderStageFlags stageFlags)
{
  vk::DescriptorSetLayoutBinding layoutBinding{};
  layoutBinding.binding = binding;
  layoutBinding.descriptorType = type;
  layoutBinding.descriptorCount = 1;
  layoutBinding.stageFlags = stageFlags;

  m_bindings.push_back(layoutBinding);

  vk::WriteDescriptorSet write{};
  write.dstBinding = binding;
  write.descriptorType = type;
  write.descriptorCount = 1;
  write.pImageInfo = imageInfo;

  m_writes.push_back(write);
  return *this;
}

VulkanDescriptorBuilder& VulkanDescriptorBuilder::bindBuffer(
  uint32_t binding,
  vk::DescriptorBufferInfo* bufferInfo,
  vk::DescriptorType type,
  vk::ShaderStageFlags stageFlags)
{
  vk::DescriptorSetLayoutBinding layoutBinding{};
  layoutBinding.binding = binding;
  layoutBinding.descriptorType = type;
  layoutBinding.descriptorCount = 1;
  layoutBinding.stageFlags = stageFlags;

  m_bindings.push_back(layoutBinding);

  vk::WriteDescriptorSet write{};
  write.dstBinding = binding;
  write.descriptorType = type;
  write.descriptorCount = 1;
  write.pBufferInfo = bufferInfo;

  m_writes.push_back(write);
  return *this;
}

bool VulkanDescriptorBuilder::build(vk::DescriptorSet& set,
                                    vk::DescriptorSetLayout& layout)
{
  vk::DescriptorSetLayoutCreateInfo layoutInfo{};
  layoutInfo.bindingCount = static_cast<uint32_t>(m_bindings.size());
  layoutInfo.pBindings = m_bindings.data();

  layout = m_cache->createLayout(layoutInfo);

  set = m_allocator->allocate(layout);

  for (auto& write : m_writes) {
    write.dstSet = set;
  }
  vk::Device device = m_allocator->device();
  device.updateDescriptorSets(m_writes, nullptr);
  return true;
}

bool VulkanDescriptorBuilder::build(vk::DescriptorSet& set) {
  vk::DescriptorSetLayout layout;
  return build(set, layout);
}

} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_device.cpp">
#include "pnkr/renderer/vulkan/vulkan_device.hpp"
#include "pnkr/core/logger.hpp"

#include <set>
#include <stdexcept>
#include <vector>

namespace pnkr::renderer {
static constexpr const char *kDeviceExtensions[] = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME};

void VulkanDevice::create_upload_pool() {
  vk::CommandPoolCreateInfo poolInfo{};
  poolInfo.flags = vk::CommandPoolCreateFlagBits::eTransient |
                   vk::CommandPoolCreateFlagBits::eResetCommandBuffer;
  poolInfo.queueFamilyIndex = graphicsQueueFamily();

  m_uploadPool = m_device.createCommandPool(poolInfo);
}

VulkanDevice::VulkanDevice(VulkanContext &vk_context) : m_context(vk_context) {
  pickPhysicalDevice(vk_context.instance(), vk_context.surface());
  createLogicalDevice(vk_context.surface());

  core::Logger::info("VulkanDevice created.");
  vk_context.initDispatcherPostDevice(m_device);

  createAllocator();

  create_upload_pool();

  core::Logger::info("VMA initialized.");
}

void VulkanDevice::createAllocator() {
  if (m_allocator)
    return; // optional guard

  const auto &dld = m_context.dispatcher();

  VmaVulkanFunctions funcs{};
  // Instance-level
  funcs.vkGetPhysicalDeviceProperties = dld.vkGetPhysicalDeviceProperties;
  funcs.vkGetPhysicalDeviceMemoryProperties =
      dld.vkGetPhysicalDeviceMemoryProperties;

  // Device-level memory management
  funcs.vkAllocateMemory = dld.vkAllocateMemory;
  funcs.vkFreeMemory = dld.vkFreeMemory;
  funcs.vkMapMemory = dld.vkMapMemory;
  funcs.vkUnmapMemory = dld.vkUnmapMemory;
  funcs.vkFlushMappedMemoryRanges = dld.vkFlushMappedMemoryRanges;
  funcs.vkInvalidateMappedMemoryRanges = dld.vkInvalidateMappedMemoryRanges;

  // Binding + requirements
  funcs.vkBindBufferMemory = dld.vkBindBufferMemory;
  funcs.vkBindImageMemory = dld.vkBindImageMemory;
  funcs.vkGetBufferMemoryRequirements = dld.vkGetBufferMemoryRequirements;
  funcs.vkGetImageMemoryRequirements = dld.vkGetImageMemoryRequirements;

  // Resource create/destroy
  funcs.vkCreateBuffer = dld.vkCreateBuffer;
  funcs.vkDestroyBuffer = dld.vkDestroyBuffer;
  funcs.vkCreateImage = dld.vkCreateImage;
  funcs.vkDestroyImage = dld.vkDestroyImage;
  funcs.vkCmdCopyBuffer = dld.vkCmdCopyBuffer;

  // Defensive: fail fast (avoids VMA asserts)
  if (!funcs.vkGetPhysicalDeviceProperties ||
      !funcs.vkGetPhysicalDeviceMemoryProperties || !funcs.vkAllocateMemory ||
      !funcs.vkFreeMemory || !funcs.vkMapMemory || !funcs.vkUnmapMemory ||
      !funcs.vkBindBufferMemory || !funcs.vkGetBufferMemoryRequirements ||
      !funcs.vkCreateBuffer || !funcs.vkDestroyBuffer) {
    throw std::runtime_error("[VulkanDevice] VMA function table is incomplete. "
                             "Did you call initDispatcherPostDevice()?");
  }

  VmaAllocatorCreateInfo info{};
  info.instance = static_cast<VkInstance>(m_context.instance());
  info.physicalDevice = static_cast<VkPhysicalDevice>(m_physicalDevice);
  info.device = static_cast<VkDevice>(m_device);
  info.pVulkanFunctions = &funcs;

  VkResult r = vmaCreateAllocator(&info, &m_allocator);
  if (r != VK_SUCCESS || !m_allocator) {
    throw std::runtime_error("[VulkanDevice] vmaCreateAllocator failed");
  }
}

VulkanDevice::~VulkanDevice() {
  if (m_device) {
    m_device.waitIdle();

    if (m_uploadPool) {
      m_device.destroyCommandPool(m_uploadPool);
      m_uploadPool = nullptr;
    }

    if (m_allocator) {
      vmaDestroyAllocator(m_allocator);
      m_allocator = nullptr;
    }

    m_device.destroy();
    m_device = nullptr;
  }
}

bool VulkanDevice::supportsDeviceExtensions(vk::PhysicalDevice pd) {
  const auto available = pd.enumerateDeviceExtensionProperties(
      nullptr, VULKAN_HPP_DEFAULT_DISPATCHER);

  std::set<std::string> required;
  for (auto *ext : kDeviceExtensions)
    required.insert(ext);

  for (const auto &e : available) {
    required.erase(e.extensionName);
  }
  return required.empty();
}

QueueFamilyIndices VulkanDevice::findQueueFamilies(vk::PhysicalDevice pd,
                                                   vk::SurfaceKHR surface) {
  QueueFamilyIndices out{};

  const auto props = pd.getQueueFamilyProperties(VULKAN_HPP_DEFAULT_DISPATCHER);

  for (uint32_t i = 0; i < static_cast<uint32_t>(props.size()); ++i) {
    if (props[i].queueFlags & vk::QueueFlagBits::eGraphics) {
      out.graphics = i;
    }

    const vk::Bool32 presentSupported =
        pd.getSurfaceSupportKHR(i, surface, VULKAN_HPP_DEFAULT_DISPATCHER);

    if (presentSupported) {
      out.present = i;
    }

    if (out.complete())
      break;
  }

  return out;
}

void VulkanDevice::immediateSubmit(
    std::function<void(vk::CommandBuffer)> &&record) const {
  vk::CommandBufferAllocateInfo allocInfo{};
  allocInfo.commandPool = m_uploadPool;
  allocInfo.level = vk::CommandBufferLevel::ePrimary;
  allocInfo.commandBufferCount = 1;

  vk::CommandBuffer cmd = m_device.allocateCommandBuffers(allocInfo).front();

  vk::CommandBufferBeginInfo beginInfo{};
  beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;
  cmd.begin(beginInfo);

  record(cmd);

  cmd.end();

  vk::Fence fence = m_device.createFence(vk::FenceCreateInfo{});

  vk::SubmitInfo submit{};
  submit.commandBufferCount = 1;
  submit.pCommandBuffers = &cmd;

  graphicsQueue().submit(submit, fence);

  // Wait and clean up
  (void)m_device.waitForFences(1, &fence, VK_TRUE, UINT64_MAX);

  m_device.destroyFence(fence);
  m_device.freeCommandBuffers(m_uploadPool, cmd);
}

void VulkanDevice::pickPhysicalDevice(vk::Instance instance,
                                      vk::SurfaceKHR surface) {
  const auto devices =
      instance.enumeratePhysicalDevices(VULKAN_HPP_DEFAULT_DISPATCHER);
  if (devices.empty()) {
    throw std::runtime_error("No Vulkan physical devices found");
  }

  for (const auto &pd : devices) {
    const auto indices = findQueueFamilies(pd, surface);
    if (!indices.complete())
      continue;
    if (!supportsDeviceExtensions(pd))
      continue;

    // For swapchain well later also require at least one surface format +
    // present mode, but we can defer that until VulkanSwapchain.
    m_physicalDevice = pd;
    m_indices = indices;

    const auto props = pd.getProperties(VULKAN_HPP_DEFAULT_DISPATCHER);
    const uint32_t api = props.apiVersion;
    if (VK_API_VERSION_MAJOR(api) < 1 ||
        (VK_API_VERSION_MAJOR(api) == 1 && VK_API_VERSION_MINOR(api) < 3)) {
      continue;
    }
    core::Logger::info("Selected GPU: {}", props.deviceName.data());
    return;
  }

  throw std::runtime_error("Failed to find a suitable Vulkan physical device");
}

void VulkanDevice::createLogicalDevice(vk::SurfaceKHR /*surface*/) {
  std::vector<vk::DeviceQueueCreateInfo> queueInfos;
  std::set<uint32_t> uniqueFamilies = {m_indices.graphics, m_indices.present};

  float priority = 1.0f;
  queueInfos.reserve(uniqueFamilies.size());
  for (uint32_t family : uniqueFamilies) {
    vk::DeviceQueueCreateInfo qci{};
    qci.queueFamilyIndex = family;
    qci.queueCount = 1;
    qci.pQueuePriorities = &priority;
    queueInfos.push_back(qci);
  }

  // Core features
  vk::PhysicalDeviceFeatures featuresCore{};
  featuresCore.samplerAnisotropy = VK_TRUE;
  featuresCore.shaderStorageImageWriteWithoutFormat = VK_TRUE;

  vk::PhysicalDeviceVulkan12Features features12{};
  features12.runtimeDescriptorArray = true;
  features12.shaderSampledImageArrayNonUniformIndexing = true;
  features12.descriptorBindingPartiallyBound = true; // Often needed for bindless
  features12.descriptorBindingVariableDescriptorCount = true;
  features12.descriptorBindingSampledImageUpdateAfterBind = true; // Essential for bindless
  features12.descriptorBindingStorageBufferUpdateAfterBind = true; // Essential for bindless

  vk::PhysicalDeviceVulkan13Features features13{};
  features13.dynamicRendering = VK_TRUE;
  features13.synchronization2 = VK_TRUE;
  vk::DeviceCreateInfo dci{};
  vk::PhysicalDeviceFeatures2 features2{};
  features2.features = featuresCore;
  features2.pNext = &features13;
  features13.pNext = &features12;
  dci.pNext = &features2;
  dci.pEnabledFeatures = nullptr;
  dci.queueCreateInfoCount = static_cast<uint32_t>(queueInfos.size());
  dci.pQueueCreateInfos = queueInfos.data();
  dci.enabledExtensionCount =
      static_cast<uint32_t>(std::size(kDeviceExtensions));
  dci.ppEnabledExtensionNames = kDeviceExtensions;

  m_device = m_physicalDevice.createDevice(dci, nullptr,
                                           VULKAN_HPP_DEFAULT_DISPATCHER);

  // IMPORTANT: init device-level dispatch
  VULKAN_HPP_DEFAULT_DISPATCHER.init(m_device);

  m_graphicsQueue =
      m_device.getQueue(m_indices.graphics, 0, VULKAN_HPP_DEFAULT_DISPATCHER);
  m_presentQueue =
      m_device.getQueue(m_indices.present, 0, VULKAN_HPP_DEFAULT_DISPATCHER);
  m_graphicsQueueFamilyIndex = m_indices.graphics;
  m_presentQueueFamilyIndex = m_indices.present;
  core::Logger::info(
      "Logical device created. GraphicsQ family={}, PresentQ family={}",
      m_indices.graphics, m_indices.present);
}
} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_dispatch.cpp">
//
// Created by Jose on 12/12/2025.
//

#define VULKAN_HPP_DISPATCH_LOADER_DYNAMIC 1
#include <vulkan/vulkan.hpp>

// This must exist in exactly ONE translation unit.
VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE
</file>

<file path="src/renderer/vulkan/vulkan_pipeline.cpp">
#include "pnkr/renderer/vulkan/vulkan_pipeline.hpp"
#include "pnkr/core/logger.hpp"

#include <fstream>
#include <stdexcept>
#include <utility>

#include "pnkr/renderer/vulkan/PushConstants.h"

namespace pnkr::renderer
{
    namespace
    {
        std::vector<std::uint32_t> ReadSpirvU32(const char* path)
        {
            std::ifstream file(path, std::ios::ate | std::ios::binary);
            if (!file.is_open())
            {
                core::Logger::error("[VulkanPipeline] Failed to open SPIR-V file: {}",
                                    path);
                throw std::runtime_error("Failed to open SPIR-V file");
            }

            const std::streamsize byteSize = file.tellg();
            if (byteSize <= 0 || (byteSize % 4) != 0)
            {
                core::Logger::error(
                    "[VulkanPipeline] Invalid SPIR-V size ({} bytes): {}", byteSize, path);
                throw std::runtime_error("Invalid SPIR-V file size");
            }

            std::vector<std::uint32_t> words(static_cast<size_t>(byteSize / 4));
            file.seekg(0);
            file.read(reinterpret_cast<char*>(words.data()), byteSize);

            if (!file)
            {
                core::Logger::error("[VulkanPipeline] Failed to read SPIR-V file: {}",
                                    path);
                throw std::runtime_error("Failed to read SPIR-V file");
            }

            return words;
        }

        vk::ShaderModule CreateShaderModule(vk::Device device, const char* path)
        {
            const auto code = ReadSpirvU32(path);

            vk::ShaderModuleCreateInfo smci{};
            smci.codeSize = code.size() * sizeof(std::uint32_t);
            smci.pCode = code.data();

            vk::ShaderModule module{};
            try
            {
                module = device.createShaderModule(smci);
            }
            catch (const vk::SystemError& e)
            {
                core::Logger::error(
                    "[VulkanPipeline] createShaderModule failed for {}: {}", path,
                    e.what());
                throw;
            }
            return module;
        }
    } // namespace

    VulkanPipeline::VulkanPipeline(vk::Device device,
                                   const Config& config)
        : m_config(config), m_device(device)
    {
        if (!m_device)
        {
            throw std::runtime_error("[VulkanPipeline] device is null");
        }

        m_vertexInput = config.m_vertexInput;

        core::Logger::info(
            "[VulkanPipeline] Creating pipeline (dynamic rendering), format={}",
            vk::to_string(m_colorFormat));

        createShaderModules(config);
        createPipelineLayout();
        createGraphicsPipeline(config);

        core::Logger::info("[VulkanPipeline] Pipeline created.");
    }

    void VulkanPipeline::reset() noexcept
    {
        if (!m_device)
            return;

        if (m_pipeline)
        {
            m_device.destroyPipeline(m_pipeline);
            m_pipeline = nullptr;
        }
        if (m_layout)
        {
            m_device.destroyPipelineLayout(m_layout);
            m_layout = nullptr;
        }
        if (m_frag)
        {
            m_device.destroyShaderModule(m_frag);
            m_frag = nullptr;
        }
        if (m_vert)
        {
            m_device.destroyShaderModule(m_vert);
            m_vert = nullptr;
        }
    }

    VulkanPipeline::~VulkanPipeline() { reset(); }

    VulkanPipeline::VulkanPipeline(VulkanPipeline&& other) noexcept
    {
        *this = std::move(other);
    }

    VulkanPipeline& VulkanPipeline::operator=(VulkanPipeline&& other) noexcept
    {
        if (this == &other)
            return *this;

        reset();

        m_device = std::exchange(other.m_device, {});
        m_colorFormat = std::exchange(other.m_colorFormat, vk::Format::eUndefined);
        m_vert = std::exchange(other.m_vert, {});
        m_frag = std::exchange(other.m_frag, {});
        m_layout = std::exchange(other.m_layout, {});
        m_pipeline = std::exchange(other.m_pipeline, {});

        return *this;
    }

    void VulkanPipeline::createShaderModules(const Config& config)
    {
        m_vert = CreateShaderModule(m_device, config.m_vertSpvPath.string().c_str());
        m_frag = CreateShaderModule(m_device, config.m_fragSpvPath.string().c_str());
    }

    void VulkanPipeline::createPipelineLayout()
    {
        // Push constant range
        vk::PushConstantRange pushConstantRange{};
        if (m_config.m_pushConstantSize > 0)
        {
            pushConstantRange.stageFlags = m_config.m_pushConstantStages;
            pushConstantRange.offset = 0;
            pushConstantRange.size = m_config.m_pushConstantSize;
        }

        vk::PipelineLayoutCreateInfo layoutInfo{};
        layoutInfo.setLayoutCount = static_cast<uint32_t>(m_config.m_descriptorSetLayouts.size());
        layoutInfo.pSetLayouts = m_config.m_descriptorSetLayouts.data();

        if (m_config.m_pushConstantSize > 0)
        {
            layoutInfo.pushConstantRangeCount = 1;
            layoutInfo.pPushConstantRanges = &pushConstantRange;
        }

        m_layout = m_device.createPipelineLayout(layoutInfo);
    }


    void VulkanPipeline::createGraphicsPipeline(
        const PipelineConfig& config)
    {
        // Shader stages
        vk::PipelineShaderStageCreateInfo stages[2]{};

        stages[0].stage = vk::ShaderStageFlagBits::eVertex;
        stages[0].module = m_vert;
        stages[0].pName = "main";

        stages[1].stage = vk::ShaderStageFlagBits::eFragment;
        stages[1].module = m_frag;
        stages[1].pName = "main";

        // Input Assembly
        vk::PipelineInputAssemblyStateCreateInfo inputAssembly{};
        inputAssembly.topology = config.m_topology;
        inputAssembly.primitiveRestartEnable = VK_FALSE;

        // Dynamic viewport/scissor: pipeline does not bake extent
        vk::PipelineViewportStateCreateInfo viewportState{};
        viewportState.viewportCount = 1;
        viewportState.scissorCount = 1;

        vk::DynamicState dynStates[] = {
            vk::DynamicState::eViewport,
            vk::DynamicState::eScissor
        };
        vk::PipelineDynamicStateCreateInfo dynamicState{};
        dynamicState.dynamicStateCount = 2;
        dynamicState.pDynamicStates = dynStates;

        vk::PipelineRasterizationStateCreateInfo raster{};
        raster.depthClampEnable = VK_FALSE;
        raster.rasterizerDiscardEnable = VK_FALSE;
        raster.polygonMode = vk::PolygonMode::eFill;
        raster.cullMode = config.m_cullMode;
        // NOTE: Vulkan screen-space Y is inverted vs OpenGL
        raster.frontFace = config.m_frontFace;
        raster.depthBiasEnable = VK_FALSE;
        raster.lineWidth = 1.0f;

        vk::PipelineMultisampleStateCreateInfo msaa{};
        msaa.rasterizationSamples = vk::SampleCountFlagBits::e1;
        msaa.sampleShadingEnable = VK_FALSE;

        vk::PipelineColorBlendAttachmentState blendAttach{};
        blendAttach.colorWriteMask =
            vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG |
            vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA;

        blendAttach.blendEnable = config.m_blend.enable ? VK_TRUE : VK_FALSE;
        if (config.m_blend.enable) {
            blendAttach.srcColorBlendFactor = config.m_blend.srcColor;
            blendAttach.dstColorBlendFactor = config.m_blend.dstColor;
            blendAttach.colorBlendOp = config.m_blend.colorOp;
            blendAttach.srcAlphaBlendFactor = config.m_blend.srcAlpha;
            blendAttach.dstAlphaBlendFactor = config.m_blend.dstAlpha;
            blendAttach.alphaBlendOp = config.m_blend.alphaOp;
        }

        vk::PipelineColorBlendStateCreateInfo blend{};
        blend.logicOpEnable = VK_FALSE;
        blend.attachmentCount = 1;
        blend.pAttachments = &blendAttach;

        // Dynamic Rendering: declare attachment formats at pipeline creation time.
        vk::PipelineRenderingCreateInfo renderingInfo{};
        renderingInfo.colorAttachmentCount = 1;
        renderingInfo.pColorAttachmentFormats = &config.m_colorFormat;
        const bool haveDepthFormat =
            (m_config.m_depthFormat != vk::Format::eUndefined);
        renderingInfo.depthAttachmentFormat =
            haveDepthFormat ? m_config.m_depthFormat : vk::Format::eUndefined;
        renderingInfo.stencilAttachmentFormat = vk::Format::eUndefined;

        vk::GraphicsPipelineCreateInfo gpci{};
        vk::PipelineDepthStencilStateCreateInfo depth{};

        // Vertex Input

        vk::PipelineVertexInputStateCreateInfo vertexInputInfo = {};
        vertexInputInfo.pVertexBindingDescriptions = m_vertexInput.m_bindings.data();
        vertexInputInfo.vertexBindingDescriptionCount = (uint32_t)m_vertexInput.m_bindings.size();
        vertexInputInfo.pVertexAttributeDescriptions = m_vertexInput.m_attributes.data();
        vertexInputInfo.vertexAttributeDescriptionCount = (uint32_t)m_vertexInput.m_attributes.size();

        gpci.pVertexInputState = &vertexInputInfo;

        gpci.pNext = &renderingInfo; // critical for dynamic rendering
        gpci.stageCount = 2;
        gpci.pStages = stages;
        gpci.pInputAssemblyState = &inputAssembly;
        gpci.pViewportState = &viewportState;
        gpci.pRasterizationState = &raster;
        gpci.pMultisampleState = &msaa;
        gpci.pColorBlendState = &blend;
        gpci.pDynamicState = &dynamicState;
        gpci.layout = m_layout;
        gpci.subpass = 0;


        if (haveDepthFormat)
        {
            depth.depthTestEnable = m_config.m_depth.testEnable ? VK_TRUE : VK_FALSE;
            depth.depthWriteEnable = m_config.m_depth.writeEnable ? VK_TRUE : VK_FALSE;
            depth.depthCompareOp = m_config.m_depth.compareOp;
            depth.depthBoundsTestEnable = VK_FALSE;
            depth.stencilTestEnable = VK_FALSE;
            gpci.pDepthStencilState = &depth;
        }
        else
        {
            gpci.pDepthStencilState = nullptr;
        }
        try
        {
            auto result = m_device.createGraphicsPipeline(nullptr, gpci);
            if (result.result != vk::Result::eSuccess)
            {
                core::Logger::error(
                    "[VulkanPipeline] createGraphicsPipeline failed: {}",
                    vk::to_string(result.result));
                throw std::runtime_error("createGraphicsPipeline failed");
            }
            m_pipeline = result.value;
        }
        catch (const vk::SystemError& e)
        {
            core::Logger::error(
                "[VulkanPipeline] createGraphicsPipeline threw: {}", e.what());
            throw;
        }
    }
} // namespace pnkr::renderer
// TODO: Fix descriptor set layout mismatch - pipelines need to use bindless layout for set 1
</file>

<file path="src/renderer/vulkan/vulkan_render_target.cpp">
//
// Created by Jose on 12/14/2025.
//

#include "pnkr/renderer/vulkan/vulkan_render_target.h"

namespace pnkr::renderer {

VulkanRenderTarget::VulkanRenderTarget(VmaAllocator allocator, [[maybe_unused]] vk::Device device,
                           uint32_t width, uint32_t height,
                           vk::Format colorFormat, vk::Format depthFormat)
    : m_width(width), m_height(height)
    // Initialize Color Image (HDR, Usage: ColorAttach + TransferSrc + Sampled)
    , m_colorImage(allocator, width, height, colorFormat, vk::ImageTiling::eOptimal,
                   vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eTransferSrc | vk::ImageUsageFlagBits::eSampled,
                   VMA_MEMORY_USAGE_GPU_ONLY)
    // Initialize Depth Image (D32, Usage: DepthAttach)
    , m_depthImage(allocator, width, height, depthFormat, vk::ImageTiling::eOptimal,
                   vk::ImageUsageFlagBits::eDepthStencilAttachment,
                   VMA_MEMORY_USAGE_GPU_ONLY, vk::ImageAspectFlagBits::eDepth)
{
}

vk::Viewport VulkanRenderTarget::viewport() const {
    return vk::Viewport{0.0f, 0.0f, (float)m_width, (float)m_height, 0.0f, 1.0f};
}

vk::Rect2D VulkanRenderTarget::scissor() const {
    return vk::Rect2D{{0, 0}, {m_width, m_height}};
}

void VulkanRenderTarget::transitionToAttachment(vk::CommandBuffer cmd) {
    // Transition Color: Undefined -> ColorAttachment
    m_colorImage.transitionLayout(cmd, vk::ImageLayout::eUndefined, vk::ImageLayout::eColorAttachmentOptimal,
                                  vk::PipelineStageFlagBits2::eNone, vk::PipelineStageFlagBits2::eColorAttachmentOutput);

    // Transition Depth: Undefined -> DepthAttachment
    m_depthImage.transitionLayout(cmd, vk::ImageLayout::eUndefined, vk::ImageLayout::eDepthAttachmentOptimal,
                                  vk::PipelineStageFlagBits2::eEarlyFragmentTests, vk::PipelineStageFlagBits2::eEarlyFragmentTests);
}

void VulkanRenderTarget::transitionToRead(vk::CommandBuffer cmd) {
    // Transition Color: ColorAttachment -> TransferSrc (for blitting)
    m_colorImage.transitionLayout(cmd, vk::ImageLayout::eColorAttachmentOptimal, vk::ImageLayout::eTransferSrcOptimal,
                                  vk::PipelineStageFlagBits2::eColorAttachmentOutput, vk::PipelineStageFlagBits2::eTransfer);
}

void VulkanRenderTarget::beginRendering(vk::CommandBuffer cmd, vk::ClearValue colorClear, vk::ClearValue depthClear) {
    vk::RenderingAttachmentInfo colorAtt{};
    colorAtt.imageView = m_colorImage.view();
    colorAtt.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
    colorAtt.loadOp = vk::AttachmentLoadOp::eClear;
    colorAtt.storeOp = vk::AttachmentStoreOp::eStore;
    colorAtt.clearValue = colorClear;

    vk::RenderingAttachmentInfo depthAtt{};
    depthAtt.imageView = m_depthImage.view();
    depthAtt.imageLayout = vk::ImageLayout::eDepthAttachmentOptimal;
    depthAtt.loadOp = vk::AttachmentLoadOp::eClear;
    depthAtt.storeOp = vk::AttachmentStoreOp::eStore;
    depthAtt.clearValue = depthClear;

    vk::RenderingInfo ri{};
    ri.renderArea = scissor();
    ri.layerCount = 1;
    ri.colorAttachmentCount = 1;
    ri.pColorAttachments = &colorAtt;
    ri.pDepthAttachment = &depthAtt;

    cmd.beginRendering(ri);

    // Set dynamic states automatically to match target
    vk::Viewport vp = viewport();
    vk::Rect2D sc = scissor();
    cmd.setViewport(0, 1, &vp);
    cmd.setScissor(0, 1, &sc);
}

void VulkanRenderTarget::endRendering(vk::CommandBuffer cmd) {
    cmd.endRendering();
}

} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_swapchain.cpp">
#include "pnkr/renderer/vulkan/vulkan_swapchain.hpp"
#include "pnkr/core/logger.hpp"
#include "pnkr/platform/window.hpp" // adjust include path to your actual Window header
#include <algorithm>
#include <limits>
#include <stdexcept>

namespace pnkr::renderer {
namespace {
struct SwapchainSupport {
  vk::SurfaceCapabilitiesKHR caps{};
  std::vector<vk::SurfaceFormatKHR> formats;
  std::vector<vk::PresentModeKHR> presentModes;
};

static SwapchainSupport QuerySwapchainSupport(vk::PhysicalDevice pd,
                                              vk::SurfaceKHR surface) {
  SwapchainSupport s{};
  s.caps = pd.getSurfaceCapabilitiesKHR(surface);
  s.formats = pd.getSurfaceFormatsKHR(surface);
  s.presentModes = pd.getSurfacePresentModesKHR(surface);
  return s;
}

static bool Contains(const std::vector<vk::PresentModeKHR> &modes,
                     vk::PresentModeKHR m) {
  return std::ranges::find(modes, m) != modes.end();
}
} // namespace

VulkanSwapchain::VulkanSwapchain(vk::PhysicalDevice physicalDevice,
                                 vk::Device device, vk::SurfaceKHR surface,
                                 uint32_t graphicsQueueFamily,
                                 uint32_t presentQueueFamily,
                                 platform::Window &window,
                                 VmaAllocator allocator) {
  m_allocator = allocator;
  recreate(physicalDevice, device, surface, graphicsQueueFamily,
           presentQueueFamily, window);
}

VulkanSwapchain::~VulkanSwapchain() {
  // m_device is cached on create; destroy uses it if valid.
  destroy(m_device);
}

void VulkanSwapchain::recreate(vk::PhysicalDevice physicalDevice,
                               vk::Device device, vk::SurfaceKHR surface,
                               uint32_t graphicsQueueFamily,
                               uint32_t presentQueueFamily,
                               platform::Window &window)

{
  if (!physicalDevice)
    throw std::runtime_error("[VulkanSwapchain] physicalDevice is null");
  if (!device)
    throw std::runtime_error("[VulkanSwapchain] device is null");
  if (!surface)
    throw std::runtime_error("[VulkanSwapchain] surface is null");

  // If recreating: destroy old swapchain + views first.
  destroy(device ? device : m_device);
  m_device = device;

  createSwapchain(physicalDevice, device, surface, graphicsQueueFamily,
                  presentQueueFamily, window);
  createImageViews(device);
  createDepthResources();
  core::Logger::info(
      "[VulkanSwapchain] Created ({} images, {}x{}, format={}).",
      static_cast<uint32_t>(m_images.size()), m_extent.width, m_extent.height,
      vk::to_string(m_format));
}

void VulkanSwapchain::destroy(vk::Device device) {
  if (!device)
    return;

  for (auto &iv : m_imageViews) {
    if (iv)
      device.destroyImageView(iv);
  }
  m_imageViews.clear();

  if (m_swapchain) {
    device.destroySwapchainKHR(m_swapchain);
    m_swapchain = nullptr;
  }

  m_images.clear();
  m_format = vk::Format::eUndefined;
  m_extent = vk::Extent2D{};
  destroyDepthResources();
}

void VulkanSwapchain::createSwapchain(vk::PhysicalDevice physicalDevice,
                                      vk::Device device, vk::SurfaceKHR surface,
                                      uint32_t graphicsQueueFamily,
                                      uint32_t presentQueueFamily,
                                      platform::Window &window) {
  const auto support = QuerySwapchainSupport(physicalDevice, surface);

  if (support.formats.empty())
    throw std::runtime_error(
        "[VulkanSwapchain] Surface has no supported formats");
  if (support.presentModes.empty())
    throw std::runtime_error(
        "[VulkanSwapchain] Surface has no supported present modes");

  const vk::SurfaceFormatKHR surfaceFormat =
      chooseSurfaceFormat(support.formats);
  const vk::PresentModeKHR presentMode =
      choosePresentMode(support.presentModes);
  const vk::Extent2D extent = chooseExtent(support.caps, window);

  // Image count: prefer min+1, clamp to max.
  uint32_t imageCount = support.caps.minImageCount + 1;
  if (support.caps.maxImageCount > 0 &&
      imageCount > support.caps.maxImageCount) {
    imageCount = support.caps.maxImageCount;
  }

  vk::SwapchainCreateInfoKHR sci{};
  sci.surface = surface;
  sci.minImageCount = imageCount;
  sci.imageFormat = surfaceFormat.format;
  sci.imageColorSpace = surfaceFormat.colorSpace;
  sci.imageExtent = extent;
  sci.imageArrayLayers = 1;
  sci.imageUsage = vk::ImageUsageFlagBits::eColorAttachment |
                   vk::ImageUsageFlagBits::eTransferDst |
                   vk::ImageUsageFlagBits::eStorage; // Compute writes tonemap results

  uint32_t queueFamilyIndices[2] = {graphicsQueueFamily, presentQueueFamily};

  if (graphicsQueueFamily != presentQueueFamily) {
    sci.imageSharingMode = vk::SharingMode::eConcurrent;
    sci.queueFamilyIndexCount = 2;
    sci.pQueueFamilyIndices = queueFamilyIndices;
  } else {
    sci.imageSharingMode = vk::SharingMode::eExclusive;
  }

  sci.preTransform = support.caps.currentTransform;

  // Composite alpha: pick first supported option in a sensible order.
  const vk::CompositeAlphaFlagBitsKHR preferredAlpha[] = {
      vk::CompositeAlphaFlagBitsKHR::eOpaque,
      vk::CompositeAlphaFlagBitsKHR::eInherit,
      vk::CompositeAlphaFlagBitsKHR::ePreMultiplied,
      vk::CompositeAlphaFlagBitsKHR::ePostMultiplied};
  sci.compositeAlpha = vk::CompositeAlphaFlagBitsKHR::eOpaque;
  for (auto a : preferredAlpha) {
    if (support.caps.supportedCompositeAlpha & a) {
      sci.compositeAlpha = a;
      break;
    }
  }

  sci.presentMode = presentMode;
  sci.clipped = VK_TRUE;
  sci.oldSwapchain = nullptr;

  try {
    m_swapchain = device.createSwapchainKHR(sci);
  } catch (const vk::SystemError &e) {
    core::Logger::error("[VulkanSwapchain] createSwapchainKHR failed: {}",
                              e.what());
    throw;
  }

  m_images = device.getSwapchainImagesKHR(m_swapchain);
  m_format = surfaceFormat.format;
  m_extent = extent;
  m_imageLayouts.assign(m_images.size(), vk::ImageLayout::eUndefined);
}

void VulkanSwapchain::createImageViews(vk::Device device) {
  m_imageViews.resize(m_images.size());

  for (size_t i = 0; i < m_images.size(); ++i) {
    vk::ImageViewCreateInfo ivci{};
    ivci.image = m_images[i];
    ivci.viewType = vk::ImageViewType::e2D;
    ivci.format = m_format;
    ivci.components = vk::ComponentMapping{
        vk::ComponentSwizzle::eIdentity, vk::ComponentSwizzle::eIdentity,
        vk::ComponentSwizzle::eIdentity, vk::ComponentSwizzle::eIdentity};
    ivci.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
    ivci.subresourceRange.baseMipLevel = 0;
    ivci.subresourceRange.levelCount = 1;
    ivci.subresourceRange.baseArrayLayer = 0;
    ivci.subresourceRange.layerCount = 1;

    try {
      m_imageViews[i] = device.createImageView(ivci);
    } catch (const vk::SystemError &e) {
      core::Logger::error(
          "[VulkanSwapchain] createImageView failed (index {}): {}", i,
          e.what());
      throw;
    }
  }
}

vk::SurfaceFormatKHR VulkanSwapchain::chooseSurfaceFormat(
    const std::vector<vk::SurfaceFormatKHR> &formats) {
  // Prefer R8G8B8A8_UNORM to match rgba8 storage image in compute shader.
  for (const auto &f : formats) {
    if (f.format == vk::Format::eR8G8B8A8Unorm &&
        f.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {
      return f;
    }
  }

  // Next: common B8G8R8A8_UNORM path on Windows.
  for (const auto &f : formats) {
    if (f.format == vk::Format::eB8G8R8A8Unorm &&
        f.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {
      return f;
    }
  }

  // Next: SRGB formats if UNORM is unavailable.
  for (const auto &f : formats) {
    if (f.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {
      if (f.format == vk::Format::eR8G8B8A8Srgb ||
          f.format == vk::Format::eB8G8R8A8Srgb) {
        return f;
      }
    }
  }

  // Fallback: first supported.
  return formats[0];
}

vk::PresentModeKHR VulkanSwapchain::choosePresentMode(
    const std::vector<vk::PresentModeKHR> &modes) {
  // You said "vsync yes" earlier. That implies FIFO.
  // If you later add a runtime toggle, implement it here.
  const bool wantVsync = true;

  if (!wantVsync) {
    // Prefer MAILBOX (triple-buffer style), else IMMEDIATE (tears), else FIFO.
    if (Contains(modes, vk::PresentModeKHR::eMailbox))
      return vk::PresentModeKHR::eMailbox;
    if (Contains(modes, vk::PresentModeKHR::eImmediate))
      return vk::PresentModeKHR::eImmediate;
  }

  // FIFO is guaranteed by Vulkan spec for WSI surfaces; present if vsync on.
  return vk::PresentModeKHR::eFifo;
}

vk::Extent2D
VulkanSwapchain::chooseExtent(const vk::SurfaceCapabilitiesKHR &caps,
                              platform::Window &window) {
  // If the surface size is defined, the swapchain must match it.
  if (caps.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
    return caps.currentExtent;
  }

  // Otherwise, clamp to allowed min/max extents.
  const uint32_t w = static_cast<uint32_t>(window.width());
  const uint32_t h = static_cast<uint32_t>(window.height());

  vk::Extent2D actual{};
  actual.width =
      std::clamp(w, caps.minImageExtent.width, caps.maxImageExtent.width);
  actual.height =
      std::clamp(h, caps.minImageExtent.height, caps.maxImageExtent.height);
  return actual;
}

vk::Result VulkanSwapchain::acquireNextImage(uint64_t timeoutNs,
                                             vk::Semaphore imageAvailable,
                                             vk::Fence fence,
                                             uint32_t &outImageIndex) {
  if (!m_device || !m_swapchain)
    throw std::runtime_error(
        "[VulkanSwapchain] acquireNextImage: swapchain/device not initialized");

  // If you pass a fence here, it will be signaled when the presentation engine
  // is done with the image acquisition step. Many engines pass VK_NULL_HANDLE
  // and rely on per-frame fences.
  try {
    auto rv = m_device.acquireNextImageKHR(m_swapchain, timeoutNs,
                                           imageAvailable, fence);
    outImageIndex = rv.value;
    return rv.result;
  } catch (const vk::OutOfDateKHRError &) {
    return vk::Result::eErrorOutOfDateKHR;
  } catch (const vk::SystemError &e) {
    return static_cast<vk::Result>(e.code().value());
  }
}

vk::Result VulkanSwapchain::present(vk::Queue presentQueue, uint32_t imageIndex,
                                    vk::Semaphore renderFinished) {
  if (!m_swapchain)
    throw std::runtime_error(
        "[VulkanSwapchain] present: swapchain not initialized");

  vk::PresentInfoKHR presentInfo{};
  presentInfo.waitSemaphoreCount = 1;
  presentInfo.pWaitSemaphores = &renderFinished; //  must be set

  presentInfo.swapchainCount = 1;
  presentInfo.pSwapchains = &m_swapchain;
  presentInfo.pImageIndices = &imageIndex;

  // Optional: capture per-swapchain result
  vk::Result presentResult = vk::Result::eSuccess;
  presentInfo.pResults = &presentResult;

  try {
    const vk::Result r = presentQueue.presentKHR(presentInfo);
    if (r == vk::Result::eSuccess)
      return presentResult;
    return r;
  } catch (const vk::OutOfDateKHRError &) {
    return vk::Result::eErrorOutOfDateKHR;
  } catch (const vk::SystemError &e) {
    return static_cast<vk::Result>(e.code().value());
  }
}

void VulkanSwapchain::createDepthResources() {
  if (m_depthFormat == vk::Format::eUndefined) {
    destroyDepthResources();
    return;
  }

  if (!m_device || !m_allocator)
    throw std::runtime_error(
        "[VulkanSwapchain] createDepthResources: device/allocator not set");

  // Destroy old if any
  destroyDepthResources();

  vk::ImageCreateInfo ici{};
  ici.imageType = vk::ImageType::e2D;
  ici.format = m_depthFormat;
  ici.extent = vk::Extent3D{m_extent.width, m_extent.height, 1};
  ici.mipLevels = 1;
  ici.arrayLayers = 1;
  ici.samples = vk::SampleCountFlagBits::e1;
  ici.tiling = vk::ImageTiling::eOptimal;
  ici.usage = vk::ImageUsageFlagBits::eDepthStencilAttachment;
  ici.sharingMode = vk::SharingMode::eExclusive;
  ici.initialLayout = vk::ImageLayout::eUndefined;

  VmaAllocationCreateInfo aci{};
  aci.usage = VMA_MEMORY_USAGE_GPU_ONLY;

  VkImage raw = VK_NULL_HANDLE;

  const VkImageCreateInfo rawIci = static_cast<VkImageCreateInfo>(ici);

  VkResult res =
      vmaCreateImage(m_allocator, &rawIci, &aci, &raw, &m_depthAlloc, nullptr);

  if (res != VK_SUCCESS || raw == VK_NULL_HANDLE)
    throw std::runtime_error("[VulkanSwapchain] vmaCreateImage(depth) failed");

  m_depthImage = vk::Image(raw);

  vk::ImageViewCreateInfo ivci{};
  ivci.image = m_depthImage;
  ivci.viewType = vk::ImageViewType::e2D;
  ivci.format = m_depthFormat;
  ivci.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eDepth;
  ivci.subresourceRange.baseMipLevel = 0;
  ivci.subresourceRange.levelCount = 1;
  ivci.subresourceRange.baseArrayLayer = 0;
  ivci.subresourceRange.layerCount = 1;

  m_depthView = m_device.createImageView(ivci);

  // First frame after recreate needs Undefined->DepthAttachment barrier
  m_depthNeedsInitBarrier = true;
}

void VulkanSwapchain::destroyDepthResources() {
  if (!m_device)
    return;

  if (m_depthView) {
    m_device.destroyImageView(m_depthView);
    m_depthView = nullptr;
  }

  if (m_depthImage && m_allocator && m_depthAlloc) {
    vmaDestroyImage(m_allocator, static_cast<VkImage>(m_depthImage),
                    m_depthAlloc);
  }

  m_depthImage = nullptr;
  m_depthAlloc = nullptr;
}
} // namespace pnkr::renderer
</file>

<file path="src/renderer/vulkan/vulkan_sync_manager.cpp">
#include "pnkr/renderer/vulkan/vulkan_sync_manager.h"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer {

VulkanSyncManager::VulkanSyncManager(vk::Device device, uint32_t framesInFlight,
                                     uint32_t swapchainImageCount)
    : m_device(device), m_framesInFlight(framesInFlight) {
  // 1. Frame-bound resources
  m_imageAvailableSemaphores.resize(framesInFlight);
  m_inFlightFences.resize(framesInFlight);

  vk::SemaphoreCreateInfo sci{};
  vk::FenceCreateInfo fci{};
  fci.flags = vk::FenceCreateFlagBits::eSignaled;

  for (uint32_t i = 0; i < framesInFlight; ++i) {
    m_imageAvailableSemaphores[i] = m_device.createSemaphore(sci);
    m_inFlightFences[i] = m_device.createFence(fci);
  }

  // 2. Image-bound resources
  updateSwapchainSize(swapchainImageCount);
}

VulkanSyncManager::~VulkanSyncManager() {
  if (!m_device)
    return;
  try {
    m_device.waitIdle();
  } catch (...) {
  }

  for (auto &sem : m_imageAvailableSemaphores) {
    if (sem)
      m_device.destroySemaphore(sem);
  }
  for (auto &fence : m_inFlightFences) {
    if (fence)
      m_device.destroyFence(fence);
  }
  destroyImageSemaphores();
}

void VulkanSyncManager::destroyImageSemaphores() {
  for (auto &sem : m_renderFinishedSemaphores) {
    if (sem)
      m_device.destroySemaphore(sem);
  }
  m_renderFinishedSemaphores.clear();
}

void VulkanSyncManager::updateSwapchainSize(uint32_t swapchainImageCount) {
  destroyImageSemaphores();

  m_renderFinishedSemaphores.resize(swapchainImageCount);
  vk::SemaphoreCreateInfo sci{};

  for (uint32_t i = 0; i < swapchainImageCount; ++i) {
    m_renderFinishedSemaphores[i] = m_device.createSemaphore(sci);
  }
}

void VulkanSyncManager::waitForFrame(uint32_t frameIndex) const {
  if (frameIndex >= m_framesInFlight)
    return;

  try {
    auto result = m_device.waitForFences(1, &m_inFlightFences[frameIndex],
                                         VK_TRUE, UINT64_MAX);
    if (result != vk::Result::eSuccess) {
      core::Logger::error("[Sync] waitForFences result: {}",
                                vk::to_string(result));
    }
  } catch (const vk::SystemError &e) {
    core::Logger::error("[Sync] waitForFences threw: {}", e.what());
    // Device lost is usually fatal; rethrow or let it crash to main
    throw;
  }
}

void VulkanSyncManager::resetFrame(uint32_t frameIndex) const {
  if (frameIndex >= m_framesInFlight)
    return;

  try {
    (void)m_device.resetFences(1, &m_inFlightFences[frameIndex]);
  } catch (const vk::SystemError &e) {
    core::Logger::error("[Sync] resetFences failed: {}", e.what());
    throw;
  }
}

} // namespace pnkr::renderer
</file>

<file path="src/rhi/rhi_pipeline_builder.cpp">
#include "pnkr/rhi/rhi_pipeline_builder.hpp"
#include <algorithm>

namespace pnkr::renderer::rhi {

    RHIPipelineBuilder::RHIPipelineBuilder() {
        // Defaults for Graphics
        m_gfxDesc.topology = PrimitiveTopology::TriangleList;
        m_gfxDesc.rasterization.polygonMode = PolygonMode::Fill;
        m_gfxDesc.rasterization.cullMode = CullMode::Back;
        m_gfxDesc.rasterization.frontFaceCCW = true;
        m_gfxDesc.rasterization.lineWidth = 1.0f;
        m_gfxDesc.depthStencil.depthTestEnable = true;
        m_gfxDesc.depthStencil.depthWriteEnable = true;
        m_gfxDesc.depthStencil.depthCompareOp = CompareOp::Less;

        setNoBlend(); // Default blend
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setShaders(const Shader* vert, const Shader* frag) {
        m_gfxDesc.shaders.clear();
        m_mergedLayouts.clear();
        m_mergedPushConstants.clear();

        if (vert) {
            ShaderModuleDescriptor sm{};
            sm.stage = ShaderStage::Vertex;
            sm.spirvCode = vert->code();
            sm.entryPoint = vert->reflection().entryPoint;
            m_gfxDesc.shaders.push_back(sm);
            mergeReflection(vert->reflection());
            m_reflectedInputAttributes = vert->reflection().inputAttributes;
        }

        if (frag) {
            ShaderModuleDescriptor sm{};
            sm.stage = ShaderStage::Fragment;
            sm.spirvCode = frag->code();
            sm.entryPoint = frag->reflection().entryPoint;
            m_gfxDesc.shaders.push_back(sm);
            mergeReflection(frag->reflection());
        }
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setComputeShader(const Shader* comp) {
        m_mergedLayouts.clear();
        m_mergedPushConstants.clear();

        if (comp) {
            m_compDesc.shader.stage = ShaderStage::Compute;
            m_compDesc.shader.spirvCode = comp->code();
            m_compDesc.shader.entryPoint = comp->reflection().entryPoint;
            mergeReflection(comp->reflection());
        }
        return *this;
    }

    void RHIPipelineBuilder::mergeReflection(const ShaderReflectionData& reflection) {
        // --- 1. Robust Push Constant Merging ---
        for (const auto& incomingPC : reflection.pushConstants) {
            if (m_mergedPushConstants.empty()) {
                m_mergedPushConstants.push_back(incomingPC);
            } else {
                auto& existing = m_mergedPushConstants[0];
                // Union of stages: e.g. Vertex | Fragment
                existing.stages = existing.stages | incomingPC.stages;
                // Max of sizes: ensure the layout is big enough for the largest user
                existing.size = std::max(existing.size, incomingPC.size);
            }
        }

        // --- 2. Merge Descriptor Sets (Logic remains the same) ---
        if (reflection.descriptorSets.size() > m_mergedLayouts.size()) {
            m_mergedLayouts.resize(reflection.descriptorSets.size());
        }
        for (size_t i = 0; i < reflection.descriptorSets.size(); ++i) {
            const auto& incomingSet = reflection.descriptorSets[i];
            auto& targetSet = m_mergedLayouts[i];
            for (const auto& binding : incomingSet.bindings) {
                bool found = false;
                for (auto& existingBinding : targetSet.bindings) {
                    if (existingBinding.binding == binding.binding) {
                        existingBinding.stages = existingBinding.stages | binding.stages;
                        found = true;
                        break;
                    }
                }
                if (!found) targetSet.bindings.push_back(binding);
            }
        }
    }

    // --- State Setters (Boilerplate) ---


    RHIPipelineBuilder& RHIPipelineBuilder::setTopology(PrimitiveTopology topology) {
        m_gfxDesc.topology = topology;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setPolygonMode(PolygonMode mode) {
        m_gfxDesc.rasterization.polygonMode = mode;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setCullMode(CullMode mode, bool frontFaceCCW) {
        m_gfxDesc.rasterization.cullMode = mode;
        m_gfxDesc.rasterization.frontFaceCCW = frontFaceCCW;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setLineWidth(float width) {
        m_gfxDesc.rasterization.lineWidth = width;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::enableDepthTest(bool writeEnable, CompareOp op) {
        m_gfxDesc.depthStencil.depthTestEnable = true;
        m_gfxDesc.depthStencil.depthWriteEnable = writeEnable;
        m_gfxDesc.depthStencil.depthCompareOp = op;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::disableDepthTest() {
        m_gfxDesc.depthStencil.depthTestEnable = false;
        m_gfxDesc.depthStencil.depthWriteEnable = false;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setNoBlend() {
        if (m_gfxDesc.blend.attachments.empty()) m_gfxDesc.blend.attachments.resize(1);
        for (auto& att : m_gfxDesc.blend.attachments) {
            att.blendEnable = false;
            att.srcColorBlendFactor = BlendFactor::One;
            att.dstColorBlendFactor = BlendFactor::Zero;
        }
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setAlphaBlend() {
        if (m_gfxDesc.blend.attachments.empty()) m_gfxDesc.blend.attachments.resize(1);
        for (auto& att : m_gfxDesc.blend.attachments) {
            att.blendEnable = true;
            att.srcColorBlendFactor = BlendFactor::SrcAlpha;
            att.dstColorBlendFactor = BlendFactor::OneMinusSrcAlpha;
            att.colorBlendOp = BlendOp::Add;
            att.srcAlphaBlendFactor = BlendFactor::One;
            att.dstAlphaBlendFactor = BlendFactor::Zero;
            att.alphaBlendOp = BlendOp::Add;
        }
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setAdditiveBlend() {
        if (m_gfxDesc.blend.attachments.empty()) m_gfxDesc.blend.attachments.resize(1);
        for (auto& att : m_gfxDesc.blend.attachments) {
            att.blendEnable = true;
            att.srcColorBlendFactor = BlendFactor::One;
            att.dstColorBlendFactor = BlendFactor::One;
            att.colorBlendOp = BlendOp::Add;
            att.srcAlphaBlendFactor = BlendFactor::One;
            att.dstAlphaBlendFactor = BlendFactor::Zero;
            att.alphaBlendOp = BlendOp::Add;
        }
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setColorFormat(Format format) {
        m_gfxDesc.colorFormats = { format };
        if (m_gfxDesc.blend.attachments.size() != 1) m_gfxDesc.blend.attachments.resize(1);
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setColorFormats(const std::vector<Format>& formats) {
        m_gfxDesc.colorFormats = formats;
        m_gfxDesc.blend.attachments.resize(formats.size()); // ensure blend states exist
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setDepthFormat(Format format) {
        m_gfxDesc.depthFormat = format;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::addPushConstant(ShaderStage stages, uint32_t offset, uint32_t size) {
        // Manual override adds to the merged list
        m_mergedPushConstants.push_back({ stages, offset, size });
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setDescriptorSetLayouts(const std::vector<DescriptorSetLayout>& layouts) {
        m_mergedLayouts = layouts;
        return *this;
    }

    RHIPipelineBuilder& RHIPipelineBuilder::setName(const char* name) {
        m_gfxDesc.debugName = name;
        m_compDesc.debugName = name;
        return *this;
    }

    GraphicsPipelineDescriptor RHIPipelineBuilder::buildGraphics() const {
        GraphicsPipelineDescriptor desc = m_gfxDesc;
        desc.descriptorSets = m_mergedLayouts;
        desc.pushConstants = m_mergedPushConstants;

        for (const auto& pc : desc.pushConstants) {
            core::Logger::info("[Builder] Pipeline PushConstant: StageFlags={}, Size={}, Offset={}",
                               (uint32_t)pc.stages, pc.size, pc.offset);
        }



        if (m_vertexStride > 0) {
            desc.vertexBindings.push_back({0, m_vertexStride, VertexInputRate::Vertex});

            // Match Reflected Inputs (Shader) to Cpp Layout (Vertex Struct)
            for (const auto& shaderIn : m_reflectedInputAttributes) {
                auto it = std::find_if(m_cppLayout.begin(), m_cppLayout.end(),
                                       [&](const auto& cpp) { return cpp.semantic == shaderIn.semantic; });

                if (it != m_cppLayout.end()) {
                    desc.vertexAttributes.push_back({
                        shaderIn.location,
                        0,
                        it->format,
                        it->offset,
                        it->semantic
                    });
                } else {
                    core::Logger::warn("Vertex shader requires semantic {} at location {}, but C++ Vertex struct does not provide it.",
                                       (int)shaderIn.semantic, shaderIn.location);
                }
            }
        }
        return desc;
    }

    ComputePipelineDescriptor RHIPipelineBuilder::buildCompute() const {
        ComputePipelineDescriptor desc = m_compDesc;
        desc.descriptorSets = m_mergedLayouts;
        desc.pushConstants = m_mergedPushConstants;
        return desc;
    }

} // namespace pnkr::renderer::rhi
</file>

<file path="src/rhi/rhi_shader.cpp">
#include "pnkr/rhi/rhi_shader.hpp"

#include "pnkr/core/logger.hpp"
#include <fstream>
#include <spirv_cross/spirv_cross.hpp>
#include <algorithm>

#include "pnkr/rhi/rhi_types.hpp"

namespace pnkr::renderer::rhi {


    static VertexSemantic parseSemanticName(std::string name) {
        std::transform(name.begin(), name.end(), name.begin(), ::tolower);
        if (name.find("pos") != std::string::npos)      return VertexSemantic::Position;
        if (name.find("color") != std::string::npos)    return VertexSemantic::Color;
        if (name.find("norm") != std::string::npos)     return VertexSemantic::Normal;
        if (name.find("uv") != std::string::npos ||
            name.find("coord") != std::string::npos)    return VertexSemantic::TexCoord;
        if (name.find("tangent") != std::string::npos)  return VertexSemantic::Tangent;
        if (name.find("weight") != std::string::npos)   return VertexSemantic::Weights;
        if (name.find("bone") != std::string::npos)     return VertexSemantic::BoneIds;
        return VertexSemantic::Unknown;
    }

    Shader::Shader(ShaderStage stage, const std::vector<uint32_t>& spirvCode, const ReflectionConfig& config)
        : m_stage(stage)
        , m_code(spirvCode)
        , m_config(config)
    {
        reflect();
    }

    std::unique_ptr<Shader> Shader::load(ShaderStage stage, const std::filesystem::path& path, const ReflectionConfig& config) {
        std::ifstream file(path, std::ios::ate | std::ios::binary);
        if (!file.is_open()) {
            core::Logger::error("Failed to open shader file: {}", path.string());
            throw std::runtime_error("Shader file not found");
        }

        size_t fileSize = (size_t)file.tellg();
        if (fileSize % 4 != 0) {
             throw std::runtime_error("Invalid SPIR-V size");
        }

        std::vector<uint32_t> buffer(fileSize / 4);
        file.seekg(0);
        file.read(reinterpret_cast<char*>(buffer.data()), fileSize);

        return std::make_unique<Shader>(stage, buffer, config);
    }

    void Shader::reflect() {
        spirv_cross::Compiler comp(m_code);
        spirv_cross::ShaderResources res = comp.get_shader_resources();

        // 1. Reflect Descriptors (UBOs, Textures, etc.)
        auto reflectSet = [&](const auto& list, DescriptorType type) {
            for (const auto& r : list) {
                uint32_t set = comp.get_decoration(r.id, spv::DecorationDescriptorSet);
                uint32_t binding = comp.get_decoration(r.id, spv::DecorationBinding);

                // Determine Array Size
                uint32_t count = 1;
                const auto& spirvType = comp.get_type(r.type_id);

                if (!spirvType.array.empty()) {
                    count = spirvType.array[0];

                    // SPIR-V reports 0 for runtime arrays (e.g., textures[])
                    if (count == 0 && m_config.enableRuntimeArrayDetection) {
                        std::string resourceName = comp.get_name(r.id);

                        // Check if this resource has an explicit configuration
                        auto it = m_config.bindlessOverrides.find(resourceName);
                        if (it != m_config.bindlessOverrides.end()) {
                            count = it->second;
                        } else {
                            // Use default size for unconfigured runtime arrays
                            count = m_config.defaultBindlessSize;
                            core::Logger::warn("Runtime array '{}' using default size {}. Consider adding to bindlessOverrides configuration.",
                                              resourceName, count);
                        }
                    }
                }

                if (set >= m_reflection.descriptorSets.size()) m_reflection.descriptorSets.resize(set + 1);

                m_reflection.descriptorSets[set].bindings.push_back({
                    binding,
                    type,
                    count, // Use calculated count, not hardcoded 1
                    m_stage
                });
            }
        };

        reflectSet(res.uniform_buffers, DescriptorType::UniformBuffer);
        reflectSet(res.sampled_images, DescriptorType::CombinedImageSampler);
        reflectSet(res.storage_images, DescriptorType::StorageImage);
        reflectSet(res.storage_buffers, DescriptorType::StorageBuffer);

        // 2. Reflect Push Constants
        for (const auto& resource : res.push_constant_buffers) {
            const auto& type = comp.get_type(resource.base_type_id);


            uint32_t size = (uint32_t)comp.get_declared_struct_size(type);

            m_reflection.pushConstants.push_back({
                m_stage,
                0,
                size
            });
        }

        // 3. Reflect Vertex Inputs (Bridge)
        if (m_stage == ShaderStage::Vertex) {
            for (const auto& input : res.stage_inputs) {
                m_reflection.inputAttributes.push_back({
                    comp.get_decoration(input.id, spv::DecorationLocation),
                    parseSemanticName(comp.get_name(input.id))
                });
            }
        }
    }
} // namespace pnkr::renderer::rhi
</file>

<file path="src/rhi/vulkan/rhi_factory.cpp">
// Force dynamic loader definition to ensure it's active in this translation unit
#ifndef VULKAN_HPP_DISPATCH_LOADER_DYNAMIC
#define VULKAN_HPP_DISPATCH_LOADER_DYNAMIC 1
#endif

#include "pnkr/rhi/rhi_factory.hpp"
#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_swapchain.hpp"
#include "pnkr/core/logger.hpp"
#include <vector>
#include <vulkan/vulkan.hpp>
#include <SDL3/SDL_vulkan.h> // Added SDL Vulkan support

namespace pnkr::renderer::rhi
{
std::vector<std::unique_ptr<RHIPhysicalDevice>>
RHIFactory::enumeratePhysicalDevices(RHIBackend backend)
{
std::vector<std::unique_ptr<RHIPhysicalDevice>> devices;


switch (backend) {
        case RHIBackend::Vulkan: {
            try {
                // Initialize the Dynamic Dispatcher
                static vk::detail::DynamicLoader dl;
                PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = dl.getProcAddress<PFN_vkGetInstanceProcAddr>("vkGetInstanceProcAddr");

                if (!vkGetInstanceProcAddr) {
                    throw std::runtime_error("Failed to load vkGetInstanceProcAddr from Vulkan loader");
                }

                VULKAN_HPP_DEFAULT_DISPATCHER.init(vkGetInstanceProcAddr);

                // Create Vulkan instance
                vk::ApplicationInfo appInfo{};
                appInfo.pApplicationName = "PNKR Engine";
                appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
                appInfo.pEngineName = "PNKR";
                appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
                appInfo.apiVersion = VK_API_VERSION_1_3;

                vk::InstanceCreateInfo createInfo{};
                createInfo.pApplicationInfo = &appInfo;

                // --- Extensions ---
                std::vector<const char*> extensions;

                // 1. Get SDL Extensions (Surface, Platform-specific)
                uint32_t sdlExtCount = 0;
                const char* const* sdlExts = SDL_Vulkan_GetInstanceExtensions(&sdlExtCount);
                if (sdlExts) {
                    for (uint32_t i = 0; i < sdlExtCount; i++) {
                        extensions.push_back(sdlExts[i]);
                    }
                }

                // 2. Add Debug Utils (if debug)
                #ifdef _DEBUG
                extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
                #endif

                // 3. Add Portability (MacOS)
                #ifdef __APPLE__
                extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
                createInfo.flags |= vk::InstanceCreateFlagBits::eEnumeratePortabilityKHR;
                #endif

                createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
                createInfo.ppEnabledExtensionNames = extensions.data();

                // --- Layers ---
                std::vector<const char*> layers;
                #ifdef _DEBUG
                layers.push_back("VK_LAYER_KHRONOS_validation");
                #endif

                createInfo.enabledLayerCount = static_cast<uint32_t>(layers.size());
                createInfo.ppEnabledLayerNames = layers.data();

                // Create Instance
                vk::Instance instance = vk::createInstance(createInfo);

                // Initialize Dispatcher with Instance
                VULKAN_HPP_DEFAULT_DISPATCHER.init(instance);

                // Enumerate physical devices
                auto physicalDevices = instance.enumeratePhysicalDevices();

                for (auto pd : physicalDevices) {
                    devices.push_back(
                        std::make_unique<vulkan::VulkanRHIPhysicalDevice>(pd, instance));
                }

                core::Logger::info("Found {} Vulkan physical device(s)", devices.size());
            } catch (const std::exception& e) {
                core::Logger::error("Vulkan initialization failed: {}", e.what());
            }
            break;
        }
        case RHIBackend::DirectX12:
            core::Logger::error("DirectX12 backend not implemented");
            break;
        case RHIBackend::Metal:
            core::Logger::error("Metal backend not implemented");
            break;
        default:
            core::Logger::error("Unknown backend");
            break;
    }

    return devices;
}

std::unique_ptr<RHIDevice> RHIFactory::createDevice(
    RHIBackend backend,
    RHIPhysicalDevice* physicalDevice,
    const DeviceDescriptor& desc)
{
    switch (backend) {
        case RHIBackend::Vulkan: {
            auto* vkPhysicalDevice = static_cast<vulkan::VulkanRHIPhysicalDevice*>(physicalDevice);

            // Transfer ownership
            std::unique_ptr<vulkan::VulkanRHIPhysicalDevice> ownedPhysicalDevice(vkPhysicalDevice);

            auto device = std::make_unique<vulkan::VulkanRHIDevice>(
                std::move(ownedPhysicalDevice), desc);

            // Initialize Dispatcher with Logical Device
            VULKAN_HPP_DEFAULT_DISPATCHER.init(device->device());

            return device;
        }
        case RHIBackend::DirectX12:
            core::Logger::error("DirectX12 backend not implemented");
            return nullptr;
        case RHIBackend::Metal:
            core::Logger::error("Metal backend not implemented");
            return nullptr;
        default:
            core::Logger::error("Unsupported backend");
            return nullptr;
    }
}

std::unique_ptr<RHIDevice> RHIFactory::createDeviceAuto(
    RHIBackend backend,
    const DeviceDescriptor& desc)
{
    auto devices = enumeratePhysicalDevices(backend);
    if (devices.empty()) {
        core::Logger::error("No physical devices found");
        return nullptr;
    }

    // Select best device (prefer discrete GPU)
    RHIPhysicalDevice* bestDevice = nullptr;
    for (auto& device : devices) {
        if (device->capabilities().discreteGPU) {
            bestDevice = device.release();
            break;
        }
    }

    // If no discrete GPU, use first device
    if (!bestDevice && !devices.empty()) {
        bestDevice = devices[0].release();
    }

    if (!bestDevice) {
        core::Logger::error("Failed to select physical device");
        return nullptr;
    }

    core::Logger::info("Selected device: {}", bestDevice->capabilities().deviceName);

    return createDevice(backend, bestDevice, desc);
}

std::unique_ptr<RHISwapchain> RHIFactory::createSwapchain(
    RHIDevice* device,
    platform::Window& window,
    Format preferredFormat)
{
    if (!device)
    {
        core::Logger::error("createSwapchain: device is null");
        return nullptr;
    }

    // Currently only Vulkan is implemented. The concrete device type determines the swapchain backend.
    if (auto* vkDevice = dynamic_cast<vulkan::VulkanRHIDevice*>(device))
    {
        try
        {
            return std::make_unique<vulkan::VulkanRHISwapchain>(vkDevice, window, preferredFormat);
        }
        catch (const std::exception& e)
        {
            core::Logger::error("Failed to create Vulkan swapchain: {}", e.what());
            return nullptr;
        }
    }

    core::Logger::error("createSwapchain: unsupported device/backend");
    return nullptr;
}





} // namespace pnkr::renderer::rhi
</file>

<file path="src/rhi/vulkan/vulkan_buffer.cpp">
#include "pnkr/rhi/vulkan/vulkan_buffer.hpp"

#include "pnkr/core/logger.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    VulkanRHIBuffer::VulkanRHIBuffer(vk::Device device,
                                     VmaAllocator allocator,
                                     const BufferDescriptor& desc)
        : m_device(device)
        , m_allocator(allocator)
        , m_size(desc.size)
        , m_usage(desc.usage)
        , m_memoryUsage(desc.memoryUsage)
    {
        vk::BufferCreateInfo bufferInfo{};
        bufferInfo.size = desc.size;
        bufferInfo.usage = VulkanUtils::toVkBufferUsage(desc.usage);
        bufferInfo.sharingMode = vk::SharingMode::eExclusive;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VulkanUtils::toVmaMemoryUsage(desc.memoryUsage);

        // VMA still uses C types, need to convert
        VkBufferCreateInfo cBufferInfo = static_cast<VkBufferCreateInfo>(bufferInfo);
        VkBuffer cBuffer;

        vk::Result result = static_cast<vk::Result>(
            vmaCreateBuffer(m_allocator, &cBufferInfo, &allocInfo,
                          &cBuffer, &m_allocation, nullptr));

        if (result != vk::Result::eSuccess) {
            core::Logger::error("Failed to create buffer: {}", vk::to_string(result));
            throw std::runtime_error("Buffer creation failed");
        }

        m_buffer = cBuffer;

        // Debug naming with vulkan-hpp
        if (desc.debugName) {
            vk::DebugUtilsObjectNameInfoEXT nameInfo{};
            nameInfo.objectType = vk::ObjectType::eBuffer;
            nameInfo.objectHandle = reinterpret_cast<uint64_t>(static_cast<VkBuffer>(m_buffer));
            nameInfo.pObjectName = desc.debugName;

                m_device.setDebugUtilsObjectNameEXT(nameInfo);

        }
    }

    VulkanRHIBuffer::~VulkanRHIBuffer()
    {
        if (m_mappedData) {
            unmap();
        }
        vmaDestroyBuffer(m_allocator, static_cast<VkBuffer>(m_buffer), m_allocation);
    }

    void* VulkanRHIBuffer::map()
    {
        if (m_mappedData) {
            return m_mappedData;
        }

        vk::Result result = static_cast<vk::Result>(
            vmaMapMemory(m_allocator, m_allocation, &m_mappedData));

        if (result != vk::Result::eSuccess) {
            core::Logger::error("Failed to map buffer memory: {}", vk::to_string(result));
            return nullptr;
        }

        return m_mappedData;
    }

    void VulkanRHIBuffer::unmap()
    {
        if (m_mappedData) {
            vmaUnmapMemory(m_allocator, m_allocation);
            m_mappedData = nullptr;
        }
    }

    void VulkanRHIBuffer::uploadData(const void* data, uint64_t size, uint64_t offset)
    {
        void* mapped = map();
        if (!mapped) {
            core::Logger::error("Failed to map buffer for upload");
            return;
        }

        std::memcpy(static_cast<char*>(mapped) + offset, data, size);
        unmap();
    }

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_command_buffer.cpp">
#include "pnkr/rhi/vulkan/vulkan_command_buffer.hpp"
#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_buffer.hpp"
#include "pnkr/rhi/vulkan/vulkan_texture.hpp"
#include "pnkr/rhi/vulkan/vulkan_pipeline.hpp"
#include "pnkr/rhi/vulkan/vulkan_descriptor.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    VulkanRHICommandBuffer::VulkanRHICommandBuffer(VulkanRHIDevice* device)
        : m_device(device)
    {
        vk::CommandBufferAllocateInfo allocInfo{};
        allocInfo.commandPool = device->commandPool();
        allocInfo.level = vk::CommandBufferLevel::ePrimary;
        allocInfo.commandBufferCount = 1;

        auto result = device->device().allocateCommandBuffers(allocInfo);
        if (result.empty())
        {
            throw std::runtime_error("Failed to allocate command buffer");
        }

        m_commandBuffer = result[0];
    }

    VulkanRHICommandBuffer::~VulkanRHICommandBuffer()
    {
        if (m_commandBuffer)
        {
            m_device->device().freeCommandBuffers(
                m_device->commandPool(), m_commandBuffer);
        }
    }

    void VulkanRHICommandBuffer::begin()
    {
        vk::CommandBufferBeginInfo beginInfo{};
        beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;

        m_commandBuffer.begin(beginInfo);
        m_recording = true;
    }

    void VulkanRHICommandBuffer::end()
    {
        m_commandBuffer.end();
        m_recording = false;
    }

    void VulkanRHICommandBuffer::reset()
    {
        m_commandBuffer.reset(vk::CommandBufferResetFlagBits::eReleaseResources);
        m_recording = false;
        m_boundPipeline = nullptr;
    }

    void VulkanRHICommandBuffer::beginRendering(const RenderingInfo& info)
    {
        // Convert to Vulkan rendering info (dynamic rendering).
        std::vector<vk::RenderingAttachmentInfo> colorAttachments;
        colorAttachments.reserve(info.colorAttachments.size());

        for (const auto& attachment : info.colorAttachments)
        {
            if (!attachment.texture)
            {
                throw std::runtime_error("beginRendering: color attachment texture is null");
            }

            const VkImageView rawView = static_cast<VkImageView>(attachment.texture->nativeView());
            if (rawView == VK_NULL_HANDLE)
            {
                throw std::runtime_error("beginRendering: color attachment has null nativeView()");
            }

            vk::RenderingAttachmentInfo vkAttachment{};
            vkAttachment.imageView = vk::ImageView(rawView);
            vkAttachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
            vkAttachment.loadOp = VulkanUtils::toVkLoadOp(attachment.loadOp);
            vkAttachment.storeOp = VulkanUtils::toVkStoreOp(attachment.storeOp);
            vkAttachment.clearValue = VulkanUtils::toVkClearValue(attachment.clearValue);

            colorAttachments.push_back(vkAttachment);
        }

        vk::RenderingInfo renderingInfo{};
        renderingInfo.renderArea = VulkanUtils::toVkRect2D(info.renderArea);
        renderingInfo.layerCount = 1;
        renderingInfo.colorAttachmentCount = static_cast<uint32_t>(colorAttachments.size());
        renderingInfo.pColorAttachments = colorAttachments.data();

        // Depth attachment
        vk::RenderingAttachmentInfo depthAttachment{};
        if (info.depthAttachment && info.depthAttachment->texture)
        {
            const VkImageView rawView = static_cast<VkImageView>(info.depthAttachment->texture->nativeView());
            if (rawView == VK_NULL_HANDLE)
            {
                throw std::runtime_error("beginRendering: depth attachment has null nativeView()");
            }

            depthAttachment.imageView = vk::ImageView(rawView);
            depthAttachment.imageLayout = vk::ImageLayout::eDepthStencilAttachmentOptimal;
            depthAttachment.loadOp = VulkanUtils::toVkLoadOp(info.depthAttachment->loadOp);
            depthAttachment.storeOp = VulkanUtils::toVkStoreOp(info.depthAttachment->storeOp);
            depthAttachment.clearValue = VulkanUtils::toVkClearValue(info.depthAttachment->clearValue);

            renderingInfo.pDepthAttachment = &depthAttachment;
        }

        m_commandBuffer.beginRendering(renderingInfo);
    }

    void VulkanRHICommandBuffer::endRendering()
    {
        m_commandBuffer.endRendering();
    }

    void VulkanRHICommandBuffer::bindPipeline(RHIPipeline* pipeline)
    {
        auto* vkPipeline = static_cast<VulkanRHIPipeline*>(pipeline);
        m_boundPipeline = vkPipeline;

        vk::PipelineBindPoint bindPoint =
            vkPipeline->bindPoint() == PipelineBindPoint::Graphics
                ? vk::PipelineBindPoint::eGraphics
                : vk::PipelineBindPoint::eCompute;

        m_commandBuffer.bindPipeline(bindPoint, vkPipeline->pipeline());
    }

    void VulkanRHICommandBuffer::bindVertexBuffer(uint32_t binding, RHIBuffer* buffer, uint64_t offset)
    {
        auto* vkBuffer = static_cast<VulkanRHIBuffer*>(buffer);
        m_commandBuffer.bindVertexBuffers(binding, vkBuffer->buffer(), offset);
    }

    void VulkanRHICommandBuffer::bindIndexBuffer(RHIBuffer* buffer, uint64_t offset, bool use16Bit)
    {
        auto* vkBuffer = static_cast<VulkanRHIBuffer*>(buffer);
        m_commandBuffer.bindIndexBuffer(
            vkBuffer->buffer(),
            offset,
            use16Bit ? vk::IndexType::eUint16 : vk::IndexType::eUint32);
    }

    void VulkanRHICommandBuffer::draw(uint32_t vertexCount, uint32_t instanceCount,
                                      uint32_t firstVertex, uint32_t firstInstance)
    {
        m_commandBuffer.draw(vertexCount, instanceCount, firstVertex, firstInstance);
    }

    void VulkanRHICommandBuffer::drawIndexed(uint32_t indexCount, uint32_t instanceCount,
                                             uint32_t firstIndex, int32_t vertexOffset,
                                             uint32_t firstInstance)
    {
        m_commandBuffer.drawIndexed(indexCount, instanceCount, firstIndex,
                                    vertexOffset, firstInstance);
    }

    void VulkanRHICommandBuffer::dispatch(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
    {
        m_commandBuffer.dispatch(groupCountX, groupCountY, groupCountZ);
    }

    void VulkanRHICommandBuffer::pushConstants(RHIPipeline* pipeline, ShaderStage stages,
                                               uint32_t offset, uint32_t size, const void* data)
    {
        auto* vkPipeline = static_cast<VulkanRHIPipeline*>(pipeline);
        m_commandBuffer.pushConstants(
            vkPipeline->pipelineLayout(),
            VulkanUtils::toVkShaderStage(stages),
            offset,
            size,
            data);
    }

    void VulkanRHICommandBuffer::bindDescriptorSet(RHIPipeline* pipeline, uint32_t setIndex,
                                                   RHIDescriptorSet* descriptorSet)
    {
        auto* vkPipeline = static_cast<VulkanRHIPipeline*>(pipeline);
        if (!descriptorSet)
        {
            throw std::runtime_error("bindDescriptorSet: descriptorSet is null");
        }
        auto* vkSet = static_cast<VulkanRHIDescriptorSet*>(descriptorSet);
        vk::DescriptorSet vkDescSet = vk::DescriptorSet(
            static_cast<VkDescriptorSet>(vkSet->nativeHandle()));

        vk::PipelineBindPoint bindPoint =
            vkPipeline->bindPoint() == PipelineBindPoint::Graphics
                ? vk::PipelineBindPoint::eGraphics
                : vk::PipelineBindPoint::eCompute;

        m_commandBuffer.bindDescriptorSets(
            bindPoint,
            vkPipeline->pipelineLayout(),
            setIndex,
            1,
            &vkDescSet,
            0,
            nullptr
        );
    }
    void VulkanRHICommandBuffer::bindDescriptorSet(RHIPipeline* pipeline, uint32_t setIndex,
                                      void* nativeDescriptorSet)
    {
        auto* vkPipeline = static_cast<VulkanRHIPipeline*>(pipeline);
        if (!nativeDescriptorSet)
        {
            throw std::runtime_error("bindDescriptorSet: nativeDescriptorSet is null");
        }

        vk::DescriptorSet vkDescSet = reinterpret_cast<VkDescriptorSet>(nativeDescriptorSet);


        vk::PipelineBindPoint bindPoint =
            vkPipeline->bindPoint() == PipelineBindPoint::Graphics
                ? vk::PipelineBindPoint::eGraphics
                : vk::PipelineBindPoint::eCompute;

        m_commandBuffer.bindDescriptorSets(
            bindPoint,
            vkPipeline->pipelineLayout(),
            setIndex,
            1,
            &vkDescSet,
            0,
            nullptr
        );
    }

    void VulkanRHICommandBuffer::setViewport(const Viewport& viewport)
    {
        m_commandBuffer.setViewport(0, VulkanUtils::toVkViewport(viewport));
    }

    void VulkanRHICommandBuffer::setScissor(const Rect2D& scissor)
    {
        m_commandBuffer.setScissor(0, VulkanUtils::toVkRect2D(scissor));
    }

    void VulkanRHICommandBuffer::pipelineBarrier(
        ShaderStage srcStage,
        ShaderStage dstStage,
        const std::vector<RHIMemoryBarrier>& barriers)
    {
        std::vector<vk::BufferMemoryBarrier2> bufferBarriers;
        std::vector<vk::ImageMemoryBarrier2> imageBarriers;

        const vk::PipelineStageFlags2 srcStageMask = VulkanUtils::toVkPipelineStage(srcStage);
        const vk::PipelineStageFlags2 dstStageMask = VulkanUtils::toVkPipelineStage(dstStage);

        for (const auto& barrier : barriers)
        {
            if (barrier.buffer)
            {
                // Buffer barrier
                auto* vkBuffer = static_cast<VulkanRHIBuffer*>(barrier.buffer);

                vk::BufferMemoryBarrier2 vkBarrier{};

                vkBarrier.srcStageMask = srcStageMask;
                vkBarrier.dstStageMask = dstStageMask;

                if (dstStage == ShaderStage::Host)
                {
                    vkBarrier.dstAccessMask = vk::AccessFlagBits2::eHostRead;
                }
                else if (dstStage == ShaderStage::Transfer)
                {
                    vkBarrier.dstAccessMask = vk::AccessFlagBits2::eTransferRead;
                }
                else
                {
                    // Default to standard GPU shader read
                    vkBarrier.dstAccessMask = vk::AccessFlagBits2::eShaderRead;
                }

                if (srcStage == ShaderStage::Transfer)
                {
                    vkBarrier.srcAccessMask = vk::AccessFlagBits2::eTransferWrite;
                }
                else
                {
                    vkBarrier.srcAccessMask = vk::AccessFlagBits2::eShaderWrite | vk::AccessFlagBits2::eMemoryWrite;
                }

                vkBarrier.buffer = vkBuffer->buffer();
                vkBarrier.size = VK_WHOLE_SIZE;

                bufferBarriers.push_back(vkBarrier);
            }
            else if (barrier.texture)
            {
                // Image barrier (works for both device-owned textures and swapchain images).
                const VkImage rawImage = static_cast<VkImage>(barrier.texture->nativeHandle());
                if (rawImage == VK_NULL_HANDLE)
                {
                    throw std::runtime_error("pipelineBarrier: texture has null nativeHandle()");
                }

                vk::ImageMemoryBarrier2 vkBarrier{};
                vkBarrier.srcStageMask = srcStageMask;
                vkBarrier.dstStageMask = dstStageMask;
                vkBarrier.oldLayout = VulkanUtils::toVkImageLayout(barrier.oldLayout);
                vkBarrier.newLayout = VulkanUtils::toVkImageLayout(barrier.newLayout);

                // Derive access masks from layouts.
                auto getAccessFlags = [](vk::ImageLayout layout) -> vk::AccessFlags2
                {
                    switch (layout)
                    {
                    case vk::ImageLayout::eUndefined: return vk::AccessFlags2{};
                    case vk::ImageLayout::eTransferDstOptimal: return vk::AccessFlagBits2::eTransferWrite;
                    case vk::ImageLayout::eTransferSrcOptimal: return vk::AccessFlagBits2::eTransferRead;
                    case vk::ImageLayout::eColorAttachmentOptimal:
                        return vk::AccessFlagBits2::eColorAttachmentWrite | vk::AccessFlagBits2::eColorAttachmentRead;
                    case vk::ImageLayout::eDepthStencilAttachmentOptimal:
                        return vk::AccessFlagBits2::eDepthStencilAttachmentWrite |
                            vk::AccessFlagBits2::eDepthStencilAttachmentRead;
                    case vk::ImageLayout::eShaderReadOnlyOptimal: return vk::AccessFlagBits2::eShaderRead;
                    case vk::ImageLayout::ePresentSrcKHR: return vk::AccessFlagBits2::eMemoryRead;
                    default: return vk::AccessFlagBits2::eMemoryRead | vk::AccessFlagBits2::eMemoryWrite;
                    }
                };

                vkBarrier.srcAccessMask = getAccessFlags(vkBarrier.oldLayout);
                vkBarrier.dstAccessMask = getAccessFlags(vkBarrier.newLayout);

                vkBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
                vkBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
                vkBarrier.image = vk::Image(rawImage);

                const vk::Format fmt = VulkanUtils::toVkFormat(barrier.texture->format());
                if (fmt == vk::Format::eD16Unorm || fmt == vk::Format::eD32Sfloat ||
                    fmt == vk::Format::eD24UnormS8Uint || fmt == vk::Format::eD32SfloatS8Uint)
                {
                    vkBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eDepth;
                    if (fmt == vk::Format::eD24UnormS8Uint || fmt == vk::Format::eD32SfloatS8Uint)
                    {
                        vkBarrier.subresourceRange.aspectMask |= vk::ImageAspectFlagBits::eStencil;
                    }
                }
                else
                {
                    vkBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
                }

                vkBarrier.subresourceRange.baseMipLevel = 0;
                vkBarrier.subresourceRange.levelCount = std::max(1u, barrier.texture->mipLevels());
                vkBarrier.subresourceRange.baseArrayLayer = 0;
                vkBarrier.subresourceRange.layerCount = std::max(1u, barrier.texture->arrayLayers());

                imageBarriers.push_back(vkBarrier);
            }
        }

        vk::DependencyInfo depInfo{};
        depInfo.dependencyFlags = vk::DependencyFlags{};
        depInfo.bufferMemoryBarrierCount = static_cast<uint32_t>(bufferBarriers.size());
        depInfo.pBufferMemoryBarriers = bufferBarriers.data();
        depInfo.imageMemoryBarrierCount = static_cast<uint32_t>(imageBarriers.size());
        depInfo.pImageMemoryBarriers = imageBarriers.data();

        m_commandBuffer.pipelineBarrier2(depInfo);
    }

    void VulkanRHICommandBuffer::copyBuffer(RHIBuffer* src, RHIBuffer* dst,
                                            uint64_t srcOffset, uint64_t dstOffset, uint64_t size)
    {
        auto* srcBuffer = static_cast<VulkanRHIBuffer*>(src);
        auto* dstBuffer = static_cast<VulkanRHIBuffer*>(dst);

        vk::BufferCopy copyRegion{};
        copyRegion.srcOffset = srcOffset;
        copyRegion.dstOffset = dstOffset;
        copyRegion.size = size;

        m_commandBuffer.copyBuffer(srcBuffer->buffer(), dstBuffer->buffer(), copyRegion);
    }

    void VulkanRHICommandBuffer::copyBufferToTexture(RHIBuffer* src, RHITexture* dst,
                                                     const BufferTextureCopyRegion& region)
    {
        auto* srcBuffer = static_cast<VulkanRHIBuffer*>(src);
        if (!dst)
        {
            throw std::runtime_error("copyBufferToTexture: dst is null");
        }

        const VkImage rawImage = static_cast<VkImage>(dst->nativeHandle());
        if (rawImage == VK_NULL_HANDLE)
        {
            throw std::runtime_error("copyBufferToTexture: dst has null nativeHandle()");
        }

        vk::BufferImageCopy copyRegion{};
        copyRegion.bufferOffset = region.bufferOffset;
        copyRegion.bufferRowLength = region.bufferRowLength;
        copyRegion.bufferImageHeight = region.bufferImageHeight;

        vk::Format fmt = VulkanUtils::toVkFormat(dst->format());
        if (fmt == vk::Format::eD16Unorm || fmt == vk::Format::eD32Sfloat ||
            fmt == vk::Format::eD24UnormS8Uint || fmt == vk::Format::eD32SfloatS8Uint)
        {
            copyRegion.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eDepth;
        }
        else
        {
            copyRegion.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
        }

        copyRegion.imageSubresource.mipLevel = region.textureSubresource.mipLevel;
        copyRegion.imageSubresource.baseArrayLayer = region.textureSubresource.arrayLayer;
        copyRegion.imageSubresource.layerCount = 1;

        copyRegion.imageOffset = vk::Offset3D{
            region.textureOffset.x,
            region.textureOffset.y,
            region.textureOffset.z
        };
        copyRegion.imageExtent = VulkanUtils::toVkExtent3D(region.textureExtent);

        m_commandBuffer.copyBufferToImage(
            srcBuffer->buffer(),
            vk::Image(rawImage),
            vk::ImageLayout::eTransferDstOptimal,
            copyRegion
        );
    }
} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_descriptor.cpp">
#include "pnkr/rhi/vulkan/vulkan_descriptor.hpp"

#include "pnkr/rhi/rhi_buffer.hpp"
#include "pnkr/rhi/rhi_sampler.hpp"
#include "pnkr/rhi/rhi_texture.hpp"
#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    VulkanRHIDescriptorSetLayout::VulkanRHIDescriptorSetLayout(
        VulkanRHIDevice* device,
        vk::DescriptorSetLayout layout,
        const DescriptorSetLayout& desc,
        bool ownsLayout)
        : m_device(device)
        , m_layout(layout)
        , m_desc(desc)
        , m_ownsLayout(ownsLayout)
    {
        for (const auto& binding : desc.bindings)
        {
            m_bindingTypes.emplace(binding.binding, binding.type);
        }
    }

    VulkanRHIDescriptorSetLayout::~VulkanRHIDescriptorSetLayout()
    {
        if (m_device && m_layout && m_ownsLayout)
        {
            m_device->device().destroyDescriptorSetLayout(m_layout);
            m_layout = nullptr;
        }
    }

    const DescriptorSetLayout& VulkanRHIDescriptorSetLayout::description() const
    {
        return m_desc;
    }

    DescriptorType VulkanRHIDescriptorSetLayout::descriptorType(uint32_t binding) const
    {
        auto it = m_bindingTypes.find(binding);
        if (it == m_bindingTypes.end())
        {
            return DescriptorType::UniformBuffer;
        }
        return it->second;
    }

    VulkanRHIDescriptorSet::VulkanRHIDescriptorSet(
        VulkanRHIDevice* device,
        VulkanRHIDescriptorSetLayout* layout,
        vk::DescriptorSet set)
        : m_device(device)
        , m_layout(layout)
        , m_set(set)
    {
    }

    void VulkanRHIDescriptorSet::updateBuffer(uint32_t binding,
                                              RHIBuffer* buffer,
                                              uint64_t offset,
                                              uint64_t range)
    {
        if (!buffer)
        {
            core::Logger::error("updateBuffer: buffer is null");
            return;
        }

        auto type = m_layout->descriptorType(binding);
        if (type != DescriptorType::UniformBuffer &&
            type != DescriptorType::StorageBuffer &&
            type != DescriptorType::UniformBufferDynamic &&
            type != DescriptorType::StorageBufferDynamic)
        {
            core::Logger::error("updateBuffer: binding {} is not a buffer descriptor", binding);
            return;
        }

        vk::DescriptorBufferInfo bufferInfo{};
        bufferInfo.buffer = vk::Buffer(static_cast<VkBuffer>(buffer->nativeHandle()));
        bufferInfo.offset = offset;
        bufferInfo.range = range;

        vk::WriteDescriptorSet write{};
        write.dstSet = m_set;
        write.dstBinding = binding;
        write.descriptorType = VulkanUtils::toVkDescriptorType(type);
        write.descriptorCount = 1;
        write.pBufferInfo = &bufferInfo;

        m_device->device().updateDescriptorSets(write, nullptr);
    }

    void VulkanRHIDescriptorSet::updateTexture(uint32_t binding,
                                               RHITexture* texture,
                                               RHISampler* sampler)
    {
        auto type = m_layout->descriptorType(binding);
        if (type != DescriptorType::CombinedImageSampler &&
            type != DescriptorType::SampledImage &&
            type != DescriptorType::StorageImage)
        {
            core::Logger::error("updateTexture: binding {} is not an image descriptor", binding);
            return;
        }
        if (!texture)
        {
            core::Logger::error("updateTexture: texture is null");
            return;
        }
        if (type == DescriptorType::CombinedImageSampler && !sampler)
        {
            core::Logger::error("updateTexture: sampler is null");
            return;
        }

        vk::DescriptorImageInfo imageInfo{};
        imageInfo.imageView = vk::ImageView(static_cast<VkImageView>(texture->nativeView()));
        if (type == DescriptorType::StorageImage)
        {
            imageInfo.imageLayout = vk::ImageLayout::eGeneral;
            imageInfo.sampler = nullptr;
        }
        else if (type == DescriptorType::SampledImage)
        {
            imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
            imageInfo.sampler = nullptr;
        }
        else
        {
            imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
            imageInfo.sampler = vk::Sampler(static_cast<VkSampler>(sampler->nativeHandle()));
        }

        vk::WriteDescriptorSet write{};
        write.dstSet = m_set;
        write.dstBinding = binding;
        write.descriptorType = VulkanUtils::toVkDescriptorType(type);
        write.descriptorCount = 1;
        write.pImageInfo = &imageInfo;

        m_device->device().updateDescriptorSets(write, nullptr);
    }
} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_device.cpp">
#include "pnkr/rhi/vulkan/vulkan_device.hpp"

#include "pnkr/rhi/vulkan/vulkan_buffer.hpp"
#include "pnkr/rhi/vulkan/vulkan_texture.hpp"
#include "pnkr/rhi/vulkan/vulkan_sampler.hpp"
#include "pnkr/rhi/vulkan/vulkan_command_buffer.hpp"
#include "pnkr/rhi/vulkan/vulkan_pipeline.hpp"
#include "pnkr/rhi/vulkan/vulkan_descriptor.hpp"
#include "pnkr/core/logger.hpp"
#include <array>
#include <set>

namespace pnkr::renderer::rhi::vulkan
{
    // VulkanRHIPhysicalDevice Implementation
    VulkanRHIPhysicalDevice::VulkanRHIPhysicalDevice(vk::PhysicalDevice physicalDevice, vk::Instance instance)
        : m_physicalDevice(physicalDevice)
          , m_instance(instance)
    {
        queryCapabilities();
        queryQueueFamilies();
    }


    void VulkanRHIPhysicalDevice::queryCapabilities()
    {
        auto props = m_physicalDevice.getProperties();
        auto features = m_physicalDevice.getFeatures();

        m_capabilities.deviceName = std::string(props.deviceName.data());
        m_capabilities.vendorID = props.vendorID;
        m_capabilities.deviceID = props.deviceID;
        m_capabilities.discreteGPU = (props.deviceType == vk::PhysicalDeviceType::eDiscreteGpu);

        m_capabilities.maxImageDimension2D = props.limits.maxImageDimension2D;
        m_capabilities.maxImageDimension3D = props.limits.maxImageDimension3D;
        m_capabilities.maxFramebufferWidth = props.limits.maxFramebufferWidth;
        m_capabilities.maxFramebufferHeight = props.limits.maxFramebufferHeight;
        m_capabilities.maxColorAttachments = props.limits.maxColorAttachments;

        m_capabilities.geometryShader = features.geometryShader;
        m_capabilities.tessellationShader = features.tessellationShader;
        m_capabilities.samplerAnisotropy = features.samplerAnisotropy;
        m_capabilities.textureCompressionBC = features.textureCompressionBC;

        // Check for bindless support (descriptor indexing)
        vk::PhysicalDeviceDescriptorIndexingFeatures indexingFeatures;
        vk::PhysicalDeviceFeatures2 features2;
        features2.pNext = &indexingFeatures;
        m_physicalDevice.getFeatures2(&features2);
        m_capabilities.bindlessTextures = indexingFeatures.descriptorBindingPartiallyBound;

        // Check for ray tracing
        m_capabilities.rayTracing = false;
        m_capabilities.meshShading = false;
    }

    void VulkanRHIPhysicalDevice::queryQueueFamilies()
    {
        auto queueFamilyProps = m_physicalDevice.getQueueFamilyProperties();

        for (uint32_t i = 0; i < queueFamilyProps.size(); ++i)
        {
            QueueFamilyInfo info{};
            info.familyIndex = i;
            info.queueCount = queueFamilyProps[i].queueCount;
            info.supportsGraphics = (queueFamilyProps[i].queueFlags & vk::QueueFlagBits::eGraphics) != vk::QueueFlags{};
            info.supportsCompute = (queueFamilyProps[i].queueFlags & vk::QueueFlagBits::eCompute) != vk::QueueFlags{};
            info.supportsTransfer = (queueFamilyProps[i].queueFlags & vk::QueueFlagBits::eTransfer) != vk::QueueFlags{};

            m_queueFamilies.push_back(info);
        }
    }

    bool VulkanRHIPhysicalDevice::supportsPresentation(uint32_t queueFamily) const
    {
        // TODO: Check presentation support with surface (requires passing surface to physical device)
        return queueFamily < m_queueFamilies.size();
    }

    // VulkanRHIDevice Implementation
    VulkanRHIDevice::VulkanRHIDevice(std::unique_ptr<VulkanRHIPhysicalDevice> physicalDevice,
                                     const DeviceDescriptor& desc)
        : m_physicalDevice(std::move(physicalDevice))
    {
        createLogicalDevice(desc);
        selectQueueFamilies();
        createAllocator();
        createCommandPool();
        createTimelineSemaphore();
        createDescriptorPool();
        initBindless();
        (void)m_validationEnabled;
        core::Logger::info("Vulkan RHI Device created: {}", m_physicalDevice->capabilities().deviceName);
    }

    VulkanRHIDevice::~VulkanRHIDevice()
    {
        if (m_device)
        {
            m_device.waitIdle();

            if (m_bindlessLayout)
            {
                m_bindlessLayout.reset(); // This triggers the RHI destructor which calls Vulkan destroy
            }
            if (m_bindlessPool)
            {
                m_device.destroyDescriptorPool(m_bindlessPool);
            }

            if (m_timelineSemaphore)
            {
                m_device.destroySemaphore(m_timelineSemaphore);
            }

            if (m_commandPool)
            {
                m_device.destroyCommandPool(m_commandPool);
            }

            if (m_descriptorPool)
            {
                m_device.destroyDescriptorPool(m_descriptorPool);
            }

            if (m_allocator)
            {
                vmaDestroyAllocator(m_allocator);
            }

            m_device.destroy();
        }

        // Destroy the instance we created in the factory
        if (m_physicalDevice && m_physicalDevice->instance())
        {
            m_physicalDevice->instance().destroy();
        }
    }

    void VulkanRHIDevice::createLogicalDevice(const DeviceDescriptor& desc)
    {
        // 1. Queue Families
        auto queueFamilies = m_physicalDevice->queueFamilies();
        uint32_t graphicsFamily = VK_QUEUE_FAMILY_IGNORED;
        uint32_t computeFamily = VK_QUEUE_FAMILY_IGNORED;

        for (const auto& family : queueFamilies)
        {
            if (family.supportsGraphics && graphicsFamily == VK_QUEUE_FAMILY_IGNORED)
            {
                graphicsFamily = family.familyIndex;
            }
            if (family.supportsCompute && computeFamily == VK_QUEUE_FAMILY_IGNORED)
            {
                computeFamily = family.familyIndex;
            }
        }

        if (graphicsFamily == VK_QUEUE_FAMILY_IGNORED)
        {
            throw std::runtime_error("No graphics queue family found");
        }

        std::set<uint32_t> uniqueQueueFamilies = {graphicsFamily};
        if (computeFamily != VK_QUEUE_FAMILY_IGNORED)
        {
            uniqueQueueFamilies.insert(computeFamily);
        }

        std::vector<vk::DeviceQueueCreateInfo> queueCreateInfos;
        float queuePriority = 1.0f;

        for (uint32_t queueFamily : uniqueQueueFamilies)
        {
            vk::DeviceQueueCreateInfo queueInfo{};
            queueInfo.queueFamilyIndex = queueFamily;
            queueInfo.queueCount = 1;
            queueInfo.pQueuePriorities = &queuePriority;
            queueCreateInfos.push_back(queueInfo);
        }

        // 2. Features
        // Core features
        vk::PhysicalDeviceFeatures featuresCore{};
        featuresCore.samplerAnisotropy = VK_TRUE;
        featuresCore.shaderStorageImageWriteWithoutFormat = VK_TRUE;
        featuresCore.fillModeNonSolid = VK_TRUE;

        // Vulkan 1.2 features (Bindless)
        vk::PhysicalDeviceVulkan12Features features12{};
        features12.runtimeDescriptorArray = VK_TRUE;
        features12.shaderSampledImageArrayNonUniformIndexing = VK_TRUE;
        features12.descriptorBindingPartiallyBound = VK_TRUE;
        features12.descriptorBindingVariableDescriptorCount = VK_TRUE;
        features12.bufferDeviceAddress = VK_TRUE;
        features12.descriptorIndexing = VK_TRUE;
        features12.descriptorBindingSampledImageUpdateAfterBind = VK_TRUE;
        features12.descriptorBindingStorageBufferUpdateAfterBind = VK_TRUE;
        // Vulkan 1.3 features (Dynamic Rendering, Sync2)
        vk::PhysicalDeviceVulkan13Features features13{};
        features13.dynamicRendering = VK_TRUE;
        features13.synchronization2 = VK_TRUE;
        features12.timelineSemaphore = VK_TRUE;
        // Chain features: 13 -> 12 -> Core
        features13.pNext = &features12;

        // 3. Create Info
        vk::DeviceCreateInfo createInfo{};
        createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
        createInfo.pQueueCreateInfos = queueCreateInfos.data();
        createInfo.pEnabledFeatures = &featuresCore;
        createInfo.enabledExtensionCount = static_cast<uint32_t>(desc.requiredExtensions.size());
        createInfo.ppEnabledExtensionNames = desc.requiredExtensions.data();

        createInfo.pNext = &features13;

        m_device = m_physicalDevice->physicalDevice().createDevice(createInfo);

        m_graphicsQueueFamily = graphicsFamily;
        m_computeQueueFamily = computeFamily != VK_QUEUE_FAMILY_IGNORED ? computeFamily : graphicsFamily;
        m_transferQueueFamily = graphicsFamily;

        core::Logger::info("Logical device created. GraphicsQ={}, ComputeQ={}", m_graphicsQueueFamily,
                           m_computeQueueFamily);
    }

    void VulkanRHIDevice::selectQueueFamilies()
    {
        m_graphicsQueue = m_device.getQueue(m_graphicsQueueFamily, 0);
        m_computeQueue = m_device.getQueue(m_computeQueueFamily, 0);
        m_transferQueue = m_device.getQueue(m_transferQueueFamily, 0);
    }

    void VulkanRHIDevice::createAllocator()
    {
        VmaVulkanFunctions funcs{};
        funcs.vkGetPhysicalDeviceProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceProperties;
        funcs.vkGetPhysicalDeviceMemoryProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties;
        funcs.vkAllocateMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkAllocateMemory;
        funcs.vkFreeMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkFreeMemory;
        funcs.vkMapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkMapMemory;
        funcs.vkUnmapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkUnmapMemory;
        funcs.vkFlushMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkFlushMappedMemoryRanges;
        funcs.vkInvalidateMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkInvalidateMappedMemoryRanges;
        funcs.vkBindBufferMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory;
        funcs.vkBindImageMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory;
        funcs.vkGetBufferMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements;
        funcs.vkGetImageMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements;
        funcs.vkCreateBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateBuffer;
        funcs.vkDestroyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyBuffer;
        funcs.vkCreateImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateImage;
        funcs.vkDestroyImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyImage;
        funcs.vkCmdCopyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCmdCopyBuffer;


        funcs.vkGetBufferMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements2;
        funcs.vkGetImageMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements2;
        funcs.vkBindBufferMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory2;
        funcs.vkBindImageMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory2;
        funcs.vkGetPhysicalDeviceMemoryProperties2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties2;
        funcs.vkGetDeviceBufferMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetDeviceBufferMemoryRequirements;

        VmaAllocatorCreateInfo allocatorInfo{};
        allocatorInfo.vulkanApiVersion = VK_API_VERSION_1_3;
        allocatorInfo.physicalDevice = m_physicalDevice->physicalDevice();
        allocatorInfo.device = m_device;
        allocatorInfo.instance = m_physicalDevice->instance();
        allocatorInfo.pVulkanFunctions = &funcs;
        allocatorInfo.flags = VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT;

        vk::Result result = static_cast<vk::Result>(vmaCreateAllocator(&allocatorInfo, &m_allocator));
        if (result != vk::Result::eSuccess)
        {
            throw std::runtime_error("Failed to create VMA allocator: " + vk::to_string(result));
        }
    }

    void VulkanRHIDevice::createCommandPool()
    {
        vk::CommandPoolCreateInfo poolInfo{};
        poolInfo.queueFamilyIndex = m_graphicsQueueFamily;
        poolInfo.flags = vk::CommandPoolCreateFlagBits::eResetCommandBuffer;

        m_commandPool = m_device.createCommandPool(poolInfo);
    }

    void VulkanRHIDevice::createTimelineSemaphore()
    {
        vk::SemaphoreTypeCreateInfo typeInfo{};
        typeInfo.semaphoreType = vk::SemaphoreType::eTimeline;
        typeInfo.initialValue = 0;

        vk::SemaphoreCreateInfo createInfo{};
        createInfo.pNext = &typeInfo;

        m_timelineSemaphore = m_device.createSemaphore(createInfo);
    }

    void VulkanRHIDevice::createDescriptorPool()
    {
        std::array<vk::DescriptorPoolSize, 4> poolSizes{};
        poolSizes[0].type = vk::DescriptorType::eUniformBuffer;
        poolSizes[0].descriptorCount = 1024;
        poolSizes[1].type = vk::DescriptorType::eStorageBuffer;
        poolSizes[1].descriptorCount = 1024;
        poolSizes[2].type = vk::DescriptorType::eCombinedImageSampler;
        poolSizes[2].descriptorCount = 2048;
        poolSizes[3].type = vk::DescriptorType::eStorageImage;
        poolSizes[3].descriptorCount = 256;

        vk::DescriptorPoolCreateInfo poolInfo{};
        poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
        poolInfo.pPoolSizes = poolSizes.data();
        poolInfo.maxSets = 2048;
        poolInfo.flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet;

        m_descriptorPool = m_device.createDescriptorPool(poolInfo);
    }

    std::unique_ptr<RHIBuffer> VulkanRHIDevice::createBuffer(
        uint64_t size,
        BufferUsage usage,
        MemoryUsage memoryUsage)
    {
        BufferDescriptor desc{};
        desc.size = size;
        desc.usage = usage;
        desc.memoryUsage = memoryUsage;

        return std::make_unique<VulkanRHIBuffer>(m_device, m_allocator, desc);
    }

    std::unique_ptr<RHITexture> VulkanRHIDevice::createTexture(
        const Extent3D& extent,
        Format format,
        TextureUsage usage,
        uint32_t mipLevels,
        uint32_t arrayLayers)
    {
        TextureDescriptor desc{};
        desc.extent = extent;
        desc.format = format;
        desc.usage = usage;
        desc.mipLevels = mipLevels;
        desc.arrayLayers = arrayLayers;

        return std::make_unique<VulkanRHITexture>(this, desc);
    }

    std::unique_ptr<RHITexture> VulkanRHIDevice::createCubemap(
        const Extent3D& extent,
        Format format,
        TextureUsage usage,
        uint32_t mipLevels)
    {
        TextureDescriptor desc{};
        desc.extent = extent;
        desc.format = format;
        desc.usage = usage;
        desc.mipLevels = mipLevels;
        desc.arrayLayers = 6;  // 6 faces for cubemap
        desc.type = TextureType::TextureCube;  // Specify cubemap type

        return std::make_unique<VulkanRHITexture>(this, desc);
    }

    std::unique_ptr<RHISampler> VulkanRHIDevice::createSampler(
        Filter minFilter,
        Filter magFilter,
        SamplerAddressMode addressMode)
    {
        return std::make_unique<VulkanRHISampler>(this, minFilter, magFilter, addressMode);
    }

    std::unique_ptr<RHICommandBuffer> VulkanRHIDevice::createCommandBuffer()
    {
        return std::make_unique<VulkanRHICommandBuffer>(this);
    }

    std::unique_ptr<RHIPipeline> VulkanRHIDevice::createGraphicsPipeline(
        const GraphicsPipelineDescriptor& desc)
    {
        return std::make_unique<VulkanRHIPipeline>(this, desc);
    }

    std::unique_ptr<RHIPipeline> VulkanRHIDevice::createComputePipeline(
        const ComputePipelineDescriptor& desc)
    {
        return std::make_unique<VulkanRHIPipeline>(this, desc);
    }

    std::unique_ptr<RHIDescriptorSetLayout> VulkanRHIDevice::createDescriptorSetLayout(
        const DescriptorSetLayout& desc)
    {
        std::vector<vk::DescriptorSetLayoutBinding> bindings;
        bindings.reserve(desc.bindings.size());

        for (const auto& binding : desc.bindings)
        {
            vk::DescriptorSetLayoutBinding vkBinding{};
            vkBinding.binding = binding.binding;
            vkBinding.descriptorType = VulkanUtils::toVkDescriptorType(binding.type);
            vkBinding.descriptorCount = binding.count;
            vkBinding.stageFlags = VulkanUtils::toVkShaderStage(binding.stages);
            bindings.push_back(vkBinding);
        }

        vk::DescriptorSetLayoutCreateInfo layoutInfo{};
        layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
        layoutInfo.pBindings = bindings.data();

        vk::DescriptorSetLayout layout = m_device.createDescriptorSetLayout(layoutInfo);
        return std::make_unique<VulkanRHIDescriptorSetLayout>(this, layout, desc);
    }

    std::unique_ptr<RHIDescriptorSet> VulkanRHIDevice::allocateDescriptorSet(
        RHIDescriptorSetLayout* layout)
    {
        auto* vkLayout = static_cast<VulkanRHIDescriptorSetLayout*>(layout);

        vk::DescriptorSetAllocateInfo allocInfo{};
        allocInfo.descriptorPool = m_descriptorPool;
        vk::DescriptorSetLayout layoutHandle = vkLayout->layout();
        allocInfo.descriptorSetCount = 1;
        allocInfo.pSetLayouts = &layoutHandle;

        auto sets = m_device.allocateDescriptorSets(allocInfo);
        return std::make_unique<VulkanRHIDescriptorSet>(this, vkLayout, sets[0]);
    }

    void VulkanRHIDevice::waitIdle()
    {
        m_device.waitIdle();
    }

    void VulkanRHIDevice::waitForFences(const std::vector<uint64_t>& fenceValues)
    {
        if (fenceValues.empty()) return;

        std::vector<vk::Semaphore> semaphores(fenceValues.size(), m_timelineSemaphore);

        vk::SemaphoreWaitInfo waitInfo{};
        waitInfo.semaphoreCount = static_cast<uint32_t>(fenceValues.size());
        waitInfo.pSemaphores = semaphores.data();
        waitInfo.pValues = fenceValues.data();

        auto result = m_device.waitSemaphores(waitInfo, UINT64_MAX);
        if (result != vk::Result::eSuccess)
        {
            core::Logger::error("Failed to wait for fences: {}", vk::to_string(result));
        }
    }

    void VulkanRHIDevice::submitCommands(
        RHICommandBuffer* commandBuffer,
        const std::vector<uint64_t>& waitSemaphores,
        const std::vector<uint64_t>& signalSemaphores)
    {
        auto* vkCmdBuffer = static_cast<VulkanRHICommandBuffer*>(commandBuffer);

        vk::SubmitInfo submitInfo{};
        submitInfo.commandBufferCount = 1;
        auto cmdBuf = vkCmdBuffer->commandBuffer();
        submitInfo.pCommandBuffers = &cmdBuf;

        // Timeline Semaphore Synchronization
        vk::TimelineSemaphoreSubmitInfo timelineInfo{};

        std::vector<vk::Semaphore> waitSems(waitSemaphores.size(), m_timelineSemaphore);
        std::vector<vk::PipelineStageFlags> waitStages(waitSemaphores.size(), vk::PipelineStageFlagBits::eAllCommands);
        std::vector<vk::Semaphore> signalSems(signalSemaphores.size(), m_timelineSemaphore);

        if (!waitSemaphores.empty())
        {
            timelineInfo.waitSemaphoreValueCount = static_cast<uint32_t>(waitSemaphores.size());
            timelineInfo.pWaitSemaphoreValues = waitSemaphores.data();

            submitInfo.waitSemaphoreCount = static_cast<uint32_t>(waitSems.size());
            submitInfo.pWaitSemaphores = waitSems.data();
            submitInfo.pWaitDstStageMask = waitStages.data();
        }

        if (!signalSemaphores.empty())
        {
            timelineInfo.signalSemaphoreValueCount = static_cast<uint32_t>(signalSemaphores.size());
            timelineInfo.pSignalSemaphoreValues = signalSemaphores.data();

            submitInfo.signalSemaphoreCount = static_cast<uint32_t>(signalSems.size());
            submitInfo.pSignalSemaphores = signalSems.data();
        }

        submitInfo.pNext = &timelineInfo;

        m_graphicsQueue.submit(submitInfo, nullptr);
    }

    vk::ShaderModule VulkanRHIDevice::createShaderModule(const std::vector<uint32_t>& spirvCode)
    {
        vk::ShaderModuleCreateInfo createInfo{};
        createInfo.codeSize = spirvCode.size() * sizeof(uint32_t);
        createInfo.pCode = spirvCode.data();

        return m_device.createShaderModule(createInfo);
    }

    void VulkanRHIDevice::destroyShaderModule(vk::ShaderModule module)
    {
        m_device.destroyShaderModule(module);
    }

    void VulkanRHIDevice::initBindless()
    {
      // 1. Create Descriptor Set Layout
      std::array<vk::DescriptorSetLayoutBinding, 3> bindings{};

      // Binding 0: Combined Image Samplers (Matches bindless.glsl set=1 binding=0)
      bindings[0].binding = 0;
      bindings[0].descriptorType = vk::DescriptorType::eCombinedImageSampler;
      bindings[0].descriptorCount = MAX_BINDLESS_RESOURCES;
      bindings[0].stageFlags = vk::ShaderStageFlagBits::eAll;

      // Binding 1: Storage Buffers
      bindings[1].binding = 1;
      bindings[1].descriptorType = vk::DescriptorType::eStorageBuffer;
      bindings[1].descriptorCount = MAX_BINDLESS_RESOURCES;
      bindings[1].stageFlags = vk::ShaderStageFlagBits::eAll;

      // Binding 2: Cubemap Samplers
      bindings[2].binding = 2;
      bindings[2].descriptorType = vk::DescriptorType::eCombinedImageSampler;
      bindings[2].descriptorCount = MAX_BINDLESS_RESOURCES;
      bindings[2].stageFlags = vk::ShaderStageFlagBits::eAll;

      std::array<vk::DescriptorBindingFlags, 3> bindingFlags{};
      bindingFlags[0] = vk::DescriptorBindingFlagBits::ePartiallyBound |
                        vk::DescriptorBindingFlagBits::eUpdateAfterBind;
      bindingFlags[1] = vk::DescriptorBindingFlagBits::ePartiallyBound |
                        vk::DescriptorBindingFlagBits::eUpdateAfterBind;
      bindingFlags[2] = vk::DescriptorBindingFlagBits::ePartiallyBound |
                        vk::DescriptorBindingFlagBits::eUpdateAfterBind;

      vk::DescriptorSetLayoutBindingFlagsCreateInfo extendedInfo{};
      extendedInfo.bindingCount = static_cast<uint32_t>(bindingFlags.size());
      extendedInfo.pBindingFlags = bindingFlags.data();

      vk::DescriptorSetLayoutCreateInfo layoutInfo{};
      layoutInfo.pNext = &extendedInfo;
      layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
      layoutInfo.pBindings = bindings.data();
      layoutInfo.flags =
        vk::DescriptorSetLayoutCreateFlagBits::eUpdateAfterBindPool;

      vk::DescriptorSetLayout vkLayout = m_device.createDescriptorSetLayout(layoutInfo);
      
      DescriptorSetLayout layoutDesc;
      layoutDesc.bindings.push_back({0, DescriptorType::CombinedImageSampler, MAX_BINDLESS_RESOURCES, ShaderStage::All});
      layoutDesc.bindings.push_back({1, DescriptorType::StorageBuffer, MAX_BINDLESS_RESOURCES, ShaderStage::All});
      layoutDesc.bindings.push_back({2, DescriptorType::CombinedImageSampler, MAX_BINDLESS_RESOURCES, ShaderStage::All});

      m_bindlessLayout = std::make_unique<VulkanRHIDescriptorSetLayout>(this, vkLayout, layoutDesc);

      // 2. Create Descriptor Pool
      std::array<vk::DescriptorPoolSize, 3> poolSizes{};
      poolSizes[0].type = vk::DescriptorType::eCombinedImageSampler;
      poolSizes[0].descriptorCount = MAX_BINDLESS_RESOURCES * 2; // *2 for textures + cubemaps
      poolSizes[1].type = vk::DescriptorType::eStorageBuffer;
      poolSizes[1].descriptorCount = MAX_BINDLESS_RESOURCES;
      poolSizes[2].type = vk::DescriptorType::eCombinedImageSampler;
      poolSizes[2].descriptorCount = MAX_BINDLESS_RESOURCES;

      vk::DescriptorPoolCreateInfo poolInfo{};
      poolInfo.flags = vk::DescriptorPoolCreateFlagBits::eUpdateAfterBind;
      poolInfo.maxSets = 1; // Only one global bindless set
      poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
      poolInfo.pPoolSizes = poolSizes.data();

      m_bindlessPool = m_device.createDescriptorPool(poolInfo);

      // 3. Allocate Descriptor Set
      vk::DescriptorSetAllocateInfo allocInfo{};
      allocInfo.descriptorPool = m_bindlessPool;
      allocInfo.descriptorSetCount = 1;
      allocInfo.pSetLayouts = &vkLayout;

      m_bindlessSet = m_device.allocateDescriptorSets(allocInfo)[0];
    }

    BindlessHandle VulkanRHIDevice::registerBindlessTexture(RHITexture* texture,
                                                            RHISampler* sampler)
    {
      auto* vkTex = static_cast<VulkanRHITexture*>(texture);
      auto* vkSamp = static_cast<VulkanRHISampler*>(sampler);

      uint32_t index = m_textureIndexCounter++;

      vk::DescriptorImageInfo imageInfo{};
      imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
      imageInfo.imageView = vkTex->imageView();
      imageInfo.sampler = vkSamp->sampler();

      vk::WriteDescriptorSet write{};
      write.dstSet = m_bindlessSet;
      write.dstBinding = 0; // Binding 0 is Textures
      write.dstArrayElement = index;
      write.descriptorType = vk::DescriptorType::eCombinedImageSampler;
      write.descriptorCount = 1;
      write.pImageInfo = &imageInfo;

      m_device.updateDescriptorSets(write, nullptr);

      return { index };
    }

    BindlessHandle VulkanRHIDevice::registerBindlessCubemap(RHITexture* texture, RHISampler* sampler)
    {
      auto* vkTex = static_cast<VulkanRHITexture*>(texture);
      auto* vkSamp = static_cast<VulkanRHISampler*>(sampler);

      uint32_t index = m_cubemapIndexCounter++;

      vk::DescriptorImageInfo imageInfo{};
      imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
      imageInfo.imageView = vkTex->imageView();
      imageInfo.sampler = vkSamp->sampler();

      vk::WriteDescriptorSet write{};
      write.dstSet = m_bindlessSet;
      write.dstBinding = 2; // Binding 2 is Cubemaps
      write.dstArrayElement = index;
      write.descriptorType = vk::DescriptorType::eCombinedImageSampler;
      write.descriptorCount = 1;
      write.pImageInfo = &imageInfo;

      m_device.updateDescriptorSets(write, nullptr);

      return { index };
    }

    BindlessHandle VulkanRHIDevice::registerBindlessBuffer(RHIBuffer* buffer)
    {
      auto* vkBuf = static_cast<VulkanRHIBuffer*>(buffer);
      uint32_t index = m_bufferIndexCounter++;

      vk::DescriptorBufferInfo bufferInfo{};
      bufferInfo.buffer = vkBuf->buffer();
      bufferInfo.offset = 0;
      bufferInfo.range = VK_WHOLE_SIZE;

      vk::WriteDescriptorSet write{};
      write.dstSet = m_bindlessSet;
      write.dstBinding = 1; // Binding 1 is Buffers
      write.dstArrayElement = index;
      write.descriptorType = vk::DescriptorType::eStorageBuffer;
      write.descriptorCount = 1;
      write.pBufferInfo = &bufferInfo;

      m_device.updateDescriptorSets(write, nullptr);

      return { index };
    }

        void* VulkanRHIDevice::getBindlessDescriptorSetNative()

        {

          return m_bindlessSet;

        }

    

        RHIDescriptorSetLayout* VulkanRHIDevice::getBindlessDescriptorSetLayout()

        {

            return m_bindlessLayout.get();

        }

    } // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_pipeline.cpp">
#include "pnkr/rhi/vulkan/vulkan_pipeline.hpp"
#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"
#include "pnkr/rhi/vulkan/vulkan_descriptor.hpp"
#include "pnkr/core/logger.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    // Graphics pipeline constructor
    VulkanRHIPipeline::VulkanRHIPipeline(VulkanRHIDevice* device,
                                         const GraphicsPipelineDescriptor& desc)
        : m_device(device)
          , m_bindPoint(PipelineBindPoint::Graphics)
    {
        createGraphicsPipeline(desc);
    }

    // Compute pipeline constructor
    VulkanRHIPipeline::VulkanRHIPipeline(VulkanRHIDevice* device,
                                         const ComputePipelineDescriptor& desc)
        : m_device(device)
          , m_bindPoint(PipelineBindPoint::Compute)
    {
        createComputePipeline(desc);
    }

    VulkanRHIPipeline::~VulkanRHIPipeline()
    {
        if (m_pipeline)
        {
            m_device->device().destroyPipeline(m_pipeline);
        }

        if (m_pipelineLayout)
        {
            m_device->device().destroyPipelineLayout(m_pipelineLayout);
        }

        cleanupShaderModules();
    }

    void VulkanRHIPipeline::createGraphicsPipeline(const GraphicsPipelineDescriptor& desc)
    {
        // Create shader modules
        std::vector<vk::PipelineShaderStageCreateInfo> shaderStages;

        for (const auto& shaderDesc : desc.shaders)
        {
            vk::ShaderModule module = createShaderModule(shaderDesc);

            vk::PipelineShaderStageCreateInfo stageInfo{};
            vk::ShaderStageFlags flags = VulkanUtils::toVkShaderStage(shaderDesc.stage);
            // Get the first bit set
            if (flags & vk::ShaderStageFlagBits::eVertex)
                stageInfo.stage = vk::ShaderStageFlagBits::eVertex;
            else if (flags & vk::ShaderStageFlagBits::eFragment)
                stageInfo.stage = vk::ShaderStageFlagBits::eFragment;
            else if (flags & vk::ShaderStageFlagBits::eCompute)
                stageInfo.stage = vk::ShaderStageFlagBits::eCompute;
            else if (flags & vk::ShaderStageFlagBits::eGeometry)
                stageInfo.stage = vk::ShaderStageFlagBits::eGeometry;
            stageInfo.module = module;
            stageInfo.pName = shaderDesc.entryPoint.c_str();

            shaderStages.push_back(stageInfo);
        }

        // Vertex input state
        std::vector<vk::VertexInputBindingDescription> bindingDescs;
        for (const auto& binding : desc.vertexBindings)
        {
            vk::VertexInputBindingDescription bindingDesc{};
            bindingDesc.binding = binding.binding;
            bindingDesc.stride = binding.stride;
            bindingDesc.inputRate = binding.inputRate == VertexInputRate::Vertex
                                        ? vk::VertexInputRate::eVertex
                                        : vk::VertexInputRate::eInstance;
            bindingDescs.push_back(bindingDesc);
        }

        std::vector<vk::VertexInputAttributeDescription> attributeDescs;
        for (const auto& attribute : desc.vertexAttributes)
        {
            vk::VertexInputAttributeDescription attrDesc{};
            attrDesc.location = attribute.location;
            attrDesc.binding = attribute.binding;
            attrDesc.format = VulkanUtils::toVkFormat(attribute.format);
            attrDesc.offset = attribute.offset;
            attributeDescs.push_back(attrDesc);
        }

        vk::PipelineVertexInputStateCreateInfo vertexInputInfo{};
        vertexInputInfo.vertexBindingDescriptionCount = static_cast<uint32_t>(bindingDescs.size());
        vertexInputInfo.pVertexBindingDescriptions = bindingDescs.data();
        vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescs.size());
        vertexInputInfo.pVertexAttributeDescriptions = attributeDescs.data();

        // Input assembly state
        vk::PipelineInputAssemblyStateCreateInfo inputAssembly{};
        inputAssembly.topology = VulkanUtils::toVkTopology(desc.topology);
        inputAssembly.primitiveRestartEnable = VK_FALSE;

        // Viewport state (dynamic)
        vk::PipelineViewportStateCreateInfo viewportState{};
        viewportState.viewportCount = 1;
        viewportState.scissorCount = 1;

        // Rasterization state
        vk::PipelineRasterizationStateCreateInfo rasterizer{};
        rasterizer.depthClampEnable = VK_FALSE;
        rasterizer.rasterizerDiscardEnable = VK_FALSE;
        rasterizer.polygonMode = VulkanUtils::toVkPolygonMode(desc.rasterization.polygonMode);
        rasterizer.cullMode = VulkanUtils::toVkCullMode(desc.rasterization.cullMode);
        rasterizer.frontFace = desc.rasterization.frontFaceCCW
                                   ? vk::FrontFace::eCounterClockwise
                                   : vk::FrontFace::eClockwise;
        rasterizer.depthBiasEnable = VK_FALSE;
        rasterizer.lineWidth = desc.rasterization.lineWidth;

        // Multisample state
        vk::PipelineMultisampleStateCreateInfo multisampling{};
        multisampling.sampleShadingEnable = VK_FALSE;
        multisampling.rasterizationSamples = vk::SampleCountFlagBits::e1;

        // Depth/stencil state
        vk::PipelineDepthStencilStateCreateInfo depthStencil{};
        depthStencil.depthTestEnable = desc.depthStencil.depthTestEnable;
        depthStencil.depthWriteEnable = desc.depthStencil.depthWriteEnable;
        depthStencil.depthCompareOp = VulkanUtils::toVkCompareOp(desc.depthStencil.depthCompareOp);
        depthStencil.depthBoundsTestEnable = VK_FALSE;
        depthStencil.stencilTestEnable = desc.depthStencil.stencilTestEnable;

        // Color blend state
        std::vector<vk::PipelineColorBlendAttachmentState> colorBlendAttachments;
        for (const auto& attachment : desc.blend.attachments)
        {
            vk::PipelineColorBlendAttachmentState blendAttachment{};
            blendAttachment.blendEnable = attachment.blendEnable;
            blendAttachment.srcColorBlendFactor = VulkanUtils::toVkBlendFactor(attachment.srcColorBlendFactor);
            blendAttachment.dstColorBlendFactor = VulkanUtils::toVkBlendFactor(attachment.dstColorBlendFactor);
            blendAttachment.colorBlendOp = VulkanUtils::toVkBlendOp(attachment.colorBlendOp);
            blendAttachment.srcAlphaBlendFactor = VulkanUtils::toVkBlendFactor(attachment.srcAlphaBlendFactor);
            blendAttachment.dstAlphaBlendFactor = VulkanUtils::toVkBlendFactor(attachment.dstAlphaBlendFactor);
            blendAttachment.alphaBlendOp = VulkanUtils::toVkBlendOp(attachment.alphaBlendOp);
            blendAttachment.colorWriteMask = vk::ColorComponentFlagBits::eR |
                vk::ColorComponentFlagBits::eG |
                vk::ColorComponentFlagBits::eB |
                vk::ColorComponentFlagBits::eA;
            colorBlendAttachments.push_back(blendAttachment);
        }

        vk::PipelineColorBlendStateCreateInfo colorBlending{};
        colorBlending.logicOpEnable = VK_FALSE;
        colorBlending.attachmentCount = static_cast<uint32_t>(colorBlendAttachments.size());
        colorBlending.pAttachments = colorBlendAttachments.data();

        // Dynamic state
        std::vector dynamicStates = {
            vk::DynamicState::eViewport,
            vk::DynamicState::eScissor
        };

        vk::PipelineDynamicStateCreateInfo dynamicState{};
        dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
        dynamicState.pDynamicStates = dynamicStates.data();

        // Create descriptor set layouts
        createDescriptorSetLayouts(desc.descriptorSets);

        // Create pipeline layout
        createPipelineLayout(desc.pushConstants);

        // Dynamic rendering (Vulkan 1.3)
        std::vector<vk::Format> colorFormats;
        for (auto format : desc.colorFormats)
        {
            colorFormats.push_back(VulkanUtils::toVkFormat(format));
        }

        vk::PipelineRenderingCreateInfo renderingInfo{};
        renderingInfo.colorAttachmentCount = static_cast<uint32_t>(colorFormats.size());
        renderingInfo.pColorAttachmentFormats = colorFormats.data();
        renderingInfo.depthAttachmentFormat = VulkanUtils::toVkFormat(desc.depthFormat);

        // Create graphics pipeline
        vk::GraphicsPipelineCreateInfo pipelineInfo{};
        pipelineInfo.stageCount = static_cast<uint32_t>(shaderStages.size());
        pipelineInfo.pStages = shaderStages.data();
        pipelineInfo.pVertexInputState = &vertexInputInfo;
        pipelineInfo.pInputAssemblyState = &inputAssembly;
        pipelineInfo.pViewportState = &viewportState;
        pipelineInfo.pRasterizationState = &rasterizer;
        pipelineInfo.pMultisampleState = &multisampling;
        pipelineInfo.pDepthStencilState = &depthStencil;
        pipelineInfo.pColorBlendState = &colorBlending;
        pipelineInfo.pDynamicState = &dynamicState;
        pipelineInfo.layout = m_pipelineLayout;
        pipelineInfo.renderPass = nullptr; // Using dynamic rendering
        pipelineInfo.subpass = 0;
        pipelineInfo.pNext = &renderingInfo;

        auto result = m_device->device().createGraphicsPipeline(nullptr, pipelineInfo);
        if (result.result != vk::Result::eSuccess)
        {
            core::Logger::error("Failed to create graphics pipeline: {}", vk::to_string(result.result));
            throw std::runtime_error("Graphics pipeline creation failed");
        }

        m_pipeline = result.value;

        // Set debug name
        if (desc.debugName)
        {
            vk::DebugUtilsObjectNameInfoEXT nameInfo{};
            nameInfo.objectType = vk::ObjectType::ePipeline;
            nameInfo.objectHandle = reinterpret_cast<uint64_t>(static_cast<VkPipeline>(m_pipeline));
            nameInfo.pObjectName = desc.debugName;


            m_device->device().setDebugUtilsObjectNameEXT(nameInfo);
        }
    }

    void VulkanRHIPipeline::createComputePipeline(const ComputePipelineDescriptor& desc)
    {
        // Create shader module
        vk::ShaderModule module = createShaderModule(desc.shader);

        vk::PipelineShaderStageCreateInfo shaderStage{};
        shaderStage.stage = vk::ShaderStageFlagBits::eCompute;
        shaderStage.module = module;
        shaderStage.pName = desc.shader.entryPoint.c_str();

        // Create descriptor set layouts
        createDescriptorSetLayouts(desc.descriptorSets);

        // Create pipeline layout
        createPipelineLayout(desc.pushConstants);

        // Create compute pipeline
        vk::ComputePipelineCreateInfo pipelineInfo{};
        pipelineInfo.stage = shaderStage;
        pipelineInfo.layout = m_pipelineLayout;

        auto result = m_device->device().createComputePipeline(nullptr, pipelineInfo);
        if (result.result != vk::Result::eSuccess)
        {
            core::Logger::error("Failed to create compute pipeline: {}", vk::to_string(result.result));
            throw std::runtime_error("Compute pipeline creation failed");
        }

        m_pipeline = result.value;

        // Set debug name
        if (desc.debugName)
        {
            vk::DebugUtilsObjectNameInfoEXT nameInfo{};
            nameInfo.objectType = vk::ObjectType::ePipeline;
            nameInfo.objectHandle = reinterpret_cast<uint64_t>(static_cast<VkPipeline>(m_pipeline));
            nameInfo.pObjectName = desc.debugName;


            m_device->device().setDebugUtilsObjectNameEXT(nameInfo);
        }
    }

    void VulkanRHIPipeline::createDescriptorSetLayouts(const std::vector<DescriptorSetLayout>& layouts)
    {
        for (size_t i = 0; i < layouts.size(); ++i)
        {
            const auto& setLayout = layouts[i];

            // FIX: If this is Set 1 (Bindless), use the global layout from the device
            // This avoids mismatch errors where Reflection thinks size is 1 but actual set is 200k.
            // Also ensures UpdateAfterBind flags are present.
            if (i == 1 && m_device->getBindlessDescriptorSetLayout())
            {
                auto* bindlessLayout = static_cast<VulkanRHIDescriptorSetLayout*>(m_device->getBindlessDescriptorSetLayout());
                m_descriptorSetLayouts.push_back(
                    std::make_unique<VulkanRHIDescriptorSetLayout>(
                        m_device, bindlessLayout->layout(), setLayout, false /* don't own */)
                );
                continue;
            }

            std::vector<vk::DescriptorSetLayoutBinding> bindings;

            for (const auto& binding : setLayout.bindings)
            {
                vk::DescriptorSetLayoutBinding vkBinding{};
                vkBinding.binding = binding.binding;
                vkBinding.descriptorType = VulkanUtils::toVkDescriptorType(binding.type);
                vkBinding.descriptorCount = binding.count;
                vkBinding.stageFlags = VulkanUtils::toVkShaderStage(binding.stages);

                bindings.push_back(vkBinding);
            }

            vk::DescriptorSetLayoutCreateInfo layoutInfo{};
            layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
            layoutInfo.pBindings = bindings.data();

            vk::DescriptorSetLayout layout = m_device->device().createDescriptorSetLayout(layoutInfo);
            m_descriptorSetLayouts.push_back(
                std::make_unique<VulkanRHIDescriptorSetLayout>(m_device, layout, setLayout));
        }
    }

    void VulkanRHIPipeline::createPipelineLayout(const std::vector<PushConstantRange>& pushConstants)
    {
        // Convert push constant ranges
        std::vector<vk::PushConstantRange> vkPushConstants;
        for (const auto& range : pushConstants)
        {
            vk::PushConstantRange vkRange{};
            vkRange.stageFlags = VulkanUtils::toVkShaderStage(range.stages);
            vkRange.offset = range.offset;
            vkRange.size = range.size;

            vkPushConstants.push_back(vkRange);
        }

        vk::PipelineLayoutCreateInfo layoutInfo{};
        std::vector<vk::DescriptorSetLayout> vkLayouts;
        vkLayouts.reserve(m_descriptorSetLayouts.size());
        for (const auto& layout : m_descriptorSetLayouts)
        {
            vkLayouts.push_back(layout->layout());
        }

        layoutInfo.setLayoutCount = static_cast<uint32_t>(vkLayouts.size());
        layoutInfo.pSetLayouts = vkLayouts.data();
        layoutInfo.pushConstantRangeCount = static_cast<uint32_t>(vkPushConstants.size());
        layoutInfo.pPushConstantRanges = vkPushConstants.data();

        m_pipelineLayout = m_device->device().createPipelineLayout(layoutInfo);
    }

    vk::ShaderModule VulkanRHIPipeline::createShaderModule(const ShaderModuleDescriptor& desc)
    {
        vk::ShaderModuleCreateInfo createInfo{};
        createInfo.codeSize = desc.spirvCode.size() * sizeof(uint32_t);
        createInfo.pCode = desc.spirvCode.data();

        vk::ShaderModule module = m_device->device().createShaderModule(createInfo);
        m_shaderModules.push_back(module);

        return module;
    }

    void VulkanRHIPipeline::cleanupShaderModules()
    {
        for (auto module : m_shaderModules)
        {
            m_device->device().destroyShaderModule(module);
        }
        m_shaderModules.clear();
    }

    RHIDescriptorSetLayout* VulkanRHIPipeline::descriptorSetLayout(uint32_t setIndex) const
    {
        if (setIndex >= m_descriptorSetLayouts.size())
        {
            return nullptr;
        }
        return m_descriptorSetLayouts[setIndex].get();
    }

    uint32_t VulkanRHIPipeline::descriptorSetLayoutCount() const
    {
        return static_cast<uint32_t>(m_descriptorSetLayouts.size());
    }
} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_sampler.cpp">
#include "pnkr/rhi/vulkan/vulkan_sampler.hpp"

#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    VulkanRHISampler::VulkanRHISampler(VulkanRHIDevice* device,
                                       Filter minFilter,
                                       Filter magFilter,
                                       SamplerAddressMode addressMode)
        : m_device(device)
    {
        vk::SamplerCreateInfo samplerInfo{};
        samplerInfo.magFilter = VulkanUtils::toVkFilter(magFilter);
        samplerInfo.minFilter = VulkanUtils::toVkFilter(minFilter);
        samplerInfo.addressModeU = VulkanUtils::toVkAddressMode(addressMode);
        samplerInfo.addressModeV = VulkanUtils::toVkAddressMode(addressMode);
        samplerInfo.addressModeW = VulkanUtils::toVkAddressMode(addressMode);
        
        // Anisotropic filtering
        samplerInfo.anisotropyEnable = VK_TRUE;
        samplerInfo.maxAnisotropy = 16.0f;
        
        // Border color
        samplerInfo.borderColor = vk::BorderColor::eIntOpaqueBlack;
        
        // Unnormalized coordinates
        samplerInfo.unnormalizedCoordinates = VK_FALSE;
        
        // Comparison
        samplerInfo.compareEnable = VK_FALSE;
        samplerInfo.compareOp = vk::CompareOp::eAlways;
        
        // Mipmapping
        samplerInfo.mipmapMode = minFilter == Filter::Linear 
            ? vk::SamplerMipmapMode::eLinear 
            : vk::SamplerMipmapMode::eNearest;
        samplerInfo.mipLodBias = 0.0f;
        samplerInfo.minLod = 0.0f;
        samplerInfo.maxLod = VK_LOD_CLAMP_NONE;

        m_sampler = m_device->device().createSampler(samplerInfo);
    }

    VulkanRHISampler::~VulkanRHISampler()
    {
        if (m_sampler) {
            m_device->device().destroySampler(m_sampler);
        }
    }

} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_swapchain.cpp">
#include "pnkr/rhi/vulkan/vulkan_swapchain.hpp"

#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"
#include "pnkr/core/logger.hpp"
#include "pnkr/platform/window.hpp"

#include <SDL3/SDL_vulkan.h>
#include <algorithm>
#include <limits>
#include <stdexcept>

namespace pnkr::renderer::rhi::vulkan
{
    namespace
    {
        struct SwapchainSupport
        {
            vk::SurfaceCapabilitiesKHR caps{};
            std::vector<vk::SurfaceFormatKHR> formats;
            std::vector<vk::PresentModeKHR> presentModes;
        };

        SwapchainSupport querySwapchainSupport(vk::PhysicalDevice pd, vk::SurfaceKHR surface)
        {
            SwapchainSupport s{};
            s.caps = pd.getSurfaceCapabilitiesKHR(surface);
            s.formats = pd.getSurfaceFormatsKHR(surface);
            s.presentModes = pd.getSurfacePresentModesKHR(surface);
            return s;
        }
    }

    VulkanRHISwapchain::VulkanRHISwapchain(VulkanRHIDevice* device, platform::Window& window, Format preferredFormat)
        : m_device(device), m_window(&window)
    {
        if (!m_device)
            throw std::runtime_error("[VulkanRHISwapchain] device is null");

        createSurface();

        createSwapchain(preferredFormat,
                        static_cast<uint32_t>(window.width()),
                        static_cast<uint32_t>(window.height()));

        createSyncObjects();

        core::Logger::info("[VulkanRHISwapchain] Created ({} images, {}x{}, format={})",
                           static_cast<uint32_t>(m_images.size()),
                           m_extent.width, m_extent.height,
                           vk::to_string(m_vkFormat));
    }

    VulkanRHISwapchain::~VulkanRHISwapchain()
    {
        if (!m_device)
            return;

        // Ensure GPU is idle before tearing down WSI objects.
        try { m_device->device().waitIdle(); }
        catch (...)
        {
        }

        destroySwapchain();
        destroySyncObjects();

        if (m_surface)
        {
            m_device->instance().destroySurfaceKHR(m_surface);
            m_surface = nullptr;
        }
    }

    void VulkanRHISwapchain::createSurface()
    {
        VkSurfaceKHR raw = VK_NULL_HANDLE;

        if (!SDL_Vulkan_CreateSurface(
            m_window->get(),
            static_cast<VkInstance>(m_device->instance()),
            nullptr,
            &raw))
        {
            throw std::runtime_error(
                std::string("[VulkanRHISwapchain] SDL_Vulkan_CreateSurface failed: ") + SDL_GetError());
        }

        m_surface = vk::SurfaceKHR(raw);
    }

    vk::SurfaceFormatKHR VulkanRHISwapchain::chooseSurfaceFormat(
        const std::vector<vk::SurfaceFormatKHR>& formats,
        Format preferred) const
    {
        const vk::Format preferredVk = VulkanUtils::toVkFormat(preferred);

        // Prefer exact match (format + srgb nonlinear).
        for (const auto& f : formats)
        {
            if (f.format == preferredVk && f.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear)
                return f;
        }

        // Otherwise, prefer an sRGB colorspace with a common 8-bit format.
        for (const auto& f : formats)
        {
            if (f.colorSpace != vk::ColorSpaceKHR::eSrgbNonlinear)
                continue;

            if (f.format == vk::Format::eB8G8R8A8Srgb ||
                f.format == vk::Format::eB8G8R8A8Unorm ||
                f.format == vk::Format::eR8G8B8A8Srgb ||
                f.format == vk::Format::eR8G8B8A8Unorm)
            {
                return f;
            }
        }

        // Fallback: first supported.
        return formats.empty() ? vk::SurfaceFormatKHR{} : formats[0];
    }

    vk::PresentModeKHR VulkanRHISwapchain::choosePresentMode(const std::vector<vk::PresentModeKHR>& modes) const
    {
        // Keep it simple for now: vsync on.
        // FIFO is guaranteed by spec.
        (void)modes;
        return vk::PresentModeKHR::eFifo;
    }

    vk::Extent2D VulkanRHISwapchain::chooseExtent(
        const vk::SurfaceCapabilitiesKHR& caps,
        uint32_t width,
        uint32_t height) const
    {
        if (caps.currentExtent.width != std::numeric_limits<uint32_t>::max())
            return caps.currentExtent;

        vk::Extent2D actual{};
        actual.width = std::clamp(width, caps.minImageExtent.width, caps.maxImageExtent.width);
        actual.height = std::clamp(height, caps.minImageExtent.height, caps.maxImageExtent.height);
        return actual;
    }

    void VulkanRHISwapchain::createSwapchain(Format preferredFormat, uint32_t width, uint32_t height)
    {
        if (!m_surface)
            throw std::runtime_error("[VulkanRHISwapchain] createSwapchain: surface not initialized");

        auto pd = m_device->vkPhysicalDevice();
        auto dev = m_device->device();

        const auto support = querySwapchainSupport(pd, m_surface);
        if (support.formats.empty())
            throw std::runtime_error("[VulkanRHISwapchain] Surface has no supported formats");
        if (support.presentModes.empty())
            throw std::runtime_error("[VulkanRHISwapchain] Surface has no supported present modes");

        const vk::SurfaceFormatKHR surfaceFormat = chooseSurfaceFormat(support.formats, preferredFormat);
        const vk::PresentModeKHR presentMode = choosePresentMode(support.presentModes);
        const vk::Extent2D extent = chooseExtent(support.caps, width, height);

        // Image count: prefer min+1, clamp to max.
        uint32_t imageCount = support.caps.minImageCount + 1;
        if (support.caps.maxImageCount > 0 && imageCount > support.caps.maxImageCount)
            imageCount = support.caps.maxImageCount;

        vk::SwapchainCreateInfoKHR sci{};
        sci.surface = m_surface;
        sci.minImageCount = imageCount;
        sci.imageFormat = surfaceFormat.format;
        sci.imageColorSpace = surfaceFormat.colorSpace;
        sci.imageExtent = extent;
        sci.imageArrayLayers = 1;
        sci.imageUsage = vk::ImageUsageFlagBits::eColorAttachment |
            vk::ImageUsageFlagBits::eTransferDst |
            vk::ImageUsageFlagBits::eTransferSrc;

        // Current RHI device does not expose a dedicated present queue; assume graphics queue presents.
        sci.imageSharingMode = vk::SharingMode::eExclusive;

        sci.preTransform = support.caps.currentTransform;

        const vk::CompositeAlphaFlagBitsKHR preferredAlpha[] = {
            vk::CompositeAlphaFlagBitsKHR::eOpaque,
            vk::CompositeAlphaFlagBitsKHR::eInherit,
            vk::CompositeAlphaFlagBitsKHR::ePreMultiplied,
            vk::CompositeAlphaFlagBitsKHR::ePostMultiplied
        };
        sci.compositeAlpha = vk::CompositeAlphaFlagBitsKHR::eOpaque;
        for (auto a : preferredAlpha)
        {
            if (support.caps.supportedCompositeAlpha & a)
            {
                sci.compositeAlpha = a;
                break;
            }
        }

        sci.presentMode = presentMode;
        sci.clipped = VK_TRUE;
        sci.oldSwapchain = nullptr;

        m_swapchain = dev.createSwapchainKHR(sci);
        m_images = dev.getSwapchainImagesKHR(m_swapchain);

        m_vkFormat = surfaceFormat.format;
        m_rhiFormat = VulkanUtils::fromVkFormat(m_vkFormat);
        m_extent = extent;

        // Views
        m_views.resize(m_images.size());
        for (size_t i = 0; i < m_images.size(); ++i)
        {
            vk::ImageViewCreateInfo ivci{};
            ivci.image = m_images[i];
            ivci.viewType = vk::ImageViewType::e2D;
            ivci.format = m_vkFormat;
            ivci.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
            ivci.subresourceRange.baseMipLevel = 0;
            ivci.subresourceRange.levelCount = 1;
            ivci.subresourceRange.baseArrayLayer = 0;
            ivci.subresourceRange.layerCount = 1;

            m_views[i] = dev.createImageView(ivci);
        }

        // Wrap into non-owning RHI textures.
        m_wrapped.clear();
        m_wrapped.reserve(m_images.size());
        const Extent3D ext3{m_extent.width, m_extent.height, 1};

        for (size_t i = 0; i < m_images.size(); ++i)
        {
            m_wrapped.push_back(std::make_unique<VulkanRHISwapchainImage>(m_images[i], m_views[i], ext3, m_rhiFormat));
        }

        m_layouts.assign(m_images.size(), ResourceLayout::Undefined);
        m_imagesInFlight.assign(m_images.size(), vk::Fence{});
    }

    void VulkanRHISwapchain::destroySwapchain()
    {
        if (!m_device)
            return;

        auto dev = m_device->device();

        // Per-swapchain-image semaphores must be destroyed alongside the swapchain.
        for (auto s : m_renderFinished)
        {
            if (s)
                dev.destroySemaphore(s);
        }
        m_renderFinished.clear();

        for (auto& view : m_views)
        {
            if (view)
                dev.destroyImageView(view);
        }
        m_views.clear();

        m_wrapped.clear();
        m_images.clear();
        m_layouts.clear();
        m_imagesInFlight.clear();

        if (m_swapchain)
        {
            dev.destroySwapchainKHR(m_swapchain);
            m_swapchain = nullptr;
        }

        m_vkFormat = vk::Format::eUndefined;
        m_rhiFormat = Format::Undefined;
        m_extent = vk::Extent2D{};
    }

    void VulkanRHISwapchain::createSyncObjects()
    {
        auto dev = m_device->device();

        vk::SemaphoreCreateInfo semInfo{};
        vk::FenceCreateInfo fenceInfo{vk::FenceCreateFlagBits::eSignaled};

        // Per-frame objects are created once and reused across swapchain recreations.
        if (m_imageAvailable.empty())
        {
            m_imageAvailable.resize(m_framesInFlight);
            m_inFlightFences.resize(m_framesInFlight);

            for (uint32_t i = 0; i < m_framesInFlight; ++i)
            {
                m_imageAvailable[i] = dev.createSemaphore(semInfo);
                m_inFlightFences[i] = dev.createFence(fenceInfo);
            }
        }

        // Per-image render-finished semaphores (created after swapchain images exist).
        // This avoids Vulkan validation errors related to swapchain semaphore reuse.
        m_renderFinished.resize(m_images.size());
        for (size_t i = 0; i < m_images.size(); ++i)
        {
            m_renderFinished[i] = dev.createSemaphore(semInfo);
        }
    }

    void VulkanRHISwapchain::destroySyncObjects()
    {
        if (!m_device)
            return;

        auto dev = m_device->device();

        // NOTE: m_renderFinished is per swapchain image and is destroyed in destroySwapchain().
        for (auto& s : m_imageAvailable) if (s) dev.destroySemaphore(s);
        for (auto& f : m_inFlightFences) if (f) dev.destroyFence(f);

        m_imageAvailable.clear();
        m_inFlightFences.clear();
    }

    void VulkanRHISwapchain::recreate(uint32_t width, uint32_t height)
    {
        if (!m_device)
            return;

        if (width == 0 || height == 0)
            return;

        m_device->device().waitIdle();

        destroySwapchain();
        createSwapchain(m_rhiFormat != Format::Undefined ? m_rhiFormat : Format::B8G8R8A8_SRGB, width, height);
        createSyncObjects();

        core::Logger::info("[VulkanRHISwapchain] Recreated ({} images, {}x{}, format={})",
                           static_cast<uint32_t>(m_images.size()),
                           m_extent.width, m_extent.height,
                           vk::to_string(m_vkFormat));
    }

    bool VulkanRHISwapchain::beginFrame(uint32_t frameIndex, RHICommandBuffer* cmd, SwapchainFrame& out)
    {
        if (!m_swapchain || !m_surface)
            return false;
        if (!cmd)
            return false;

        const uint32_t frame = frameIndex % m_framesInFlight;

        auto dev = m_device->device();

        // Throttle CPU and ensure per-frame resources are available.
        auto res = dev.waitForFences(1, &m_inFlightFences[frame], VK_TRUE, UINT64_MAX);
        if (res != vk::Result::eSuccess)
            throw std::runtime_error("failed to acquire fences");

        // Now it is safe to recycle the command buffer.
        cmd->reset();
        cmd->begin();

        // Acquire
        uint32_t imageIndex = 0;
        vk::Result acquireResult{};
        try
        {
            auto rv = dev.acquireNextImageKHR(m_swapchain, UINT64_MAX, m_imageAvailable[frame], nullptr);
            acquireResult = rv.result;
            imageIndex = rv.value;
        }
        catch (const vk::OutOfDateKHRError&)
        {
            recreate(static_cast<uint32_t>(m_window->width()), static_cast<uint32_t>(m_window->height()));
            cmd->end();
            return false;
        }

        if (acquireResult == vk::Result::eErrorOutOfDateKHR)
        {
            recreate(static_cast<uint32_t>(m_window->width()), static_cast<uint32_t>(m_window->height()));
            cmd->end();
            return false;
        }

        if (acquireResult != vk::Result::eSuccess && acquireResult != vk::Result::eSuboptimalKHR)
        {
            core::Logger::error("[VulkanRHISwapchain] acquireNextImageKHR failed: {}", vk::to_string(acquireResult));
            cmd->end();
            return false;
        }

        if (acquireResult == vk::Result::eSuboptimalKHR)
        {
            recreate(static_cast<uint32_t>(m_window->width()), static_cast<uint32_t>(m_window->height()));
            cmd->end();
            return false;
        }

        // If a previous frame is using this image, wait for it.
        if (m_imagesInFlight.size() == m_images.size() && m_imagesInFlight[imageIndex])
        {
            if (dev.waitForFences(1, &m_imagesInFlight[imageIndex], VK_TRUE, UINT64_MAX)                !=
                vk::Result::eSuccess
            )
            {
                throw std::runtime_error("failed to acquire fences");
            }
        }
        if (m_imagesInFlight.size() == m_images.size())
        {
            m_imagesInFlight[imageIndex] = m_inFlightFences[frame];
        }

        m_currentImage = imageIndex;

        // Ensure the per-image render-finished semaphore exists.
        if (m_currentImage >= m_renderFinished.size())
        {
            cmd->end();
            return false;
        }

        out.imageIndex = imageIndex;
        out.color = m_wrapped[imageIndex].get();

        // Transition acquired image to ColorAttachment.
        {
            RHIMemoryBarrier b{};
            b.texture = out.color;
            b.srcAccessStage = ShaderStage::None;
            b.dstAccessStage = ShaderStage::RenderTarget;
            b.oldLayout = m_layouts[imageIndex];
            b.newLayout = ResourceLayout::ColorAttachment;

            // Use a broad srcStage to cover WSI reads after acquire before writing.
            cmd->pipelineBarrier(ShaderStage::All, ShaderStage::RenderTarget, {b});
            m_layouts[imageIndex] = ResourceLayout::ColorAttachment;
        }

        // Fence will be reset before submit in endFrame.
        return true;
    }

    bool VulkanRHISwapchain::endFrame(uint32_t frameIndex, RHICommandBuffer* cmd)
    {
        if (!m_swapchain || !cmd)
            return false;

        const uint32_t frame = frameIndex % m_framesInFlight;
        auto dev = m_device->device();

        // Transition to Present.
        {
            RHIMemoryBarrier b{};
            b.texture = m_wrapped[m_currentImage].get();
            b.srcAccessStage = ShaderStage::RenderTarget;
            b.dstAccessStage = ShaderStage::All;
            b.oldLayout = m_layouts[m_currentImage];
            b.newLayout = ResourceLayout::Present;

            cmd->pipelineBarrier(ShaderStage::RenderTarget, ShaderStage::All, {b});
            m_layouts[m_currentImage] = ResourceLayout::Present;
        }

        // End recording before submit.
        cmd->end();

        const vk::Semaphore renderFinished = m_renderFinished[m_currentImage];

        // Reset the per-frame fence now that we are about to submit work for this frame.
        if (dev.resetFences(1, &m_inFlightFences[frame] )!= vk::Result::eSuccess)
        {
            throw std::runtime_error("failed to acquire fences");
        }

        vk::CommandBuffer vkCmd = vk::CommandBuffer(static_cast<VkCommandBuffer>(cmd->nativeHandle()));

        vk::PipelineStageFlags waitStage = vk::PipelineStageFlagBits::eColorAttachmentOutput;
        vk::SubmitInfo submit{};
        submit.waitSemaphoreCount = 1;
        submit.pWaitSemaphores = &m_imageAvailable[frame];
        submit.pWaitDstStageMask = &waitStage;
        submit.commandBufferCount = 1;
        submit.pCommandBuffers = &vkCmd;
        submit.signalSemaphoreCount = 1;
        submit.pSignalSemaphores = &renderFinished;

        m_device->graphicsQueue().submit(submit, m_inFlightFences[frame]);

        // Present (assume graphics queue supports present).
        vk::PresentInfoKHR present{};
        present.waitSemaphoreCount = 1;
        present.pWaitSemaphores = &renderFinished;
        present.swapchainCount = 1;
        present.pSwapchains = &m_swapchain;
        present.pImageIndices = &m_currentImage;

        vk::Result presentResult{};
        try
        {
            presentResult = m_device->graphicsQueue().presentKHR(present);
        }
        catch (const vk::OutOfDateKHRError&)
        {
            presentResult = vk::Result::eErrorOutOfDateKHR;
        }

        if (presentResult == vk::Result::eErrorOutOfDateKHR || presentResult == vk::Result::eSuboptimalKHR)
        {
            recreate(static_cast<uint32_t>(m_window->width()), static_cast<uint32_t>(m_window->height()));
            return false;
        }

        return presentResult == vk::Result::eSuccess;
    }
} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_texture.cpp">
#include "pnkr/rhi/vulkan/vulkan_texture.hpp"

#include "pnkr/rhi/vulkan/vulkan_device.hpp"
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"
#include "pnkr/core/logger.hpp"
#include "pnkr/rhi/vulkan/vulkan_command_buffer.hpp"

namespace pnkr::renderer::rhi::vulkan
{
    VulkanRHITexture::VulkanRHITexture(VulkanRHIDevice* device, const TextureDescriptor& desc)
        : m_device(device)
          , m_extent(desc.extent)
          , m_format(desc.format)
          , m_usage(desc.usage)
          , m_mipLevels(desc.mipLevels)
          , m_arrayLayers(desc.arrayLayers)
    {
        createImage(desc);
        createImageView(desc);
    }

    VulkanRHITexture::~VulkanRHITexture()
    {
        if (m_imageView)
        {
            m_device->device().destroyImageView(m_imageView);
        }

        if (m_image)
        {
            vmaDestroyImage(m_device->allocator(),
                            static_cast<VkImage>(m_image),
                            m_allocation);
        }
    }

    void VulkanRHITexture::createImage(const TextureDescriptor& desc)
    {
        vk::ImageCreateInfo imageInfo{};

        // Image type
        switch (desc.type)
        {
        case TextureType::Texture1D:
            imageInfo.imageType = vk::ImageType::e1D;
            break;
        case TextureType::Texture2D:
            imageInfo.imageType = vk::ImageType::e2D;
            break;
        case TextureType::Texture3D:
            imageInfo.imageType = vk::ImageType::e3D;
            break;
        case TextureType::TextureCube:
            imageInfo.imageType = vk::ImageType::e2D;
            imageInfo.flags = vk::ImageCreateFlagBits::eCubeCompatible;
            break;
        }

        imageInfo.extent = VulkanUtils::toVkExtent3D(desc.extent);
        imageInfo.mipLevels = desc.mipLevels;
        imageInfo.arrayLayers = desc.arrayLayers;
        imageInfo.format = VulkanUtils::toVkFormat(desc.format);
        imageInfo.tiling = vk::ImageTiling::eOptimal;
        imageInfo.initialLayout = vk::ImageLayout::eUndefined;
        imageInfo.usage = VulkanUtils::toVkImageUsage(desc.usage);
        imageInfo.samples = vk::SampleCountFlagBits::e1;
        imageInfo.sharingMode = vk::SharingMode::eExclusive;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;

        VkImageCreateInfo cImageInfo = static_cast<VkImageCreateInfo>(imageInfo);
        VkImage cImage;

        vk::Result result = static_cast<vk::Result>(
            vmaCreateImage(m_device->allocator(), &cImageInfo, &allocInfo,
                           &cImage, &m_allocation, nullptr));

        if (result != vk::Result::eSuccess)
        {
            core::Logger::error("Failed to create texture: {}", vk::to_string(result));
            throw std::runtime_error("Texture creation failed");
        }

        m_image = cImage;

        // Set debug name if provided
        if (desc.debugName)
        {
            vk::DebugUtilsObjectNameInfoEXT nameInfo{};
            nameInfo.objectType = vk::ObjectType::eImage;
            nameInfo.objectHandle = reinterpret_cast<uint64_t>(static_cast<VkImage>(m_image));
            nameInfo.pObjectName = desc.debugName;

            m_device->device().setDebugUtilsObjectNameEXT(nameInfo);
        }
    }

    void VulkanRHITexture::createImageView(const TextureDescriptor& desc)
    {
        vk::ImageViewCreateInfo viewInfo{};
        viewInfo.image = m_image;

        // View type
        switch (desc.type)
        {
        case TextureType::Texture1D:
            viewInfo.viewType = desc.arrayLayers > 1 ? vk::ImageViewType::e1DArray : vk::ImageViewType::e1D;
            break;
        case TextureType::Texture2D:
            viewInfo.viewType = desc.arrayLayers > 1 ? vk::ImageViewType::e2DArray : vk::ImageViewType::e2D;
            break;
        case TextureType::Texture3D:
            viewInfo.viewType = vk::ImageViewType::e3D;
            break;
        case TextureType::TextureCube:
            viewInfo.viewType = vk::ImageViewType::eCube;
            break;
        }

        viewInfo.format = VulkanUtils::toVkFormat(desc.format);

        // Component mapping (identity)
        viewInfo.components.r = vk::ComponentSwizzle::eIdentity;
        viewInfo.components.g = vk::ComponentSwizzle::eIdentity;
        viewInfo.components.b = vk::ComponentSwizzle::eIdentity;
        viewInfo.components.a = vk::ComponentSwizzle::eIdentity;

        // Subresource range
        viewInfo.subresourceRange.baseMipLevel = 0;
        viewInfo.subresourceRange.levelCount = desc.mipLevels;
        viewInfo.subresourceRange.baseArrayLayer = 0;
        viewInfo.subresourceRange.layerCount = desc.arrayLayers;

        // Aspect mask
        vk::Format vkFormat = VulkanUtils::toVkFormat(desc.format);
        if (vkFormat == vk::Format::eD16Unorm ||
            vkFormat == vk::Format::eD32Sfloat ||
            vkFormat == vk::Format::eD24UnormS8Uint ||
            vkFormat == vk::Format::eD32SfloatS8Uint)
        {
            viewInfo.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eDepth;
            if (vkFormat == vk::Format::eD24UnormS8Uint ||
                vkFormat == vk::Format::eD32SfloatS8Uint)
            {
                viewInfo.subresourceRange.aspectMask |= vk::ImageAspectFlagBits::eStencil;
            }
        }
        else
        {
            viewInfo.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
        }

        m_imageView = m_device->device().createImageView(viewInfo);
    }

    void VulkanRHITexture::uploadData(
        const void* data,
        uint64_t dataSize,
        const TextureSubresource& subresource)
    {
        uploadDataInternal(data, dataSize, subresource);
    }

    void VulkanRHITexture::uploadDataInternal(
        const void* data,
        uint64_t dataSize,
        const TextureSubresource& subresource)
    {
        // Create staging buffer
        BufferDescriptor stagingDesc{};
        stagingDesc.size = dataSize;
        stagingDesc.usage = BufferUsage::TransferSrc;
        stagingDesc.memoryUsage = MemoryUsage::CPUToGPU;

        auto stagingBuffer = m_device->createBuffer(
            dataSize,
            BufferUsage::TransferSrc,
            MemoryUsage::CPUToGPU);

        // Upload to staging buffer
        stagingBuffer->uploadData(data, dataSize, 0);

        // Create command buffer for transfer
        auto cmdBuffer = m_device->createCommandBuffer();
        cmdBuffer->begin();

        // Transition image to transfer dst
        transitionLayout(vk::ImageLayout::eTransferDstOptimal,
                         static_cast<VulkanRHICommandBuffer*>(cmdBuffer.get())->commandBuffer());

        // Copy buffer to image
        BufferTextureCopyRegion region{};
        region.bufferOffset = 0;
        region.textureSubresource = subresource;
        region.textureExtent = m_extent;

        cmdBuffer->copyBufferToTexture(stagingBuffer.get(), this, region);

        // Transition to shader read optimal
        transitionLayout(vk::ImageLayout::eShaderReadOnlyOptimal,
                         static_cast<VulkanRHICommandBuffer*>(cmdBuffer.get())->commandBuffer());

        cmdBuffer->end();

        // Submit and wait
        m_device->submitCommands(cmdBuffer.get());
        m_device->waitIdle();
    }

    void VulkanRHITexture::transitionLayout(vk::ImageLayout newLayout, vk::CommandBuffer cmd)
    {
        vk::ImageMemoryBarrier2 barrier{};
        barrier.oldLayout = m_currentLayout;
        barrier.newLayout = newLayout;
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.image = m_image;

        // Determine aspect mask
        vk::Format vkFormat = VulkanUtils::toVkFormat(m_format);
        if (vkFormat == vk::Format::eD16Unorm ||
            vkFormat == vk::Format::eD32Sfloat ||
            vkFormat == vk::Format::eD24UnormS8Uint ||
            vkFormat == vk::Format::eD32SfloatS8Uint)
        {
            barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eDepth;
            if (vkFormat == vk::Format::eD24UnormS8Uint ||
                vkFormat == vk::Format::eD32SfloatS8Uint)
            {
                barrier.subresourceRange.aspectMask |= vk::ImageAspectFlagBits::eStencil;
            }
        }
        else
        {
            barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
        }

        barrier.subresourceRange.baseMipLevel = 0;
        barrier.subresourceRange.levelCount = m_mipLevels;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = m_arrayLayers;

        vk::PipelineStageFlags2 sourceStage;
        vk::PipelineStageFlags2 destinationStage;

        // Configure barrier based on layout transition
        if (m_currentLayout == vk::ImageLayout::eUndefined &&
            newLayout == vk::ImageLayout::eTransferDstOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlags2{};
            barrier.dstAccessMask = vk::AccessFlagBits2::eTransferWrite;
            sourceStage = vk::PipelineStageFlagBits2::eNone;
            destinationStage = vk::PipelineStageFlagBits2::eTransfer;
        }
        else if (m_currentLayout == vk::ImageLayout::eTransferDstOptimal &&
            newLayout == vk::ImageLayout::eShaderReadOnlyOptimal)
        {
            barrier.srcAccessMask = vk::AccessFlagBits2::eTransferWrite;
            barrier.dstAccessMask = vk::AccessFlagBits2::eShaderRead;
            sourceStage = vk::PipelineStageFlagBits2::eTransfer;
            destinationStage = vk::PipelineStageFlagBits2::eFragmentShader;
        }
        else
        {
            // General case
            barrier.srcAccessMask = vk::AccessFlagBits2::eMemoryRead | vk::AccessFlagBits2::eMemoryWrite;
            barrier.dstAccessMask = vk::AccessFlagBits2::eMemoryRead | vk::AccessFlagBits2::eMemoryWrite;
            sourceStage = vk::PipelineStageFlagBits2::eAllCommands;
            destinationStage = vk::PipelineStageFlagBits2::eAllCommands;
        }

        barrier.srcStageMask = sourceStage;
        barrier.dstStageMask = destinationStage;

        vk::DependencyInfo depInfo{};
        depInfo.dependencyFlags = vk::DependencyFlags{};
        depInfo.imageMemoryBarrierCount = 1;
        depInfo.pImageMemoryBarriers = &barrier;

        cmd.pipelineBarrier2(depInfo);

        m_currentLayout = newLayout;
    }

    void VulkanRHITexture::generateMipmaps()
    {
        // Create command buffer
        auto cmdBuffer = m_device->createCommandBuffer();
        cmdBuffer->begin();

        vk::CommandBuffer cmd = static_cast<VulkanRHICommandBuffer*>(cmdBuffer.get())->commandBuffer();

        vk::ImageMemoryBarrier2 barrier{};
        barrier.image = m_image;
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = m_arrayLayers;
        barrier.subresourceRange.levelCount = 1;

        int32_t mipWidth = static_cast<int32_t>(m_extent.width);
        int32_t mipHeight = static_cast<int32_t>(m_extent.height);

        for (uint32_t i = 1; i < m_mipLevels; i++)
        {
            // Transition previous mip level to transfer src
            barrier.subresourceRange.baseMipLevel = i - 1;
            barrier.oldLayout = vk::ImageLayout::eTransferDstOptimal;
            barrier.newLayout = vk::ImageLayout::eTransferSrcOptimal;
            barrier.srcAccessMask = vk::AccessFlagBits2::eTransferWrite;
            barrier.dstAccessMask = vk::AccessFlagBits2::eTransferRead;
            barrier.srcStageMask = vk::PipelineStageFlagBits2::eTransfer;
            barrier.dstStageMask = vk::PipelineStageFlagBits2::eTransfer;

            vk::DependencyInfo depInfo{};
            depInfo.dependencyFlags = vk::DependencyFlags{};
            depInfo.imageMemoryBarrierCount = 1;
            depInfo.pImageMemoryBarriers = &barrier;
            cmd.pipelineBarrier2(depInfo);

            // Blit from previous level to current level
            vk::ImageBlit blit{};
            blit.srcOffsets[0] = vk::Offset3D{0, 0, 0};
            blit.srcOffsets[1] = vk::Offset3D{mipWidth, mipHeight, 1};
            blit.srcSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
            blit.srcSubresource.mipLevel = i - 1;
            blit.srcSubresource.baseArrayLayer = 0;
            blit.srcSubresource.layerCount = m_arrayLayers;

            int32_t nextMipWidth = mipWidth > 1 ? mipWidth / 2 : 1;
            int32_t nextMipHeight = mipHeight > 1 ? mipHeight / 2 : 1;

            blit.dstOffsets[0] = vk::Offset3D{0, 0, 0};
            blit.dstOffsets[1] = vk::Offset3D{nextMipWidth, nextMipHeight, 1};
            blit.dstSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
            blit.dstSubresource.mipLevel = i;
            blit.dstSubresource.baseArrayLayer = 0;
            blit.dstSubresource.layerCount = m_arrayLayers;

            cmd.blitImage(
                m_image, vk::ImageLayout::eTransferSrcOptimal,
                m_image, vk::ImageLayout::eTransferDstOptimal,
                1, &blit,
                vk::Filter::eLinear
            );

            // Transition previous mip level to shader read
            barrier.oldLayout = vk::ImageLayout::eTransferSrcOptimal;
            barrier.newLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
            barrier.srcAccessMask = vk::AccessFlagBits2::eTransferRead;
            barrier.dstAccessMask = vk::AccessFlagBits2::eShaderRead;
            barrier.srcStageMask = vk::PipelineStageFlagBits2::eTransfer;
            barrier.dstStageMask = vk::PipelineStageFlagBits2::eFragmentShader;

            depInfo.dependencyFlags = vk::DependencyFlags{};
            depInfo.imageMemoryBarrierCount = 1;
            depInfo.pImageMemoryBarriers = &barrier;
            cmd.pipelineBarrier2(depInfo);

            mipWidth = nextMipWidth;
            mipHeight = nextMipHeight;
        }

        // Transition last mip level to shader read
        barrier.subresourceRange.baseMipLevel = m_mipLevels - 1;
        barrier.oldLayout = vk::ImageLayout::eTransferDstOptimal;
        barrier.newLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
        barrier.srcAccessMask = vk::AccessFlagBits2::eTransferWrite;
        barrier.dstAccessMask = vk::AccessFlagBits2::eShaderRead;
        barrier.srcStageMask = vk::PipelineStageFlagBits2::eTransfer;
        barrier.dstStageMask = vk::PipelineStageFlagBits2::eFragmentShader;

        vk::DependencyInfo depInfo{};
        depInfo.dependencyFlags = vk::DependencyFlags{};
        depInfo.imageMemoryBarrierCount = 1;
        depInfo.pImageMemoryBarriers = &barrier;
        cmd.pipelineBarrier2(depInfo);

        cmdBuffer->end();

        // Submit and wait
        m_device->submitCommands(cmdBuffer.get());
        m_device->waitIdle();

        m_currentLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
    }
} // namespace pnkr::renderer::rhi::vulkan
</file>

<file path="src/rhi/vulkan/vulkan_utils.cpp">
#include "pnkr/rhi/vulkan/vulkan_utils.hpp"

#include <stdexcept>

namespace pnkr::renderer::rhi::vulkan
{
    vk::Format VulkanUtils::toVkFormat(Format format)
    {
        switch (format)
        {
        case Format::Undefined: return vk::Format::eUndefined;

        // Color formats
        case Format::R8_UNORM: return vk::Format::eR8Unorm;
        case Format::R8G8_UNORM: return vk::Format::eR8G8Unorm;
        case Format::R8G8B8_UNORM: return vk::Format::eR8G8B8Unorm;
        case Format::R8G8B8A8_UNORM: return vk::Format::eR8G8B8A8Unorm;
        case Format::R8G8B8A8_SRGB: return vk::Format::eR8G8B8A8Srgb;
        case Format::B8G8R8A8_UNORM: return vk::Format::eB8G8R8A8Unorm;
        case Format::B8G8R8A8_SRGB: return vk::Format::eB8G8R8A8Srgb;

        case Format::R16_SFLOAT: return vk::Format::eR16Sfloat;
        case Format::R16G16_SFLOAT: return vk::Format::eR16G16Sfloat;
        case Format::R16G16B16A16_SFLOAT: return vk::Format::eR16G16B16A16Sfloat;

        case Format::R32_SFLOAT: return vk::Format::eR32Sfloat;
        case Format::R32G32_SFLOAT: return vk::Format::eR32G32Sfloat;
        case Format::R32G32B32_SFLOAT: return vk::Format::eR32G32B32Sfloat;
        case Format::R32G32B32A32_SFLOAT: return vk::Format::eR32G32B32A32Sfloat;

        // Depth/stencil
        case Format::D16_UNORM: return vk::Format::eD16Unorm;
        case Format::D32_SFLOAT: return vk::Format::eD32Sfloat;
        case Format::D24_UNORM_S8_UINT: return vk::Format::eD24UnormS8Uint;
        case Format::D32_SFLOAT_S8_UINT: return vk::Format::eD32SfloatS8Uint;

        // Compressed
        case Format::BC1_RGB_UNORM: return vk::Format::eBc1RgbUnormBlock;
        case Format::BC1_RGB_SRGB: return vk::Format::eBc1RgbSrgbBlock;
        case Format::BC3_UNORM: return vk::Format::eBc3UnormBlock;
        case Format::BC3_SRGB: return vk::Format::eBc3SrgbBlock;
        case Format::BC7_UNORM: return vk::Format::eBc7UnormBlock;
        case Format::BC7_SRGB: return vk::Format::eBc7SrgbBlock;

        default: return vk::Format::eUndefined;
        }
    }

    Format VulkanUtils::fromVkFormat(vk::Format format)
    {
        switch (format)
        {
        case vk::Format::eUndefined: return Format::Undefined;

        case vk::Format::eR8Unorm: return Format::R8_UNORM;
        case vk::Format::eR8G8Unorm: return Format::R8G8_UNORM;
        case vk::Format::eR8G8B8Unorm: return Format::R8G8B8_UNORM;
        case vk::Format::eR8G8B8A8Unorm: return Format::R8G8B8A8_UNORM;
        case vk::Format::eR8G8B8A8Srgb: return Format::R8G8B8A8_SRGB;
        case vk::Format::eB8G8R8A8Unorm: return Format::B8G8R8A8_UNORM;
        case vk::Format::eB8G8R8A8Srgb: return Format::B8G8R8A8_SRGB;

        case vk::Format::eR16Sfloat: return Format::R16_SFLOAT;
        case vk::Format::eR16G16Sfloat: return Format::R16G16_SFLOAT;
        case vk::Format::eR16G16B16A16Sfloat: return Format::R16G16B16A16_SFLOAT;

        case vk::Format::eR32Sfloat: return Format::R32_SFLOAT;
        case vk::Format::eR32G32Sfloat: return Format::R32G32_SFLOAT;
        case vk::Format::eR32G32B32Sfloat: return Format::R32G32B32_SFLOAT;
        case vk::Format::eR32G32B32A32Sfloat: return Format::R32G32B32A32_SFLOAT;

        case vk::Format::eD16Unorm: return Format::D16_UNORM;
        case vk::Format::eD32Sfloat: return Format::D32_SFLOAT;
        case vk::Format::eD24UnormS8Uint: return Format::D24_UNORM_S8_UINT;
        case vk::Format::eD32SfloatS8Uint: return Format::D32_SFLOAT_S8_UINT;

        default: return Format::Undefined;
        }
    }

    vk::BufferUsageFlags VulkanUtils::toVkBufferUsage(BufferUsage usage)
    {
        vk::BufferUsageFlags flags{};

        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::TransferSrc))
            flags |= vk::BufferUsageFlagBits::eTransferSrc;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::TransferDst))
            flags |= vk::BufferUsageFlagBits::eTransferDst;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::UniformBuffer))
            flags |= vk::BufferUsageFlagBits::eUniformBuffer;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::StorageBuffer))
            flags |= vk::BufferUsageFlagBits::eStorageBuffer;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::IndexBuffer))
            flags |= vk::BufferUsageFlagBits::eIndexBuffer;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::VertexBuffer))
            flags |= vk::BufferUsageFlagBits::eVertexBuffer;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(BufferUsage::IndirectBuffer))
            flags |= vk::BufferUsageFlagBits::eIndirectBuffer;

        return flags;
    }

    BufferUsage VulkanUtils::fromVkBufferUsage(vk::BufferUsageFlags flags)
    {
        uint32_t usage = 0;

        if (flags & vk::BufferUsageFlagBits::eTransferSrc)
            usage |= static_cast<uint32_t>(BufferUsage::TransferSrc);
        if (flags & vk::BufferUsageFlagBits::eTransferDst)
            usage |= static_cast<uint32_t>(BufferUsage::TransferDst);
        if (flags & vk::BufferUsageFlagBits::eUniformBuffer)
            usage |= static_cast<uint32_t>(BufferUsage::UniformBuffer);
        if (flags & vk::BufferUsageFlagBits::eStorageBuffer)
            usage |= static_cast<uint32_t>(BufferUsage::StorageBuffer);
        if (flags & vk::BufferUsageFlagBits::eIndexBuffer)
            usage |= static_cast<uint32_t>(BufferUsage::IndexBuffer);
        if (flags & vk::BufferUsageFlagBits::eVertexBuffer)
            usage |= static_cast<uint32_t>(BufferUsage::VertexBuffer);
        if (flags & vk::BufferUsageFlagBits::eIndirectBuffer)
            usage |= static_cast<uint32_t>(BufferUsage::IndirectBuffer);

        return static_cast<BufferUsage>(usage);
    }

    vk::ImageUsageFlags VulkanUtils::toVkImageUsage(TextureUsage usage)
    {
        vk::ImageUsageFlags flags{};

        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::TransferSrc))
            flags |= vk::ImageUsageFlagBits::eTransferSrc;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::TransferDst))
            flags |= vk::ImageUsageFlagBits::eTransferDst;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::Sampled))
            flags |= vk::ImageUsageFlagBits::eSampled;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::Storage))
            flags |= vk::ImageUsageFlagBits::eStorage;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::ColorAttachment))
            flags |= vk::ImageUsageFlagBits::eColorAttachment;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::DepthStencilAttachment))
            flags |= vk::ImageUsageFlagBits::eDepthStencilAttachment;
        if (static_cast<uint32_t>(usage) & static_cast<uint32_t>(TextureUsage::InputAttachment))
            flags |= vk::ImageUsageFlagBits::eInputAttachment;

        return flags;
    }

    TextureUsage VulkanUtils::fromVkImageUsage(vk::ImageUsageFlags flags)
    {
        uint32_t usage = 0;

        if (flags & vk::ImageUsageFlagBits::eTransferSrc)
            usage |= static_cast<uint32_t>(TextureUsage::TransferSrc);
        if (flags & vk::ImageUsageFlagBits::eTransferDst)
            usage |= static_cast<uint32_t>(TextureUsage::TransferDst);
        if (flags & vk::ImageUsageFlagBits::eSampled)
            usage |= static_cast<uint32_t>(TextureUsage::Sampled);
        if (flags & vk::ImageUsageFlagBits::eStorage)
            usage |= static_cast<uint32_t>(TextureUsage::Storage);
        if (flags & vk::ImageUsageFlagBits::eColorAttachment)
            usage |= static_cast<uint32_t>(TextureUsage::ColorAttachment);
        if (flags & vk::ImageUsageFlagBits::eDepthStencilAttachment)
            usage |= static_cast<uint32_t>(TextureUsage::DepthStencilAttachment);

        return static_cast<TextureUsage>(usage);
    }

    VmaMemoryUsage VulkanUtils::toVmaMemoryUsage(MemoryUsage usage)
    {
        switch (usage)
        {
        case MemoryUsage::GPUOnly: return VMA_MEMORY_USAGE_GPU_ONLY;
        case MemoryUsage::CPUToGPU: return VMA_MEMORY_USAGE_CPU_TO_GPU;
        case MemoryUsage::GPUToCPU: return VMA_MEMORY_USAGE_GPU_TO_CPU;
        case MemoryUsage::CPUOnly: return VMA_MEMORY_USAGE_CPU_ONLY;
        default: return VMA_MEMORY_USAGE_AUTO;
        }
    }

    vk::ShaderStageFlags VulkanUtils::toVkShaderStage(ShaderStage stage)
    {
        vk::ShaderStageFlags flags{};

        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Vertex))
            flags |= vk::ShaderStageFlagBits::eVertex;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Fragment))
            flags |= vk::ShaderStageFlagBits::eFragment;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Geometry))
            flags |= vk::ShaderStageFlagBits::eGeometry;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Compute))
            flags |= vk::ShaderStageFlagBits::eCompute;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::TessControl))
            flags |= vk::ShaderStageFlagBits::eTessellationControl;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::TessEval))
            flags |= vk::ShaderStageFlagBits::eTessellationEvaluation;

        return flags;
    }

    ShaderStage VulkanUtils::fromVkShaderStage(vk::ShaderStageFlags flags)
    {
        uint32_t stage = 0;

        if (flags & vk::ShaderStageFlagBits::eVertex)
            stage |= static_cast<uint32_t>(ShaderStage::Vertex);
        if (flags & vk::ShaderStageFlagBits::eFragment)
            stage |= static_cast<uint32_t>(ShaderStage::Fragment);
        if (flags & vk::ShaderStageFlagBits::eGeometry)
            stage |= static_cast<uint32_t>(ShaderStage::Geometry);
        if (flags & vk::ShaderStageFlagBits::eCompute)
            stage |= static_cast<uint32_t>(ShaderStage::Compute);
        if (flags & vk::ShaderStageFlagBits::eTessellationControl)
            stage |= static_cast<uint32_t>(ShaderStage::TessControl);
        if (flags & vk::ShaderStageFlagBits::eTessellationEvaluation)
            stage |= static_cast<uint32_t>(ShaderStage::TessEval);

        return static_cast<ShaderStage>(stage);
    }

    vk::PipelineStageFlags2 VulkanUtils::toVkPipelineStage(ShaderStage stage)
    {
        if (stage == ShaderStage::None)
            return vk::PipelineStageFlagBits2::eNone;
        // Treat "All" as a generic sync point without injecting unsupported shader stages.
        if (stage == ShaderStage::All)
            return vk::PipelineStageFlagBits2::eAllCommands;

        if (stage == ShaderStage::Host)
            return vk::PipelineStageFlagBits2::eHost; // <--- Map to Host

        vk::PipelineStageFlags2 flags{};
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Vertex))
            flags |= vk::PipelineStageFlagBits2::eVertexShader;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Fragment))
            flags |= vk::PipelineStageFlagBits2::eFragmentShader;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Geometry))
            flags |= vk::PipelineStageFlagBits2::eGeometryShader;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Compute))
            flags |= vk::PipelineStageFlagBits2::eComputeShader;

        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::TessEval))
            flags |= vk::PipelineStageFlagBits2::eTessellationEvaluationShader;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::TessControl))
            flags |= vk::PipelineStageFlagBits2::eTessellationControlShader;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::RenderTarget))
            flags |= vk::PipelineStageFlagBits2::eColorAttachmentOutput |
                vk::PipelineStageFlagBits2::eEarlyFragmentTests |
                vk::PipelineStageFlagBits2::eLateFragmentTests;
        if (static_cast<uint32_t>(stage) & static_cast<uint32_t>(ShaderStage::Transfer))
            flags |= vk::PipelineStageFlagBits2::eTransfer;

        return flags;
    }

    vk::ImageLayout VulkanUtils::toVkImageLayout(ResourceLayout layout)
    {
        switch (layout)
        {
        case ResourceLayout::Undefined: return vk::ImageLayout::eUndefined;
        case ResourceLayout::General: return vk::ImageLayout::eGeneral;
        case ResourceLayout::ColorAttachment: return vk::ImageLayout::eColorAttachmentOptimal;
        case ResourceLayout::DepthStencilAttachment: return vk::ImageLayout::eDepthStencilAttachmentOptimal;
        case ResourceLayout::DepthStencilReadOnly: return vk::ImageLayout::eDepthStencilReadOnlyOptimal;
        case ResourceLayout::ShaderReadOnly: return vk::ImageLayout::eShaderReadOnlyOptimal;
        case ResourceLayout::TransferSrc: return vk::ImageLayout::eTransferSrcOptimal;
        case ResourceLayout::TransferDst: return vk::ImageLayout::eTransferDstOptimal;
        case ResourceLayout::Present: return vk::ImageLayout::ePresentSrcKHR;
        default: return vk::ImageLayout::eUndefined;
        }
    }

    vk::PrimitiveTopology VulkanUtils::toVkTopology(PrimitiveTopology topology)
    {
        switch (topology)
        {
        case PrimitiveTopology::PointList: return vk::PrimitiveTopology::ePointList;
        case PrimitiveTopology::LineList: return vk::PrimitiveTopology::eLineList;
        case PrimitiveTopology::LineStrip: return vk::PrimitiveTopology::eLineStrip;
        case PrimitiveTopology::TriangleList: return vk::PrimitiveTopology::eTriangleList;
        case PrimitiveTopology::TriangleStrip: return vk::PrimitiveTopology::eTriangleStrip;
        case PrimitiveTopology::TriangleFan: return vk::PrimitiveTopology::eTriangleFan;
        default: return vk::PrimitiveTopology::eTriangleList;
        }
    }

    PrimitiveTopology VulkanUtils::fromVkTopology(vk::PrimitiveTopology topology)
    {
        switch (topology)
        {
        case vk::PrimitiveTopology::ePointList: return PrimitiveTopology::PointList;
        case vk::PrimitiveTopology::eLineList: return PrimitiveTopology::LineList;
        case vk::PrimitiveTopology::eLineStrip: return PrimitiveTopology::LineStrip;
        case vk::PrimitiveTopology::eTriangleList: return PrimitiveTopology::TriangleList;
        case vk::PrimitiveTopology::eTriangleStrip: return PrimitiveTopology::TriangleStrip;
        case vk::PrimitiveTopology::eTriangleFan: return PrimitiveTopology::TriangleFan;
        default: return PrimitiveTopology::TriangleList;
        }
    }

    vk::PolygonMode VulkanUtils::toVkPolygonMode(PolygonMode mode)
    {
        switch (mode)
        {
        case PolygonMode::Fill: return vk::PolygonMode::eFill;
        case PolygonMode::Line: return vk::PolygonMode::eLine;
        case PolygonMode::Point: return vk::PolygonMode::ePoint;
        default: return vk::PolygonMode::eFill;
        }
    }

    PolygonMode VulkanUtils::fromVkPolygonMode(vk::PolygonMode mode)
    {
        switch (mode)
        {
        case vk::PolygonMode::eFill: return PolygonMode::Fill;
        case vk::PolygonMode::eLine: return PolygonMode::Line;
        case vk::PolygonMode::ePoint: return PolygonMode::Point;
        default: return PolygonMode::Fill;
        }
    }

    vk::CullModeFlags VulkanUtils::toVkCullMode(CullMode mode)
    {
        switch (mode)
        {
        case CullMode::None: return vk::CullModeFlagBits::eNone;
        case CullMode::Front: return vk::CullModeFlagBits::eFront;
        case CullMode::Back: return vk::CullModeFlagBits::eBack;
        case CullMode::FrontAndBack: return vk::CullModeFlagBits::eFrontAndBack;
        default: return vk::CullModeFlagBits::eNone;
        }
    }

    CullMode VulkanUtils::fromVkCullMode(vk::CullModeFlags flags)
    {
        if (flags & vk::CullModeFlagBits::eFrontAndBack) return CullMode::FrontAndBack;
        if (flags & vk::CullModeFlagBits::eFront) return CullMode::Front;
        if (flags & vk::CullModeFlagBits::eBack) return CullMode::Back;
        return CullMode::None;
    }

    vk::CompareOp VulkanUtils::toVkCompareOp(CompareOp op)
    {
        switch (op)
        {
        case CompareOp::Never: return vk::CompareOp::eNever;
        case CompareOp::Less: return vk::CompareOp::eLess;
        case CompareOp::Equal: return vk::CompareOp::eEqual;
        case CompareOp::LessOrEqual: return vk::CompareOp::eLessOrEqual;
        case CompareOp::Greater: return vk::CompareOp::eGreater;
        case CompareOp::NotEqual: return vk::CompareOp::eNotEqual;
        case CompareOp::GreaterOrEqual: return vk::CompareOp::eGreaterOrEqual;
        case CompareOp::Always: return vk::CompareOp::eAlways;
        default: return vk::CompareOp::eLess;
        }
    }

    CompareOp VulkanUtils::fromVkCompareOp(vk::CompareOp op)
    {
        switch (op)
        {
        case vk::CompareOp::eNever: return CompareOp::Never;
        case vk::CompareOp::eLess: return CompareOp::Less;
        case vk::CompareOp::eEqual: return CompareOp::Equal;
        case vk::CompareOp::eLessOrEqual: return CompareOp::LessOrEqual;
        case vk::CompareOp::eGreater: return CompareOp::Greater;
        case vk::CompareOp::eNotEqual: return CompareOp::NotEqual;
        case vk::CompareOp::eGreaterOrEqual: return CompareOp::GreaterOrEqual;
        case vk::CompareOp::eAlways: return CompareOp::Always;
        default: return CompareOp::Less;
        }
    }

    vk::BlendFactor VulkanUtils::toVkBlendFactor(BlendFactor factor)
    {
        switch (factor)
        {
        case BlendFactor::Zero: return vk::BlendFactor::eZero;
        case BlendFactor::One: return vk::BlendFactor::eOne;
        case BlendFactor::SrcColor: return vk::BlendFactor::eSrcColor;
        case BlendFactor::OneMinusSrcColor: return vk::BlendFactor::eOneMinusSrcColor;
        case BlendFactor::DstColor: return vk::BlendFactor::eDstColor;
        case BlendFactor::OneMinusDstColor: return vk::BlendFactor::eOneMinusDstColor;
        case BlendFactor::SrcAlpha: return vk::BlendFactor::eSrcAlpha;
        case BlendFactor::OneMinusSrcAlpha: return vk::BlendFactor::eOneMinusSrcAlpha;
        case BlendFactor::DstAlpha: return vk::BlendFactor::eDstAlpha;
        case BlendFactor::OneMinusDstAlpha: return vk::BlendFactor::eOneMinusDstAlpha;
        default: return vk::BlendFactor::eOne;
        }
    }

    BlendFactor VulkanUtils::fromVkBlendFactor(vk::BlendFactor factor)
    {
        switch (factor)
        {
        case vk::BlendFactor::eZero: return BlendFactor::Zero;
        case vk::BlendFactor::eOne: return BlendFactor::One;
        case vk::BlendFactor::eSrcColor: return BlendFactor::SrcColor;
        case vk::BlendFactor::eOneMinusSrcColor: return BlendFactor::OneMinusSrcColor;
        case vk::BlendFactor::eDstColor: return BlendFactor::DstColor;
        case vk::BlendFactor::eOneMinusDstColor: return BlendFactor::OneMinusDstColor;
        case vk::BlendFactor::eSrcAlpha: return BlendFactor::SrcAlpha;
        case vk::BlendFactor::eOneMinusSrcAlpha: return BlendFactor::OneMinusSrcAlpha;
        case vk::BlendFactor::eDstAlpha: return BlendFactor::DstAlpha;
        case vk::BlendFactor::eOneMinusDstAlpha: return BlendFactor::OneMinusDstAlpha;
        default: return BlendFactor::One;
        }
    }

    vk::BlendOp VulkanUtils::toVkBlendOp(BlendOp op)
    {
        switch (op)
        {
        case BlendOp::Add: return vk::BlendOp::eAdd;
        case BlendOp::Subtract: return vk::BlendOp::eSubtract;
        case BlendOp::ReverseSubtract: return vk::BlendOp::eReverseSubtract;
        case BlendOp::Min: return vk::BlendOp::eMin;
        case BlendOp::Max: return vk::BlendOp::eMax;
        default: return vk::BlendOp::eAdd;
        }
    }

    BlendOp VulkanUtils::fromVkBlendOp(vk::BlendOp op)
    {
        switch (op)
        {
        case vk::BlendOp::eAdd: return BlendOp::Add;
        case vk::BlendOp::eSubtract: return BlendOp::Subtract;
        case vk::BlendOp::eReverseSubtract: return BlendOp::ReverseSubtract;
        case vk::BlendOp::eMin: return BlendOp::Min;
        case vk::BlendOp::eMax: return BlendOp::Max;
        default: return BlendOp::Add;
        }
    }

    vk::Filter VulkanUtils::toVkFilter(Filter filter)
    {
        switch (filter)
        {
        case Filter::Nearest: return vk::Filter::eNearest;
        case Filter::Linear: return vk::Filter::eLinear;
        default: return vk::Filter::eLinear;
        }
    }

    Filter VulkanUtils::fromVkFilter(vk::Filter filter)
    {
        switch (filter)
        {
        case vk::Filter::eNearest: return Filter::Nearest;
        case vk::Filter::eLinear: return Filter::Linear;
        default: return Filter::Linear;
        }
    }

    vk::SamplerAddressMode VulkanUtils::toVkAddressMode(SamplerAddressMode mode)
    {
        switch (mode)
        {
        case SamplerAddressMode::Repeat: return vk::SamplerAddressMode::eRepeat;
        case SamplerAddressMode::MirroredRepeat: return vk::SamplerAddressMode::eMirroredRepeat;
        case SamplerAddressMode::ClampToEdge: return vk::SamplerAddressMode::eClampToEdge;
        case SamplerAddressMode::ClampToBorder: return vk::SamplerAddressMode::eClampToBorder;
        default: return vk::SamplerAddressMode::eRepeat;
        }
    }

    SamplerAddressMode VulkanUtils::fromVkAddressMode(vk::SamplerAddressMode mode)
    {
        switch (mode)
        {
        case vk::SamplerAddressMode::eRepeat: return SamplerAddressMode::Repeat;
        case vk::SamplerAddressMode::eMirroredRepeat: return SamplerAddressMode::MirroredRepeat;
        case vk::SamplerAddressMode::eClampToEdge: return SamplerAddressMode::ClampToEdge;
        case vk::SamplerAddressMode::eClampToBorder: return SamplerAddressMode::ClampToBorder;
        default: return SamplerAddressMode::Repeat;
        }
    }

    vk::AttachmentLoadOp VulkanUtils::toVkLoadOp(LoadOp op)
    {
        switch (op)
        {
        case LoadOp::Load: return vk::AttachmentLoadOp::eLoad;
        case LoadOp::Clear: return vk::AttachmentLoadOp::eClear;
        case LoadOp::DontCare: return vk::AttachmentLoadOp::eDontCare;
        default: return vk::AttachmentLoadOp::eDontCare;
        }
    }

    vk::AttachmentStoreOp VulkanUtils::toVkStoreOp(StoreOp op)
    {
        switch (op)
        {
        case StoreOp::Store: return vk::AttachmentStoreOp::eStore;
        case StoreOp::DontCare: return vk::AttachmentStoreOp::eDontCare;
        default: return vk::AttachmentStoreOp::eStore;
        }
    }

    vk::DescriptorType VulkanUtils::toVkDescriptorType(DescriptorType type)
    {
        switch (type)
        {
        case DescriptorType::Sampler: return vk::DescriptorType::eSampler;
        case DescriptorType::CombinedImageSampler: return vk::DescriptorType::eCombinedImageSampler;
        case DescriptorType::SampledImage: return vk::DescriptorType::eSampledImage;
        case DescriptorType::StorageImage: return vk::DescriptorType::eStorageImage;
        case DescriptorType::UniformBuffer: return vk::DescriptorType::eUniformBuffer;
        case DescriptorType::StorageBuffer: return vk::DescriptorType::eStorageBuffer;
        case DescriptorType::UniformBufferDynamic: return vk::DescriptorType::eUniformBufferDynamic;
        case DescriptorType::StorageBufferDynamic: return vk::DescriptorType::eStorageBufferDynamic;
        default: return vk::DescriptorType::eUniformBuffer;
        }
    }

    DescriptorType VulkanUtils::fromVkDescriptorType(vk::DescriptorType type)
    {
        switch (type)
        {
        case vk::DescriptorType::eSampler: return DescriptorType::Sampler;
        case vk::DescriptorType::eCombinedImageSampler: return DescriptorType::CombinedImageSampler;
        case vk::DescriptorType::eSampledImage: return DescriptorType::SampledImage;
        case vk::DescriptorType::eStorageImage: return DescriptorType::StorageImage;
        case vk::DescriptorType::eUniformBuffer: return DescriptorType::UniformBuffer;
        case vk::DescriptorType::eStorageBuffer: return DescriptorType::StorageBuffer;
        case vk::DescriptorType::eUniformBufferDynamic: return DescriptorType::UniformBufferDynamic;
        case vk::DescriptorType::eStorageBufferDynamic: return DescriptorType::StorageBufferDynamic;
        default: return DescriptorType::UniformBuffer;
        }
    }

    vk::Viewport VulkanUtils::toVkViewport(const Viewport& viewport)
    {
        return vk::Viewport{
            viewport.x,
            viewport.y,
            viewport.width,
            viewport.height,
            viewport.minDepth,
            viewport.maxDepth
        };
    }

    vk::Rect2D VulkanUtils::toVkRect2D(const Rect2D& rect)
    {
        return vk::Rect2D{
            vk::Offset2D{rect.x, rect.y},
            vk::Extent2D{rect.width, rect.height}
        };
    }

    vk::Extent2D VulkanUtils::toVkExtent2D(const Extent2D& extent)
    {
        return vk::Extent2D{extent.width, extent.height};
    }

    vk::Extent3D VulkanUtils::toVkExtent3D(const Extent3D& extent)
    {
        return vk::Extent3D{extent.width, extent.height, extent.depth};
    }

    vk::ClearValue VulkanUtils::toVkClearValue(const ClearValue& clearValue)
    {
        vk::ClearValue vkClear;

        if (clearValue.isDepthStencil)
        {
            vkClear.depthStencil.depth = clearValue.depthStencil.depth;
            vkClear.depthStencil.stencil = clearValue.depthStencil.stencil;
        }
        else
        {
            std::memcpy(vkClear.color.float32, clearValue.color.float32, sizeof(float) * 4);
        }

        return vkClear;
    }
} // namespace pnkr::renderer::rhi::vulkan
</file>

</files>
